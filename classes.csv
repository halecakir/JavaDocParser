,url,api,class,description
0,Bolts-Android/bolts,bolts,Class AggregateException,Aggregates multiple Throwables that may be thrown in the process of a task's execution.
1,Bolts-Android/bolts,bolts,Class AppLink,Contains App Link metadata relevant for navigation on this device derived from the HTML at a given URL.
2,Bolts-Android/bolts,bolts,Class AppLink.Target,"Represents a target defined in App Link metadata, consisting of at least a package name, and optionally a URL, class name (for explicit intent handling), and an app name."
3,Bolts-Android/bolts,bolts,Class AppLinkNavigation,"Represents a pending request to navigate to an App Link. Most developers will simply use navigateInBackground(Context, Uri) to open a URL, but developers can build custom requests with additional navigation and app data attached to them by creating AppLinkNavigations themselves."
4,Bolts-Android/bolts,bolts,Enum AppLinkNavigation.NavigationResult,The result of calling AppLinkNavigation.navigate(Context) on an AppLinkNavigation.
5,Bolts-Android/bolts,bolts,Interface AppLinkResolver,"Implement this interface to provide an alternate strategy for resolving App Links that may include pre-fetching, caching, or querying for App Link data from an index provided by a service provider."
6,Bolts-Android/bolts,bolts,Class AppLinks,Provides a set of utility methods for working with incoming Intents that may contain App Link data.
7,Bolts-Android/bolts,bolts,Class Bolts,
8,Bolts-Android/bolts,bolts,Class CancellationToken,Propagates notification that operations should be canceled. Create an instance of CancellationTokenSource and pass the token returned from CancellationTokenSource#getToken() to the asynchronous operation(s). Call CancellationTokenSource#cancel() to cancel the operations. A CancellationToken can only be cancelled once - it should not be passed to future operations once cancelled.
9,Bolts-Android/bolts,bolts,Class CancellationTokenRegistration,Represents a callback delegate that has been registered with a CancellationToken.
10,Bolts-Android/bolts,bolts,Class CancellationTokenSource,Signals to a CancellationToken that it should be canceled. To create a CancellationToken first create a CancellationTokenSource then call getToken() to retrieve the token for the source.
11,Bolts-Android/bolts,bolts,Class Capture<T>,Provides a class that can be used for capturing variables in an anonymous class implementation.
12,Bolts-Android/bolts,bolts,"Interface Continuation<TTaskResult,TContinuationResult>",A function to be called after a task completes. If you wish to have the Task from a Continuation that does not return a Task be cancelled then throw a CancellationException from the Continuation.
13,Bolts-Android/bolts,bolts,Class ExecutorException,"This is a wrapper class for emphasizing that task failed due to bad Executor, rather than the continuation block it self."
14,Bolts-Android/bolts,bolts,Class MeasurementEvent,"Bolts raises events to the application by sending local broadcasts. Application integrated to Bolts can listen to events by registering BroadcastReceiver with intent filter MEASUREMENT_EVENT_NOTIFICATION_NAME. When receive the event, a String field MEASUREMENT_EVENT_NAME_KEY and A Bundle field @{link #MEASUREMENT_EVENT_ARGS_KEY} in Intent extra in indicate the event name and arguments with this event."
15,Bolts-Android/bolts,bolts,Class Task<TResult>,Represents the result of an asynchronous operation.
16,Bolts-Android/bolts,bolts,Interface Task.UnobservedExceptionHandler,"Interface for handlers invoked when a failed Task is about to be finalized, but the exception has not been consumed. The handler will execute in the GC thread, so if the handler needs to do anything time consuming or complex it is a good idea to fire off a Task to handle the exception."
17,Bolts-Android/bolts,bolts,Class TaskCompletionSource<TResult>,"Allows safe orchestration of a task's completion, preventing the consumer from prematurely completing the task. Essentially, it represents the producer side of a Task, providing access to the consumer side through the getTask() method while isolating the Task's completion mechanisms from the consumer."
18,Bolts-Android/bolts,bolts,Class UnobservedTaskException,Used to signify that a Task's error went unobserved.
19,Bolts-Android/bolts,bolts,Class WebViewAppLinkResolver,A reference implementation for an App Link resolver that uses a hidden WebView to parse the HTML containing App Link metadata.
20,glide/signature,com.bumptech.glide.signature,Class AndroidResourceSignature,Includes information about the package as well as whether or not the device is in night mode.
21,glide/gifencoder,com.bumptech.glide.gifencoder,Class AnimatedGifEncoder,"Class AnimatedGifEncoder - Encodes a GIF file consisting of one or more frames. Example: AnimatedGifEncoder e = new AnimatedGifEncoder(); e.start(outputFileName); e.setDelay(1000); // 1 frame per sec e.addFrame(image1); e.addFrame(image2); e.addFrame(image3, 100, 100); // set position of the frame e.finish(); No copyright asserted on the source code of this class. May be used for any purpose, however, refer to the Unisys LZW patent for restrictions on use of the associated LZWEncoder class. Please forward any corrections to kweiner@fmsware.com."
22,glide/module,com.bumptech.glide.module,Class AppGlideModule,"Defines a set of dependencies and options to use when initializing Glide within an application. There can be at most one AppGlideModule in an application. Only Applications can include a AppGlideModule. Libraries must use LibraryGlideModule. Classes that extend AppGlideModule must be annotated with GlideModule to be processed correctly. Classes that extend AppGlideModule can optionally be annotated with Excludes to optionally exclude one or more LibraryGlideModule and/or GlideModule classes. Once an application has migrated itself and all libraries it depends on to use Glide's annotation processor, AppGlideModule implementations should override isManifestParsingEnabled() and return false."
23,glide/signature,com.bumptech.glide.signature,Class ApplicationVersionSignature,A utility class for obtaining a Key signature containing the application version name using PackageInfo.versionCode.
24,request/target,com.bumptech.glide.request.target,Class AppWidgetTarget,"This class is used in order to display downloaded Bitmap inside an ImageView of an AppWidget through RemoteViews. Note - For cancellation to work correctly, you must pass in the same instance of this class for every subsequent load."
25,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Interface ArrayPool,Interface for an array pool that pools arrays of different types.
26,load/data,com.bumptech.glide.load.data,Class AssetFileDescriptorLocalUriFetcher,Fetches an AssetFileDescriptor for a local Uri.
27,load/data,com.bumptech.glide.load.data,Class AssetPathFetcher<T>,An abstract class for obtaining data for an asset path using an AssetManager.
28,load/model,com.bumptech.glide.load.model,Class AssetUriLoader<Data>,Loads a specific data type from an Asset Manager Uri.
29,load/model,com.bumptech.glide.load.model,Interface AssetUriLoader.AssetFetcherFactory<Data>,A factory to build a DataFetcher for a specific asset path.
30,load/model,com.bumptech.glide.load.model,Class AssetUriLoader.FileDescriptorFactory,Factory for loading ParcelFileDescriptors from asset manager Uris.
31,load/model,com.bumptech.glide.load.model,Class AssetUriLoader.StreamFactory,Factory for loading InputStreams from asset manager Uris.
32,model/stream,com.bumptech.glide.load.model.stream,Class BaseGlideUrlLoader<Model>,A base class for loading data over http/https. Can be subclassed for use with any model that can be translated in to InputStream data.
33,glide/request,com.bumptech.glide.request,Class BaseRequestOptions<T extends BaseRequestOptions<T>>,A base object to allow method sharing between RequestOptions and RequestBuilder. This class is not meant for general use and may change at any time.
34,request/target,com.bumptech.glide.request.target,Class BaseTarget<Z>,"Deprecated. Use CustomViewTarget if loading the content into a view, the download API if in the background (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a a fully implemented Target for any specialized use-cases. Using BaseView is unsafe if the user does not implement onLoadCleared(android.graphics.drawable.Drawable), resulting in recycled bitmaps being referenced from the UI and hard to root-cause crashes."
35,resource/transcode,com.bumptech.glide.load.resource.transcode,Class BitmapBytesTranscoder,"An ResourceTranscoder that converts Bitmaps into byte arrays using (android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)."
36,request/transition,com.bumptech.glide.request.transition,Class BitmapContainerTransitionFactory<R>,A TransitionFactory for complex types that have a Bitmap inside. The transitioning bitmap is wrapped in a BitmapDrawable. Most commonly used with DrawableCrossFadeFactory.
37,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapDrawableDecoder<DataType>,Decodes an BitmapDrawable for a data type.
38,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapDrawableEncoder,Encodes BitmapDrawables.
39,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapDrawableResource,A Resource that wraps an BitmapDrawableThis class ensures that every call to DrawableResource.get()} always returns a new BitmapDrawable to avoid rendering issues if used in multiple views and is also responsible for returning the underlying Bitmap to the given BitmapPool when the resource is recycled.
40,resource/transcode,com.bumptech.glide.load.resource.transcode,Class BitmapDrawableTranscoder,An ResourceTranscoder that converts Bitmaps into BitmapDrawables.
41,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapDrawableTransformation,Deprecated. Use DrawableTransformation instead.
42,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapEncoder,An ResourceEncoder that writes Bitmaps to OutputStreams. Bitmaps that return true from ()} are written using Bitmap.CompressFormat.PNG to preserve alpha and all other bitmaps are written using Bitmap.CompressFormat.JPEG.
43,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapImageDecoderResourceDecoder,Bitmap specific implementation of ImageDecoderResourceDecoder.
44,request/target,com.bumptech.glide.request.target,Class BitmapImageViewTarget,A Target that can display an Bitmap in an ImageView.
45,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Interface BitmapPool,An interface for a pool that allows users to reuse Bitmap objects.
46,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Class BitmapPoolAdapter,An BitmapPool implementation that rejects all Bitmaps added to it and always returns null from get.
47,engine/prefill,com.bumptech.glide.load.engine.prefill,Class BitmapPreFiller,A class for pre-filling Bitmaps in a BitmapPool.
48,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapResource,A resource wrapping a Bitmap object.
49,request/target,com.bumptech.glide.request.target,Class BitmapThumbnailImageViewTarget,Efficiently displays multiple Bitmaps loaded serially into a single View.
50,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapTransformation,"A simple Transformation for transforming Bitmaps that abstracts away dealing with Resource objects for subclasses. Use cases will look something like this: public class FillSpace extends BitmapTransformation { private static final String ID = ""com.bumptech.glide.transformations.FillSpace""; private static final byte[] ID_BYTES = ID.getBytes(Charset.forName(""UTF-8"")); @Override public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) { if (toTransform.getWidth() == outWidth && toTransform.getHeight() == outHeight) { return toTransform; } return Bitmap.createScaledBitmap(toTransform, outWidth, outHeight, true); } @Override public boolean equals(Object o) { return o instanceof FillSpace; } @Override public int hashCode() { return ID.hashCode(); } @Override public void updateDiskCacheKey(MessageDigest messageDigest) { messageDigest.update(ID_BYTES); } } Using the fully qualified class name as a static final String (not Class.getName() to avoid proguard obfuscation) is an easy way to implement Key.updateDiskCacheKey(java.security.MessageDigest)} correctly. If additional arguments are required they can be passed in to the constructor of the Transformation and then used to update the MessageDigest passed in to Key.updateDiskCacheKey(MessageDigest). If arguments are primitive types, they can typically easily be serialized using ByteBuffer. String types can be serialized with String.getBytes(Charset) using the constant Key.CHARSET. As with all Transformations, all subclasses must implement Object.equals(Object) and Object.hashCode() for memory caching to work correctly."
51,request/transition,com.bumptech.glide.request.transition,Class BitmapTransitionFactory,A TransitionFactory for Bitmaps that uses a Drawable transition factory to transition from an existing drawable already visible on the target to the new bitmap.
52,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class BitmapTransitionOptions,Contains Bitmap specific animation options.
53,load/data,com.bumptech.glide.load.data,Class BufferedOutputStream,An OutputStream implementation that recycles and re-uses byte[]s using the provided ArrayPool.
54,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Class ByteArrayAdapter,Adapter for handling primitive byte arrays.
55,load/model,com.bumptech.glide.load.model,Class ByteArrayLoader<Data>,"A base class to convert byte arrays to input streams so they can be decoded. This class is abstract because there is no simple/quick way to generate an id from the bytes themselves, so subclass must include an id."
56,load/model,com.bumptech.glide.load.model,Class ByteArrayLoader.ByteBufferFactory,Factory for ByteArrayLoader and ByteBuffer.
57,load/model,com.bumptech.glide.load.model,Interface ByteArrayLoader.Converter<Data>,Converts between a byte array a desired model class.
58,load/model,com.bumptech.glide.load.model,Class ByteArrayLoader.StreamFactory,Factory for ByteArrayLoader and InputStream.
59,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class ByteBufferBitmapDecoder,Decodes Bitmaps from ByteBuffers.
60,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class ByteBufferBitmapImageDecoderResourceDecoder,ByteBuffer specific implementation of ByteBufferBitmapImageDecoderResourceDecoder.
61,load/model,com.bumptech.glide.load.model,Class ByteBufferEncoder,Writes ByteBuffers to Files.
62,load/model,com.bumptech.glide.load.model,Class ByteBufferFileLoader,Loads ByteBuffers using NIO for File.
63,load/model,com.bumptech.glide.load.model,Class ByteBufferFileLoader.Factory,Factory for ByteBufferFileLoader.
64,resource/gif,com.bumptech.glide.load.resource.gif,Class ByteBufferGifDecoder,An ResourceDecoder that decodes GifDrawable from InputStream data.
65,resource/bytes,com.bumptech.glide.load.resource.bytes,Class ByteBufferRewinder,Rewinds ByteBuffers.
66,resource/bytes,com.bumptech.glide.load.resource.bytes,Class ByteBufferRewinder.Factory,Factory for ByteBufferRewinder.
67,glide/util,com.bumptech.glide.util,Class ByteBufferUtil,Utilities for interacting with ByteBuffers.
68,resource/bytes,com.bumptech.glide.load.resource.bytes,Class BytesResource,An Resource wrapping a byte array.
69,glide/util,com.bumptech.glide.util,"Class CachedHashCodeArrayMap<K,V>",An ArrayMap that caches its hashCode to support efficient lookup.
70,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class CenterCrop,"Scale the image so that either the width of the image matches the given width and the height of the image is greater than the given height or vice versa, and then crop the larger dimension to match the given dimension. Does not maintain the image's aspect ratio"
71,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class CenterInside,"Returns the image with its original size if its dimensions match or are smaller than the target's, couple with ImageView.ScaleType.CENTER_INSIDE in order to center it in Target. If not, then it is scaled so that one of the dimensions of the image will be equal to the given dimension and the other will be less than the given dimension (maintaining the image's aspect ratio)."
72,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class CircleCrop,"A Glide BitmapTransformation to circle crop an image. Behaves similar to a FitCenter transform, but the resulting image is masked to a circle. Uses a PorterDuff blend mode, see http://ssp.impulsetrain.com/porterduff.html."
73,glide/manager,com.bumptech.glide.manager,Interface ConnectivityMonitor,An interface for monitoring network connectivity events.
74,glide/manager,com.bumptech.glide.manager,Interface ConnectivityMonitor.ConnectivityListener,An interface for listening to network connectivity events picked up by the monitor.
75,glide/manager,com.bumptech.glide.manager,Interface ConnectivityMonitorFactory,A factory class that produces a functional ConnectivityMonitor.
76,glide/util,com.bumptech.glide.util,Class ContentLengthInputStream,Uses the content length as the basis for the return value of available() and verifies that at least content length bytes are returned from the various read methods.
77,request/target,com.bumptech.glide.request.target,Class CustomTarget<T>,"A base Target for loading resources (Bitmap, Drawable etc) that are used outside of Views. If you're loading a resource into a View, use RequestBuilder.into(ImageView), a subclass of ImageViewTarget, or CustomViewTarget. Using this class to load resources into Views can prevent Glide from correctly cancelling any previous loads, which may result in incorrect images appearing in the view, especially in scrolling views like RecyclerView. You MUST implement Target.onLoadCleared(Drawable) and ensure that all references to any resource passed into the target in Target.onResourceReady(Object, Transition) are removed before Target.onLoadCleared(Drawable) completes. Failing to do so can result in graphical corruption, crashes caused by recycled Bitmaps, and other undefined behavior. It is never safe to leave Target.onLoadCleared(Drawable) unimplemented or empty. Even if you do not manually clear this Target, Glide may do so automatically after certain lifecycle events in Fragments and Activitys. This class can only be used with Target.SIZE_ORIGINAL or when the desired resource dimensions are known when the Target is created. If you'd like to run some asynchronous process and make full use of getSize(SizeReadyCallback) and SizeReadyCallback, extend Target directly instead of using this class."
78,request/target,com.bumptech.glide.request.target,"Class CustomViewTarget<T extends android.view.View,Z>","A base Target for loading resources (Bitmap, Drawable etc) into Views that provides default implementations for most methods and can determine the size of views using a ViewTreeObserver.OnDrawListener."
79,load/data,com.bumptech.glide.load.data,Interface DataFetcher<T>,"Lazily retrieves data that can be used to load a resource. A new instance is created per resource load by ModelLoader. loadData(com.bumptech.glide.Priority, com.bumptech.glide.load.data.DataFetcher.DataCallback) may or may not be called for any given load depending on whether or not the corresponding resource is cached. Cancel also may or may not be called. If loadData(com.bumptech.glide.Priority, com.bumptech.glide.load.data.DataFetcher.DataCallback)} is called, then so cleanup() will be called."
80,load/data,com.bumptech.glide.load.data,Interface DataFetcher.DataCallback<T>,"Callback that must be called when data has been loaded and is available, or when the load fails."
81,load/data,com.bumptech.glide.load.data,Interface DataRewinder<T>,Responsible for rewinding a stream like data types.
82,load/data,com.bumptech.glide.load.data,Interface DataRewinder.Factory<T>,A factory interface for producing individual DataRewinders.
83,load/data,com.bumptech.glide.load.data,Class DataRewinderRegistry,Stores a mapping of data class to DataRewinder.Factory and allows registration of new types and factories.
84,glide/load,com.bumptech.glide.load,Enum DataSource,Indicates the origin of some retrieved data.
85,load/model,com.bumptech.glide.load.model,"Class DataUrlLoader<Model,Data>","A simple model loader for loading data from a Data URL String. Data URIs use the ""data"" scheme. See http://www.ietf.org/rfc/rfc2397.txt for a complete description of the 'data' URL scheme. Briefly, a 'data' URL has the form: data:[mediatype][;base64],some_data"
86,load/model,com.bumptech.glide.load.model,Interface DataUrlLoader.DataDecoder<Data>,Allows decoding a specific type of data from a Data URL String.
87,load/model,com.bumptech.glide.load.model,Class DataUrlLoader.StreamFactory<Model>,Factory for loading InputStreams from data uris.
88,glide/load,com.bumptech.glide.load,Enum DecodeFormat,"Options for setting the value of Bitmap.getConfig() for Bitmaps returned by ResourceDecoders. Note - In some cases it may not be possible to obey the requested setting, not all Downsamplers support setting formats and certain images may not be able to be loaded as certain configurations. Therefore this class represents a preference rather than a requirement."
89,load/engine,com.bumptech.glide.load.engine,"Class DecodePath<DataType,ResourceType,Transcode>",Attempts to decode and transcode resource type from a given data type.
90,glide/manager,com.bumptech.glide.manager,Class DefaultConnectivityMonitorFactory,A factory class that produces a functional ConnectivityMonitor if the application has the android.permission.ACCESS_NETWORK_STATE permission and a no-op non functional ConnectivityMonitor if the app does not have the required permission.
91,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class DefaultImageHeaderParser,A class for parsing the exif orientation and other data from an image header.
92,engine/cache,com.bumptech.glide.load.engine.cache,Interface DiskCache,An interface for writing to and reading from a disk cache.
93,engine/cache,com.bumptech.glide.load.engine.cache,Interface DiskCache.Factory,An interface for lazily creating a disk cache.
94,engine/cache,com.bumptech.glide.load.engine.cache,Interface DiskCache.Writer,An interface to actually write data to a key in the disk cache.
95,engine/cache,com.bumptech.glide.load.engine.cache,Class DiskCacheAdapter,A simple class that returns null for all gets and ignores all writes.
96,engine/cache,com.bumptech.glide.load.engine.cache,Class DiskCacheAdapter.Factory,Default factory for DiskCacheAdapter.
97,load/engine,com.bumptech.glide.load.engine,Class DiskCacheStrategy,Set of available caching strategies for media.
98,glide/disklrucache,com.bumptech.glide.disklrucache,Class DiskLruCache,"A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key and a fixed number of values. Each key must match the regex [a-z0-9_-]{1,120}. Values are byte sequences, accessible as streams or files. Each value must be between 0 and Integer.MAX_VALUE bytes in length. The cache stores its data in a directory on the filesystem. This directory must be exclusive to the cache; the cache may delete or overwrite files from its directory. It is an error for multiple processes to use the same cache directory at the same time. This cache limits the number of bytes that it will store on the filesystem. When the number of stored bytes exceeds the limit, the cache will remove entries in the background until the limit is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for files to be deleted. The limit does not include filesystem overhead or the cache journal so space-sensitive applications should set a conservative limit. Clients call edit(java.lang.String) to create or update the values of an entry. An entry may have only one editor at one time; if a value is not available to be edited then edit(java.lang.String) will return null. When an entry is being created it is necessary to supply a full set of values; the empty value should be used as a placeholder if necessary. When an entry is being edited, it is not necessary to supply data for every value; values default to their previous value. Every edit(java.lang.String) call must be matched by a call to DiskLruCache.Editor.commit() or DiskLruCache.Editor.abort(). Committing is atomic: a read observes the full set of values as they were before or after the commit, but never a mix of values. Clients call get(java.lang.String) to read a snapshot of an entry. The read will observe the value at the time that get(java.lang.String) was called. Updates and removals after the call do not impact ongoing reads. This class is tolerant of some I/O errors. If files are missing from the filesystem, the corresponding entries will be dropped from the cache. If an error occurs while writing a cache value, the edit will fail silently. Callers should handle other problems by catching IOException and responding appropriately."
99,engine/cache,com.bumptech.glide.load.engine.cache,Class DiskLruCacheFactory,"Creates an DiskLruCache based disk cache in the specified disk cache directory. If you need to make I/O access before returning the cache directory use the DiskLruCacheFactory(CacheDirectoryGetter, long) constructor variant."
100,engine/cache,com.bumptech.glide.load.engine.cache,Interface DiskLruCacheFactory.CacheDirectoryGetter,Interface called out of UI thread to get the cache folder.
101,engine/cache,com.bumptech.glide.load.engine.cache,Class DiskLruCacheWrapper,The default DiskCache implementation. There must be no more than one active instance for a given directory at a time.
102,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class Downsampler,"Downsamples, decodes, and rotates images according to their exif orientation using BitmapFactory."
103,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Interface Downsampler.DecodeCallbacks,Callbacks for key points during decodes.
104,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class DownsampleStrategy,"Indicates the algorithm to use when downsampling images. DownsampleStrategy does not provide any guarantees about output sizes. Behavior will differ depending on the ResourceDecoder using the strategy and the version of Android the code runs on. Use DownsampleStrategy as an optimization to improve memory efficiency only. If you need a particular size or shape output, use an Transformation either instead or in addition to a DownsampleStrategy. Some differences between versions of Android and ResourceDecoders are listed below, but the list is not comprehensive because DownsampleStrategy only controls its output scale value, not how that output value is used. On some versions of Android, precise scaling is not possible. In those cases, the strategies can only pick between downsampling to between 1x the requested size and 2x the requested size and between 0.5x the requested size and 1x the requested size because only power of two downsampling is supported. To preserve the potential for a Transformation to scale precisely without a loss in quality, all but AT_MOST will prefer to downsample to between 1x and 2x the requested size."
105,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Enum DownsampleStrategy.SampleSizeRounding,Indicates whether to prefer to prefer downsampling or scaling to prefer lower memory usage or higher quality.
106,resource/transcode,com.bumptech.glide.load.resource.transcode,Class DrawableBytesTranscoder,Obtains byte[] from BitmapDrawables by delegating to a ResourceTranscoder for Bitmaps to byte[]s.
107,request/transition,com.bumptech.glide.request.transition,Class DrawableCrossFadeFactory,"A factory class that produces a new Transition that varies depending on whether or not the drawable was loaded from the memory cache and whether or not the drawable is the first image to be put on the target. Resources are usually loaded from the memory cache just before the user can see the view, for example when the user changes screens or scrolls back and forth in a list. In those cases the user typically does not expect to see a transition. As a result, when the resource is loaded from the memory cache this factory produces an NoTransition."
108,request/transition,com.bumptech.glide.request.transition,Class DrawableCrossFadeFactory.Builder,A Builder for DrawableCrossFadeFactory.
109,request/transition,com.bumptech.glide.request.transition,Class DrawableCrossFadeTransition,"A cross fade Transition for Drawables that uses an TransitionDrawable to transition from an existing drawable already visible on the target to a new drawable. If no existing drawable exists, this class can instead fall back to a default animation that doesn't rely on TransitionDrawable."
110,resource/drawable,com.bumptech.glide.load.resource.drawable,Class DrawableDecoderCompat,Handles decoding Drawables with the v7 support library if present and falling back to the v4 support library otherwise.
111,request/target,com.bumptech.glide.request.target,Class DrawableImageViewTarget,A target for display Drawable objects in ImageViews.
112,resource/drawable,com.bumptech.glide.load.resource.drawable,Class DrawableResource<T extends android.graphics.drawable.Drawable>,Simple wrapper for an Android Drawable which returns a new drawable based on it's state. Suggested usages only include Ts where the new drawable is of the same or descendant class.
113,request/target,com.bumptech.glide.request.target,Class DrawableThumbnailImageViewTarget,Efficiently displays multiple Drawables loaded serially into a single View.
114,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class DrawableTransformation,"Applies a Bitmap Transformation to Drawables by first attempting to convert the Drawable to a Bitmap and then running the Transformation on the converted Bitmap. This class is relatively efficient for BitmapDrawable where the Bitmap is readily accessible. For non-Bitmap based Drawables, this class must first try to draw the Drawable to a Bitmap using Canvas, which is less efficient. Drawables that implement Animatable will fail with an exception. Drawables that return <= 0 for Drawable.getIntrinsicHeight() and/or Drawable.getIntrinsicWidth() will fail with an exception if the requested size is Target.SIZE_ORIGINAL. Drawables without intrinsic dimensions are drawn using the dimensions provided in Transformation.transform(Context, Resource, int, int). As a result, they may be transformed incorrectly or in unexpected ways."
115,resource/drawable,com.bumptech.glide.load.resource.drawable,Class DrawableTransitionOptions,Contains Drawable specific animation options.
116,glide/signature,com.bumptech.glide.signature,Class EmptySignature,An empty key that is always equal to all other empty keys.
117,glide/load,com.bumptech.glide.load,Interface Encoder<T>,An interface for writing data to some persistent data store (i.e. a local File cache).
118,glide/provider,com.bumptech.glide.provider,Class EncoderRegistry,Contains an ordered list of Encoders capable of encoding arbitrary data types.
119,glide/load,com.bumptech.glide.load,Enum EncodeStrategy,Details how an ResourceEncoder will encode a resource to cache.
120,load/engine,com.bumptech.glide.load.engine,Class Engine,Responsible for starting loads and managing active and cached resources.
121,glide/request,com.bumptech.glide.request,Class ErrorRequestCoordinator,Runs a single primary Request until it completes and then a fallback error request only if the single primary request fails.
122,glide/util,com.bumptech.glide.util,Class ExceptionCatchingInputStream,An InputStream that catches IOExceptions during read and skip calls and stores them so they can later be handled or thrown. This class is a workaround for a framework issue where exceptions during reads while decoding bitmaps in BitmapFactory can return partially decoded bitmaps. See https://github.com/bumptech/glide/issues/126.
123,glide/util,com.bumptech.glide.util,Class Executors,Generic Executor implementations.
124,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class ExifInterfaceImageHeaderParser,"Uses ExifInterface to parse orientation data. ExifInterface supports the HEIF format on OMR1+. Glide's DefaultImageHeaderParser doesn't currently support HEIF. In the future we should reconcile these two classes, but for now this is a simple way to ensure that HEIF files are oriented correctly on platforms where they're supported."
125,load/data,com.bumptech.glide.load.data,Class ExifOrientationStream,Adds an exif segment with an orientation attribute to a wrapped InputStream containing image data. This class assumes that the wrapped stream contains an image format that can contain exif information and performs no verification.
126,engine/cache,com.bumptech.glide.load.engine.cache,Class ExternalCacheDiskCacheFactory,Deprecated. use ExternalPreferredCacheDiskCacheFactory instead.
127,engine/cache,com.bumptech.glide.load.engine.cache,Class ExternalPreferredCacheDiskCacheFactory,"Creates an DiskLruCache based disk cache in the external disk cache directory, which falls back to the internal disk cache if no external storage is available. If ever fell back to the internal disk cache, will use that one from that moment on. Images can be read by everyone when using external disk cache."
128,util/pool,com.bumptech.glide.util.pool,Class FactoryPools,"Provides implementations of Pools.Pool never return null, log when new instances are created, and that can use the FactoryPools.Poolable interface to ensure objects aren't used while inside the pool."
129,util/pool,com.bumptech.glide.util.pool,Interface FactoryPools.Factory<T>,Creates new instances of the given type.
130,util/pool,com.bumptech.glide.util.pool,Interface FactoryPools.Poolable,Allows additional verification to catch errors caused by using objects while they are in an object pool.
131,util/pool,com.bumptech.glide.util.pool,Interface FactoryPools.Resetter<T>,Resets state when objects are returned to the pool.
132,resource/file,com.bumptech.glide.load.resource.file,Class FileDecoder,A simple ResourceDecoder that creates resource for a given File.
133,load/data,com.bumptech.glide.load.data,Class FileDescriptorAssetPathFetcher,Fetches an ParcelFileDescriptor for an asset path.
134,load/data,com.bumptech.glide.load.data,Class FileDescriptorLocalUriFetcher,Fetches an ParcelFileDescriptor for a local Uri.
135,load/model,com.bumptech.glide.load.model,Class FileLoader<Data>,A simple model loader for loading data from Files.
136,load/model,com.bumptech.glide.load.model,Class FileLoader.Factory<Data>,Base factory for loading data from files.
137,load/model,com.bumptech.glide.load.model,Class FileLoader.FileDescriptorFactory,Factory for loading ParcelFileDescriptors from Files.
138,load/model,com.bumptech.glide.load.model,Interface FileLoader.FileOpener<Data>,Allows opening a specific type of data from a File.
139,load/model,com.bumptech.glide.load.model,Class FileLoader.StreamFactory,Factory for loading InputStreams from Files.
140,resource/file,com.bumptech.glide.load.resource.file,Class FileResource,A simple Resource that wraps a File.
141,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class FitCenter,Scales the image uniformly (maintaining the image's aspect ratio) so that one of the dimensions of the image will be equal to the given dimension and the other will be less than the given dimension.
142,glide/util,com.bumptech.glide.util,Class FixedPreloadSizeProvider<T>,A ListPreloader.PreloadSizeProvider with a fixed width and height.
143,request/target,com.bumptech.glide.request.target,Class FixedSizeDrawable,A wrapper drawable to square the wrapped drawable so that it expands to fill a square with exactly the given side length. The goal of this drawable is to ensure that square thumbnail drawables always match the size of the view they will be displayed in to avoid a costly requestLayout call. This class should not be used with views or drawables that are not square.
144,glide/request,com.bumptech.glide.request,Interface FutureTarget<R>,"An interface for an object that is both a Target and a Future. For example: FutureTarget<Bitmap> futureTarget = Glide.with(fragment) .load(""http://goo.gl/1asf12"") .asBitmap() .into(250, 250); Bitmap myBitmap = futureTarget.get(); ... // do things with bitmap and then release when finished: futureTarget.cancel(false); Note - Future.get() and Future.get(long, java.util.concurrent.TimeUnit) must be called off of the main thread or they will block forever."
145,bumptech/glide,com.bumptech.glide,Class GenericTransitionOptions<TranscodeType>,Implementation of TransitionOptions that exposes only generic methods that can be applied to any resource type.
146,resource/gif,com.bumptech.glide.load.resource.gif,Class GifBitmapProvider,Implements GifDecoder.BitmapProvider by wrapping Glide's BitmapPool.
147,glide/gifdecoder,com.bumptech.glide.gifdecoder,Interface GifDecoder,Shared interface for GIF decoders.
148,glide/gifdecoder,com.bumptech.glide.gifdecoder,Interface GifDecoder.BitmapProvider,An interface that can be used to provide reused Bitmaps to avoid GCs from constantly allocating Bitmaps for every frame.
149,glide/gifdecoder,com.bumptech.glide.gifdecoder,Annotation Type GifDecoder.GifDecodeStatus,Android Lint annotation for status codes that can be used with a GIF decoder.
150,resource/gif,com.bumptech.glide.load.resource.gif,Class GifDrawable,An animated Drawable that plays the frames of an animated GIF.
151,resource/transcode,com.bumptech.glide.load.resource.transcode,Class GifDrawableBytesTranscoder,An ResourceTranscoder that converts GifDrawable into bytes by obtaining the original bytes of the GIF from the GifDrawable.
152,resource/gif,com.bumptech.glide.load.resource.gif,Class GifDrawableEncoder,Writes the original bytes of a GifDrawable to an OutputStream.
153,resource/gif,com.bumptech.glide.load.resource.gif,Class GifDrawableResource,A resource wrapping an GifDrawable.
154,resource/gif,com.bumptech.glide.load.resource.gif,Class GifDrawableTransformation,An Transformation that wraps a transformation for a Bitmap and can apply it to every frame of any GifDrawable.
155,resource/gif,com.bumptech.glide.load.resource.gif,Class GifFrameResourceDecoder,Decodes Bitmaps from GifDecoders representing a particular frame of a particular GIF image.
156,glide/gifdecoder,com.bumptech.glide.gifdecoder,Class GifHeader,A header object containing the number of frames in an animated GIF image as well as basic metadata like width and height that can be used to decode each individual frame of the GIF. Can be shared by one or more GifDecoders to play the same animated GIF in multiple views.
157,glide/gifdecoder,com.bumptech.glide.gifdecoder,Class GifHeaderParser,A class responsible for creating GifHeaders from data representing animated GIFs.
158,resource/gif,com.bumptech.glide.load.resource.gif,Class GifOptions,Options related to decoding GIFs.
159,bumptech/glide,com.bumptech.glide,Class Glide,"A singleton to present a simple static interface for building requests with RequestBuilder and maintaining an Engine, BitmapPool, DiskCache and MemoryCache."
160,bumptech/glide,com.bumptech.glide,Interface Glide.RequestOptionsFactory,Creates a new instance of RequestOptions.
161,bumptech/glide,com.bumptech.glide,Class GlideBuilder,A builder class for setting default structural classes for Glide to use.
162,bumptech/glide,com.bumptech.glide,Class GlideContext,Global context for all loads in Glide containing and exposing the various registries and classes required to load resources.
163,load/engine,com.bumptech.glide.load.engine,Class GlideException,An exception with zero or more causes indicating why a load in Glide failed.
164,engine/executor,com.bumptech.glide.load.engine.executor,Class GlideExecutor,A prioritized ThreadPoolExecutor for running jobs in Glide.
165,engine/executor,com.bumptech.glide.load.engine.executor,Class GlideExecutor.Builder,A builder for GlideExecutors.
166,engine/executor,com.bumptech.glide.load.engine.executor,Interface GlideExecutor.UncaughtThrowableStrategy,A strategy for handling unexpected and uncaught Throwables thrown by futures run on the pool.
167,integration/concurrent,com.bumptech.glide.integration.concurrent,Class GlideFutures,Utilities for getting ListenableFutures out of Glide.
168,integration/concurrent,com.bumptech.glide.integration.concurrent,Interface GlideFutures.ResourceConsumer<T>,Acts on a resource loaded by Glide.
169,glide/module,com.bumptech.glide.module,Interface GlideModule,Deprecated. Libraries should use LibraryGlideModule and Applications should use AppGlideModule.
170,util/pool,com.bumptech.glide.util.pool,Class GlideTrace,Systracing utilities for Glide.
171,load/model,com.bumptech.glide.load.model,Class GlideUrl,"A wrapper for strings representing http/https URLs responsible for ensuring URLs are properly escaped and avoiding unnecessary URL instantiations for loaders that require only string urls rather than URL objects. Users wishing to replace the class for handling URLs must register a factory using GlideUrl. To obtain a properly escaped URL, call toURL(). To obtain a properly escaped string URL, call toStringUrl(). To obtain a less safe, but less expensive to calculate cache key, call getCacheKey(). This class can also optionally wrap Headers for convenience."
172,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class GranularRoundedCorners,A BitmapTransformation which has a different radius for each corner of a bitmap.
173,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class HardwareConfigState,State and constants for interacting with Bitmap.Config.HARDWARE on Android O+.
174,load/model,com.bumptech.glide.load.model,Interface Headers,An interface for a wrapper for a set of headers to be included in a Glide request. Implementations must implement equals() and hashcode().
175,glide/load,com.bumptech.glide.load,Class HttpException,Thrown when an http request fails. Exposes the specific status code or UNKNOWN via getStatusCode() so users may attempt to retry or otherwise uniformly handle certain types of errors regardless of the underlying http library.
176,model/stream,com.bumptech.glide.load.model.stream,Class HttpGlideUrlLoader,An ModelLoader for translating GlideUrl (http/https URLS) into InputStream data.
177,model/stream,com.bumptech.glide.load.model.stream,Class HttpGlideUrlLoader.Factory,The default factory for HttpGlideUrlLoaders.
178,model/stream,com.bumptech.glide.load.model.stream,Class HttpUriLoader,Loads InputStreams from http or https Uris.
179,model/stream,com.bumptech.glide.load.model.stream,Class HttpUriLoader.Factory,Factory for loading InputStreams from http/https Uris.
180,load/data,com.bumptech.glide.load.data,Class HttpUrlFetcher,A DataFetcher that retrieves an InputStream for a Url.
181,load/resource,com.bumptech.glide.load.resource,Class ImageDecoderResourceDecoder<T>,"Downsamples, decodes, and rotates images according to their exif orientation using ImageDecoder. Obeys all options in Downsampler except for Downsampler.FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS."
182,glide/load,com.bumptech.glide.load,Interface ImageHeaderParser,Interface for the ImageHeaderParser.
183,glide/load,com.bumptech.glide.load,Enum ImageHeaderParser.ImageType,The format of the image data including whether or not the image may include transparent pixels.
184,glide/provider,com.bumptech.glide.provider,Class ImageHeaderParserRegistry,Contains an unordered list of ImageHeaderParsers capable of parsing image headers.
185,glide/load,com.bumptech.glide.load,Class ImageHeaderParserUtils,Utilities for the ImageHeaderParser.
186,request/target,com.bumptech.glide.request.target,Class ImageViewTarget<Z>,A base Target for displaying resources in ImageViews.
187,request/target,com.bumptech.glide.request.target,Class ImageViewTargetFactory,A factory responsible for producing the correct type of Target for a given View subclass.
188,load/engine,com.bumptech.glide.load.engine,Interface Initializable,A callback allowing a resource to do some optimization on a background thread before being returned to the ui.
189,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class InputStreamBitmapImageDecoderResourceDecoder,InputStream specific implementation of BitmapImageDecoderResourceDecoder.
190,load/data,com.bumptech.glide.load.data,Class InputStreamRewinder,Implementation for InputStreams that rewinds streams by wrapping them in a buffered stream.
191,load/data,com.bumptech.glide.load.data,Class InputStreamRewinder.Factory,Factory for producing InputStreamRewinders from InputStreams.
192,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Class IntegerArrayAdapter,Adapter for handling primitive int arrays.
193,engine/cache,com.bumptech.glide.load.engine.cache,Class InternalCacheDiskCacheFactory,Creates an DiskLruCache based disk cache in the internal disk cache directory.
194,glide/load,com.bumptech.glide.load,Interface Key,"An interface that uniquely identifies some put of data. Implementations must implement Object.equals(Object) and Object.hashCode(). Implementations are generally expected to add all uniquely identifying information used in in Object.equals(Object)} and Object.hashCode()} to the given MessageDigest in updateDiskCacheKey(java.security.MessageDigest)}, although this requirement is not as strict for partial cache key signatures."
195,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class LazyBitmapDrawableResource,Lazily allocates a BitmapDrawable from a given Bitmap on the first call to get().
196,load/model,com.bumptech.glide.load.model,Interface LazyHeaderFactory,An interface for lazily creating headers that allows expensive to calculate headers (oauth for example) to be generated in the background during the first fetch. Implementations should implement equals() and hashcode() .
197,load/model,com.bumptech.glide.load.model,Class LazyHeaders,"A wrapper class for a set of headers to be included in a Glide request, allowing headers to be constructed lazily. Ideally headers are constructed once and then re-used for multiple loads, rather then being constructed individually for each load. This class is thread safe."
198,load/model,com.bumptech.glide.load.model,Class LazyHeaders.Builder,"Adds an LazyHeaderFactory that will be used to construct a value for the given key* lazily on a background thread. This class is not thread safe. This class may include default values for User-Agent and Accept-Encoding headers. These will be replaced by calls to either setHeader(String, LazyHeaderFactory) or addHeader(String, String), even though addHeader(String, LazyHeaderFactory) would usually append an additional value."
199,glide/module,com.bumptech.glide.module,Class LibraryGlideModule,"Registers a set of components to use when initializing Glide within an app when Glide's annotation processor is used. Any number of LibraryGlideModules can be contained within any library or application. LibraryGlideModules are called in no defined order. If LibraryGlideModules within an application conflict, AppGlideModules can use the Excludes annotation to selectively remove one or more of the conflicting modules."
200,glide/manager,com.bumptech.glide.manager,Interface Lifecycle,An interface for listening to Activity/Fragment lifecycle events.
201,glide/manager,com.bumptech.glide.manager,Interface LifecycleListener,An interface for listener to Fragment and Activity lifecycle events.
202,bumptech/glide,com.bumptech.glide,Class ListPreloader<T>,"Loads a few resources ahead in the direction of scrolling in any AbsListView so that images are in the memory cache just before the corresponding view in created in the list. Gives the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and cache size. Must be put using AbsListView.setOnScrollListener(android.widget.AbsListView.OnScrollListener), or have its corresponding methods called from another AbsListView.OnScrollListener to function."
203,bumptech/glide,com.bumptech.glide,Interface ListPreloader.PreloadModelProvider<U>,An implementation of PreloadModelProvider should provide all the models that should be preloaded.
204,bumptech/glide,com.bumptech.glide,Interface ListPreloader.PreloadSizeProvider<T>,An implementation of PreloadSizeProvider should provide the size of the view in the list where the resources will be displayed.
205,load/engine,com.bumptech.glide.load.engine,"Class LoadPath<Data,ResourceType,Transcode>","For a given DataFetcher for a given data class, attempts to fetch the data and then run it through one or more DecodePaths."
206,glide/provider,com.bumptech.glide.provider,Class LoadPathCache,"Maintains a cache of data, resource, and transcode classes to available LoadPaths capable of decoding with the requested types."
207,load/data,com.bumptech.glide.load.data,Class LocalUriFetcher<T>,A DataFetcher that uses an ContentResolver to load data from a Uri pointing to a local resource.
208,glide/util,com.bumptech.glide.util,Class LogTime,A class for logging elapsed real time in millis.
209,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Class LruArrayPool,A fixed size Array Pool that evicts arrays using an LRU strategy to keep the pool under the maximum byte size.
210,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Class LruBitmapPool,An BitmapPool implementation that uses an LruPoolStrategy to bucket Bitmaps and then uses an LRU eviction policy to evict Bitmaps from the least recently used bucket in order to keep the pool below a given maximum size limit.
211,glide/util,com.bumptech.glide.util,"Class LruCache<T,Y>",A general purpose size limited cache that evicts items using an LRU algorithm. By default every item is assumed to have a size of one. Subclasses can override getSize(Object)} to change the size on a per item basis.
212,engine/cache,com.bumptech.glide.load.engine.cache,Class LruResourceCache,An LRU in memory cache for Resources.
213,glide/module,com.bumptech.glide.module,Class ManifestParser,Deprecated.
214,glide/util,com.bumptech.glide.util,Class MarkEnforcingInputStream,Prevents InputStreams from overflowing their buffer by reading data past their read limit.
215,load/model,com.bumptech.glide.load.model,Class MediaStoreFileLoader,Loads the file path for MediaStore owned uris.
216,load/model,com.bumptech.glide.load.model,Class MediaStoreFileLoader.Factory,ModelLoaderFactory for MediaStoreFileLoaders.
217,model/stream,com.bumptech.glide.load.model.stream,Class MediaStoreImageThumbLoader,Loads InputStreams from media store image Uris that point to pre-generated thumbnails for those Uris in the media store.
218,model/stream,com.bumptech.glide.load.model.stream,Class MediaStoreImageThumbLoader.Factory,Factory that loads InputStreams from media store image Uris.
219,glide/signature,com.bumptech.glide.signature,Class MediaStoreSignature,"A unique signature based on metadata data from the media store that detects common changes to media store files like edits, rotations, and temporary file replacement."
220,data/mediastore,com.bumptech.glide.load.data.mediastore,Class MediaStoreUtil,Utility classes for interacting with the media store.
221,model/stream,com.bumptech.glide.load.model.stream,Class MediaStoreVideoThumbLoader,"Loads InputStreams from media store video Uris that point to pre-generated thumbnails for those Uris in the media store. If VideoDecoder.TARGET_FRAME is set with a non-null value that is not equal to VideoDecoder.DEFAULT_FRAME, this loader will always return null. The media store does not use a defined frame to generate the thumbnail, so we cannot accurately fulfill requests for specific frames."
222,model/stream,com.bumptech.glide.load.model.stream,Class MediaStoreVideoThumbLoader.Factory,Loads InputStreams from media store image Uris that point to pre-generated thumbnails for those Uris in the media store.
223,engine/cache,com.bumptech.glide.load.engine.cache,Interface MemoryCache,An interface for adding and removing resources from an in memory cache.
224,engine/cache,com.bumptech.glide.load.engine.cache,Interface MemoryCache.ResourceRemovedListener,An interface that will be called whenever a bitmap is removed from the cache.
225,engine/cache,com.bumptech.glide.load.engine.cache,Class MemoryCacheAdapter,A simple class that ignores all puts and returns null for all gets.
226,bumptech/glide,com.bumptech.glide,Enum MemoryCategory,An enum for dynamically modifying the amount of memory Glide is able to use.
227,engine/cache,com.bumptech.glide.load.engine.cache,Class MemorySizeCalculator,"A calculator that tries to intelligently determine cache sizes for a given device based on some constants and the devices screen density, width, and height."
228,engine/cache,com.bumptech.glide.load.engine.cache,Class MemorySizeCalculator.Builder,Constructs an MemorySizeCalculator with reasonable defaults that can be optionally overridden.
229,engine/executor,com.bumptech.glide.load.engine.executor,Class MockGlideExecutor,Creates mock GlideExecutors.
230,load/model,com.bumptech.glide.load.model,Interface Model,An optional interface that models can implement to enhance control over Glide behaviors.
231,load/model,com.bumptech.glide.load.model,"Class ModelCache<A,B>","A simple cache that can be used by ModelLoader and ModelLoaderFactory to cache some data for a given model, width and height. For a loader that takes a model and returns a url, the cache could be used to safely memoize url creation based on the width and height of the view."
232,load/model,com.bumptech.glide.load.model,"Interface ModelLoader<Model,Data>","A factory interface for translating an arbitrarily complex data model into a concrete data type that can be used by an DataFetcher to obtain the data for a resource represented by the model. This interface has two objectives: 1. To translate a specific model into a data type that can be decoded into a resource. 2. To allow a model to be combined with the dimensions of the view to fetch a resource of a specific size. This not only avoids having to duplicate dimensions in xml and in your code in order to determine the size of a view on devices with different densities, but also allows you to use layout weights or otherwise programmatically put the dimensions of the view without forcing you to fetch a generic resource size. The smaller the resource you fetch, the less bandwidth and battery life you use, and the lower your memory footprint per resource."
233,load/model,com.bumptech.glide.load.model,Class ModelLoader.LoadData<Data>,"Contains a set of Keys identifying the source of the load, alternate cache keys pointing to equivalent data, and a DataFetcher that can be used to fetch data not found in cache."
234,load/model,com.bumptech.glide.load.model,"Interface ModelLoaderFactory<T,Y>","An interface for creating a ModelLoader for a given model type. The application Context can be passed in to the constructor of the factory when necessary. It's unsafe to retain Activity Contexts in factories. The Context can be obtained from LibraryGlideModule.registerComponents(Context, Glide, Registry) in most cases."
235,load/model,com.bumptech.glide.load.model,Class ModelLoaderRegistry,Maintains an ordered put of ModelLoaders and the model and data types they handle in order from highest priority to lowest.
236,glide/provider,com.bumptech.glide.provider,Class ModelToResourceClassCache,Maintains a cache of Model + Resource class to a set of registered resource classes that are subclasses of the resource class that can be decoded from the model class.
237,glide/util,com.bumptech.glide.util,Class MultiClassKey,A key of two Classes to be used in hashed collections.
238,load/model,com.bumptech.glide.load.model,Class MultiModelLoaderFactory,Capable of building an ModelLoader that wraps one or more other ModelLoaders for a given model and data class.
239,glide/load,com.bumptech.glide.load,Class MultiTransformation<T>,A transformation that applies one or more transformations in iteration order to a resource.
240,request/target,com.bumptech.glide.request.target,Class NotificationTarget,"This class is used to display downloaded Bitmap inside an ImageView of a Notification through RemoteViews. Note - For cancellation to work correctly, you must pass in the same instance of this class for every subsequent load."
241,request/transition,com.bumptech.glide.request.transition,Class NoTransition<R>,A simple Transition that performs no actions.
242,request/transition,com.bumptech.glide.request.transition,Class NoTransition.NoAnimationFactory<R>,A factory that always returns the same NoTransition.
243,glide/signature,com.bumptech.glide.signature,Class ObjectKey,"Wraps an Object, delegating equals(Object) and hashCode() to the wrapped Object and providing the bytes of the result of the Object's toString() method to the MessageDigest in updateDiskCacheKey(java.security.MessageDigest). The Object's toString() method must be unique and suitable for use as a disk cache key."
244,integration/okhttp,com.bumptech.glide.integration.okhttp,Class OkHttpGlideModule,Deprecated. replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule.
245,integration/okhttp3,com.bumptech.glide.integration.okhttp3,Class OkHttpGlideModule,Deprecated. Replaced by OkHttpLibraryGlideModule for Applications that use Glide's annotations.
246,integration/okhttp,com.bumptech.glide.integration.okhttp,Class OkHttpLibraryGlideModule,Deprecated. Prefer the okhttp3 version instead.
247,integration/okhttp3,com.bumptech.glide.integration.okhttp3,Class OkHttpLibraryGlideModule,"Registers OkHttp related classes via Glide's annotation processor. For Applications that depend on this library and include an AppGlideModule and Glide's annotation processor, this class will be automatically included."
248,integration/okhttp,com.bumptech.glide.integration.okhttp,Class OkHttpStreamFetcher,Deprecated. replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher.
249,integration/okhttp3,com.bumptech.glide.integration.okhttp3,Class OkHttpStreamFetcher,Fetches an InputStream using the okhttp library.
250,integration/okhttp,com.bumptech.glide.integration.okhttp,Class OkHttpUrlLoader,Deprecated. replaced with com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader.
251,integration/okhttp3,com.bumptech.glide.integration.okhttp3,Class OkHttpUrlLoader,A simple model loader for fetching media over http/https using OkHttp.
252,integration/okhttp,com.bumptech.glide.integration.okhttp,Class OkHttpUrlLoader.Factory,The default factory for OkHttpUrlLoaders.
253,integration/okhttp3,com.bumptech.glide.integration.okhttp3,Class OkHttpUrlLoader.Factory,The default factory for OkHttpUrlLoaders.
254,glide/load,com.bumptech.glide.load,Class Option<T>,"Defines available component (decoders, encoders, model loaders etc.) options with optional default values and the ability to affect the resource disk cache key used by DiskCacheStrategy.RESOURCE. Implementations must either be unique (usually declared as static final variables), or implement equals(Object) and hashCode(). Implementations can implement update(Object, MessageDigest) to make sure that the disk cache key includes the specific option set."
255,glide/load,com.bumptech.glide.load,Interface Option.CacheKeyUpdater<T>,An interface that updates a MessageDigest with the given value as part of a process to generate a disk cache key.
256,glide/load,com.bumptech.glide.load,Class Options,A set of Options to apply to in memory and disk cache keys.
257,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class ParcelFileDescriptorBitmapDecoder,Decodes Bitmaps from ParcelFileDescriptors.
258,load/data,com.bumptech.glide.load.data,Class ParcelFileDescriptorRewinder,Implementation for ParcelFileDescriptors that rewinds file descriptors by seeking to 0.
259,load/data,com.bumptech.glide.load.data,Class ParcelFileDescriptorRewinder.Factory,Factory for producing ParcelFileDescriptorRewinders from ParcelFileDescriptors.
260,glide/util,com.bumptech.glide.util,Class Preconditions,Contains common assertions.
261,glide/load,com.bumptech.glide.load,Enum PreferredColorSpace,"Glide's supported handling of color spaces on Android O+, defaults to SRGB. On Android O, Glide will always request SRGB and will ignore this option if set. A bug on Android O prevents P3 images from being compressed correctly and can result in color distortion. We may eventually work around this in Glide if sufficient demand arises, but doing so will require a memory intensive conversion to SRGB prior to compressing Bitmaps to Glide's disk cache. This work around would also work only for Glide's compression, not for any compression that a caller performs on a Bitmap returned by Glide. On Android P+, Glide supports SRGB and display P3. However, if display p3 is requested, we will still decode to SRGB unless BitmapFactory.Options.outColorSpace is also ColorSpace.Named.DISPLAY_P3. Preferring P3 for SRGB images adds unnecessary CPU work to convert back and forth between the color spaces at decode time. Using DISPLAY_P3 is wasteful if either the screen or the renderer do not support P3. Currently Glide does not attempt to detect whether or not this support is present. Do not use DISPLAY_P3 thinking that you're going to get higher quality by default. Only use DISPLAY_P3 if you're confident you understand color spaces, your application is working with a display that supports wide gamut and you've set the appropriate options to render wide gamut colors. If you've missed one or more of these steps, DISPLAY_P3 can lead to poor color quality and washed out looking images. When in doubt, always use SRGB, which is Glide's default. As with DecodeFormat we cannot directly set color spaces, we can only suggest to the framework which one we want. Setting one of these values is not a guarantee that any returned Bitmap will actually use the requested color space."
262,engine/prefill,com.bumptech.glide.load.engine.prefill,Class PreFillType,A container for a put of options used to pre-fill a BitmapPool with Bitmaps of a single size and configuration.
263,engine/prefill,com.bumptech.glide.load.engine.prefill,Class PreFillType.Builder,Builder for PreFillType.
264,request/target,com.bumptech.glide.request.target,Class PreloadTarget<Z>,A one time use Target class that loads a resource into memory and then clears itself.
265,bumptech/glide,com.bumptech.glide,Enum Priority,"Priorities for completing loads. If more than one load is queued at a time, the load with the higher priority will be started first. Priorities are considered best effort, there are no guarantees about the order in which loads will start or finish."
266,model/stream,com.bumptech.glide.load.model.stream,Class QMediaStoreUriLoader<DataT>,"Best effort attempt to work around various Q storage states and bugs. In particular, HEIC images on Q cannot be decoded if they've gone through Android's exif redaction, due to a bug in the implementation that corrupts the file. To avoid the issue, we need to get at the un-redacted File. There are two ways we can do so: MediaStore.setRequireOriginal Querying for and opening the file via the underlying file path, rather than via ContentResolverMediaStore.setRequireOriginal will only work for applications that target Q and request and currently have Manifest.permission.ACCESS_MEDIA_LOCATION. It's the simplest change to make, but it covers the fewest applications. Querying for the file path and opening the file directly works for applications that do not target Q and for applications that do target Q but that opt in to legacy storage mode. Other options are theoretically available for applications that do not target Q, but due to other bugs, the only consistent way to get unredacted files is via the file system. This class does not fix applications that target Q, do not opt in to legacy storage and that don't have Manifest.permission.ACCESS_MEDIA_LOCATION. Avoid using this class directly, it may be removed in any future version of Glide."
267,model/stream,com.bumptech.glide.load.model.stream,Class QMediaStoreUriLoader.FileDescriptorFactory,Factory for ParcelFileDescriptor.
268,model/stream,com.bumptech.glide.load.model.stream,Class QMediaStoreUriLoader.InputStreamFactory,Factory for InputStream.
269,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class RecyclableBufferedInputStream,"Wraps an existing InputStream and buffers the input. Expensive interaction with the underlying input stream is minimized, since most (smaller) requests can be satisfied by accessing the buffer alone. The drawback is that some extra space is required to hold the buffer and that copying takes place when filling that buffer, but this is usually outweighed by the performance benefits. A typical application pattern for the class looks like this: BufferedInputStream buf = new BufferedInputStream(new FileInputStream(""file.java""));"
270,integration/recyclerview,com.bumptech.glide.integration.recyclerview,Class RecyclerToListViewScrollListener,Converts RecyclerView.OnScrollListener events to AbsListView scroll events. Requires that the the recycler view be using a LinearLayoutManager subclass.
271,integration/recyclerview,com.bumptech.glide.integration.recyclerview,Class RecyclerViewPreloader<T>,"Loads a few resources ahead in the direction of scrolling in any RecyclerView so that images are in the memory cache just before the corresponding view in created in the list. Gives the appearance of an infinitely large image cache, depending on scrolling speed, cpu speed, and cache size. Must be added as a listener to the RecyclerView using RecyclerView.addOnScrollListener(RecyclerView.OnScrollListener), or have its corresponding methods called from another RecyclerView.OnScrollListener to function. This class only works with LinearLayoutManager and subclasses of LinearLayoutManager."
272,integration/gifencoder,com.bumptech.glide.integration.gifencoder,Class ReEncodingGifResourceEncoder,An ResourceEncoder that can write GifDrawable to cache.
273,bumptech/glide,com.bumptech.glide,Class Registry,"Manages component registration to extend or replace Glide's default loading, decoding, and encoding logic."
274,bumptech/glide,com.bumptech.glide,Class Registry.MissingComponentException,Thrown when some necessary component is missing for a load.
275,bumptech/glide,com.bumptech.glide,Class Registry.NoImageHeaderParserException,Thrown when no ImageHeaderParser is registered.
276,bumptech/glide,com.bumptech.glide,Class Registry.NoModelLoaderAvailableException,Thrown when no ModelLoader is registered for a given model class.
277,bumptech/glide,com.bumptech.glide,Class Registry.NoResultEncoderAvailableException,Thrown when no ResourceEncoder is registered for a given resource class.
278,bumptech/glide,com.bumptech.glide,Class Registry.NoSourceEncoderAvailableException,Thrown when no Encoder is registered for a given data class.
279,glide/request,com.bumptech.glide.request,Interface Request,A request that loads a resource for an Target.
280,bumptech/glide,com.bumptech.glide,Class RequestBuilder<TranscodeType>,A generic class that can handle setting options and staring loads for generic resource types.
281,glide/request,com.bumptech.glide.request,Interface RequestCoordinator,"An interface for coordinating multiple requests with the same Target. To avoid deadlock, implemenations must not call into individual Requests to determine their state (ie do not call Request.isCleared() or Request.isRunning() etc). Instead use RequestCoordinator.RequestState and the various methods available on this interface and Request to track states manually."
282,glide/request,com.bumptech.glide.request,Enum RequestCoordinator.RequestState,A simple state enum to keep track of the states of individual subrequests.
283,glide/request,com.bumptech.glide.request,Class RequestFutureTarget<R>,"A Future implementation for Glide that can be used to load resources in a blocking manner on background threads. Note - Unlike most targets, RequestFutureTargets can be used once and only once. Attempting to reuse a RequestFutureTarget will probably result in undesirable behavior or exceptions. Instead of reusing objects of this class, the pattern should be: FutureTarget<File> target = null; RequestManager requestManager = Glide.with(context); try { target = requestManager .downloadOnly() .load(model) .submit(); File downloadedFile = target.get(); // ... do something with the file (usually throws IOException) } catch (ExecutionException | InterruptedException | IOException e) { // ... bug reporting or recovery } finally { // make sure to cancel pending operations and free resources if (target != null) { target.cancel(true); // mayInterruptIfRunning } } The cancel(boolean) call will cancel pending operations and make sure that any resources used are recycled."
284,glide/request,com.bumptech.glide.request,Interface RequestListener<R>,"A class for monitoring the status of a request while images load. All methods in this interface will be called from a background thread if the RequestListener is added to a request that is started with RequestBuilder.submit(), RequestBuilder.submit(int, int), or RequestBuilder.into(int, int). Those methods no longer post results back to the main thread to avoid the unnecessary thread interactions and corresponding latency. As a side affect though, listeners added to those requests are no longer called on the main thread. RequestListeners added to requests started with RequestBuilder.into(Target) or RequestBuilder.into(ImageView) will continue to be called back on the main thread."
285,bumptech/glide,com.bumptech.glide,Class RequestManager,"A class for managing and starting requests for Glide. Can use activity, fragment and connectivity lifecycle events to intelligently stop, start, and restart requests. Retrieve either by instantiating a new object, or to take advantage built in Activity and Fragment lifecycle handling, use the static Glide.load methods with your Fragment or Activity."
286,glide/manager,com.bumptech.glide.manager,Class RequestManagerFragment,Deprecated.
287,glide/manager,com.bumptech.glide.manager,Class RequestManagerRetriever,A collection of static methods for creating new RequestManagers or retrieving existing ones from activities and fragment.
288,glide/manager,com.bumptech.glide.manager,Interface RequestManagerRetriever.RequestManagerFactory,Used internally to create RequestManagers.
289,glide/manager,com.bumptech.glide.manager,Interface RequestManagerTreeNode,Provides access to the relatives of a RequestManager based on the current context. The context hierarchy is provided by nesting in Activity and Fragments; the application context does not provide access to any other RequestManagers hierarchically.
290,glide/request,com.bumptech.glide.request,Class RequestOptions,Provides type independent options to customize loads with Glide. Non-final to allow Glide's generated classes to be assignable to their non-generated equivalents.
291,glide/manager,com.bumptech.glide.manager,Class RequestTracker,"A class for tracking, canceling, and restarting in progress, completed, and failed requests. This class is not thread safe and must be accessed on the main thread."
292,load/engine,com.bumptech.glide.load.engine,Interface Resource<Z>,A resource interface that wraps a particular type so that it can be pooled and reused.
293,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class ResourceBitmapDecoder,"Decodes Bitmaps from resource ids. The framework will decode some resources as Drawables that do not wrap Bitmaps. This decoder will attempt to return a Bitmap for those Drawables anyway by drawing the Drawable to a Canvass using the Drawable's intrinsic bounds or the dimensions provided to ResourceDecoder.decode(Object, int, int, Options). For non-Bitmap Drawables that return <= 0 for Drawable.getIntrinsicWidth() and/or Drawable.getIntrinsicHeight(), this decoder will fail if the width and height provided to ResourceDecoder.decode(Object, int, int, Options) are Target.SIZE_ORIGINAL."
294,glide/request,com.bumptech.glide.request,Interface ResourceCallback,A callback that listens for when a resource load completes successfully or fails due to an exception.
295,glide/load,com.bumptech.glide.load,"Interface ResourceDecoder<T,Z>",An interface for decoding resources.
296,glide/provider,com.bumptech.glide.provider,Class ResourceDecoderRegistry,Contains an ordered list of ResourceDecoders capable of decoding arbitrary data types into arbitrary resource types from highest priority decoders to lowest priority decoders.
297,resource/drawable,com.bumptech.glide.load.resource.drawable,Class ResourceDrawableDecoder,"Decodes Drawables given resource Uris. This is typically used as a fallback for resource types that either aren't Bitmaps (see #350) or for resource types that we can't obtain an InputStream for using a standard ContentResolver, including some types of application icons and resources loaded from other packages."
298,glide/load,com.bumptech.glide.load,Interface ResourceEncoder<T>,An interface for writing data from a resource to some persistent data store (i.e. a local File cache).
299,glide/provider,com.bumptech.glide.provider,Class ResourceEncoderRegistry,Contains an ordered list of ResourceEncoders capable of encoding arbitrary resource types.
300,load/model,com.bumptech.glide.load.model,Class ResourceLoader<Data>,A model loader for handling Android resource files. Model must be an Android resource id in the package of the given context.
301,load/model,com.bumptech.glide.load.model,Class ResourceLoader.AssetFileDescriptorFactory,Loads AssetFileDescriptors from resource ids.
302,load/model,com.bumptech.glide.load.model,Class ResourceLoader.FileDescriptorFactory,Factory for loading ParcelFileDescriptors from Android resource ids.
303,load/model,com.bumptech.glide.load.model,Class ResourceLoader.StreamFactory,Factory for loading InputStreams from Android resource ids.
304,load/model,com.bumptech.glide.load.model,Class ResourceLoader.UriFactory,Factory for loading resource Uris from Android resource ids.
305,resource/transcode,com.bumptech.glide.load.resource.transcode,"Interface ResourceTranscoder<Z,R>",Transcodes a resource of one type to a resource of another type.
306,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class Rotate,A BitmapTransformation which rotates the bitmap.
307,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class RoundedCorners,A BitmapTransformation which rounds the corners of a bitmap.
308,engine/cache,com.bumptech.glide.load.engine.cache,Class SafeKeyGenerator,A class that generates and caches safe and unique string file names from Keys.
309,load/resource,com.bumptech.glide.load.resource,Class SimpleResource<T>,Simple wrapper for an arbitrary object which helps to satisfy some of the glide engine's contracts. Suggested usages only include resource object which don't have size and cannot be recycled/closed.
310,request/target,com.bumptech.glide.request.target,Class SimpleTarget<Z>,"Deprecated. Use CustomViewTarget if loading the content into a view, the download API if in the background (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a CustomTarget for any specialized use-cases. Using SimpleTarget or BaseTarget is unsafe if the user does not implement BaseTarget.onLoadCleared(android.graphics.drawable.Drawable), resulting in recycled bitmaps being referenced from the UI and hard to root-cause crashes."
311,glide/request,com.bumptech.glide.request,Class SingleRequest<R>,A Request that loads a Resource into a given Target.
312,engine/bitmap_recycle,com.bumptech.glide.load.engine.bitmap_recycle,Class SizeConfigStrategy,"Keys Bitmaps using both Bitmap.getAllocationByteCount() and the Bitmap.Config returned from Bitmap.getConfig(). Using both the config and the byte size allows us to safely re-use a greater variety of Bitmaps, which increases the hit rate of the pool and therefore the performance of applications. This class works around #301 by only allowing re-use of Bitmaps with a matching number of bytes per pixel."
313,request/target,com.bumptech.glide.request.target,Interface SizeReadyCallback,A callback that must be called when the target has determined its size. For fixed size targets it can be called synchronously.
314,glide/gifdecoder,com.bumptech.glide.gifdecoder,Class StandardGifDecoder,"Reads frame data from a GIF image source and decodes it into individual frames for animation purposes. Image data can be read from either and InputStream source or a byte[]. This class is optimized for running animations with the frames, there are no methods to get individual frame images, only to decode the next frame in the animation sequence. Instead, it lowers its memory footprint by only housing the minimum data necessary to decode the next frame in the animation sequence. The animation must be manually moved forward using advance() before requesting the next frame. This method must also be called before you request the first frame or an error will occur. Implementation adapted from sample code published in Lyons. (2004). Java for Programmers, republished under the MIT Open Source License"
315,util/pool,com.bumptech.glide.util.pool,Class StateVerifier,Verifies that the job is not in the recycled state.
316,load/data,com.bumptech.glide.load.data,Class StreamAssetPathFetcher,Fetches an InputStream for an asset path.
317,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class StreamBitmapDecoder,Decodes Bitmaps from InputStreams.
318,load/model,com.bumptech.glide.load.model,Class StreamEncoder,An Encoder that can write an InputStream to disk.
319,resource/gif,com.bumptech.glide.load.resource.gif,Class StreamGifDecoder,A relatively inefficient decoder for GifDrawable that converts InputStreams to ByteBuffers and then passes the buffer to a wrapped decoder.
320,load/data,com.bumptech.glide.load.data,Class StreamLocalUriFetcher,Fetches an InputStream for a local Uri.
321,load/model,com.bumptech.glide.load.model,Class StringLoader<Data>,"A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by ContentResolver.openInputStream(Uri)."
322,load/model,com.bumptech.glide.load.model,Class StringLoader.AssetFileDescriptorFactory,Loads AssetFileDescriptors from Strings.
323,load/model,com.bumptech.glide.load.model,Class StringLoader.FileDescriptorFactory,Factory for loading ParcelFileDescriptors from Strings.
324,load/model,com.bumptech.glide.load.model,Class StringLoader.StreamFactory,Factory for loading InputStreams from Strings.
325,glide/manager,com.bumptech.glide.manager,Class SupportRequestManagerFragment,"A view-less Fragment used to safely store an RequestManager that can be used to start, stop and manage Glide requests started for targets within the fragment or activity this fragment is a child of."
326,glide/util,com.bumptech.glide.util,Annotation Type Synthetic,Indicates that target's visibility can be relaxed to avoid synthetic methods.
327,request/target,com.bumptech.glide.request.target,Interface Target<R>,"An interface that Glide can load a resource into and notify of relevant lifecycle events during a load. The lifecycle events in this class are as follows: onLoadStarted onResourceReady onLoadCleared onLoadFailed The typical lifecycle is onLoadStarted -> onResourceReady or onLoadFailed -> onLoadCleared. However, there are no guarantees. onLoadStarted may not be called if the resource is in memory or if the load will fail because of a null model object. onLoadCleared similarly may never be called if the target is never cleared. See the docs for the individual methods for details."
328,glide/manager,com.bumptech.glide.manager,Class TargetTracker,Holds the set of Targets currently active for a RequestManager and forwards on lifecycle events.
329,data/mediastore,com.bumptech.glide.load.data.mediastore,Class ThumbFetcher,A DataFetcher implementation for InputStreams that loads data from thumbnail files obtained from the MediaStore.
330,request/target,com.bumptech.glide.request.target,Class ThumbnailImageViewTarget<T>,"Avoids extra calls to View.requestLayout() when loading more than once image into an ImageView with fixed dimensions. Typically it makes sense to use this class when loading multiple images with the RequestBuilder.thumbnail(com.bumptech.glide.RequestBuilder) API into views in a scrolling list like ListView, GridView, or RecyclerView. FixedSizeDrawable may cause skewing or other undesirable behavior depending on your images, views, and scaling. If this occurs, consider DrawableImageViewTarget or BitmapImageViewTarget as alternatives."
331,glide/request,com.bumptech.glide.request,Class ThumbnailRequestCoordinator,A coordinator that coordinates two individual Requests that load a small thumbnail version of an image and the full size version of the image at the same time.
332,resource/transcode,com.bumptech.glide.load.resource.transcode,Class TranscoderRegistry,A class that allows ResourceTranscoders to be registered and retrieved by the classes they convert between.
333,glide/load,com.bumptech.glide.load,Interface Transformation<T>,"A class for performing an arbitrary transformation on a resource that implements Key.equals(Object) and Key.hashCode()} to identify the transformation in the memory cache and Key.updateDiskCacheKey(java.security.MessageDigest)} to identify the transformation in disk caches. Using the fully qualified class name as a static final String (not Class.getName() to avoid proguard obfuscation) is an easy way to implement Key.updateDiskCacheKey(java.security.MessageDigest)} correctly. If additional arguments are required they can be passed in to the constructor of the Transformation and then used to update the MessageDigest passed in to Key.updateDiskCacheKey(MessageDigest). If arguments are primitive types, they can typically easily be serialized using ByteBuffer. String types can be serialized with String.getBytes(Charset) using the constant Key.CHARSET. Implementations must implement Key.equals(Object) and Key.hashCode() for memory caching to work correctly."
334,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class TransformationUtils,A class with methods to efficiently resize Bitmaps.
335,request/transition,com.bumptech.glide.request.transition,Interface Transition<R>,An interface that allows a transition to be applied to Views in Targets in across resource types. Targets that wrap views will be able to provide all of the necessary arguments and start the transition. Those that do not will be unable to provide the necessary arguments and will therefore be forced to ignore the transition. This interface is a compromise that allows view specific transition in Glide's complex world of arbitrary resource types and arbitrary target types.
336,request/transition,com.bumptech.glide.request.transition,Interface Transition.ViewAdapter,"An interface wrapping a view that exposes the necessary methods to run the various types of android animations as transitions: (ViewTransition, ViewPropertyTransition and animated Drawables)."
337,request/transition,com.bumptech.glide.request.transition,Interface TransitionFactory<R>,A factory class that can produce different Transitions based on the state of the request.
338,bumptech/glide,com.bumptech.glide,"Class TransitionOptions<CHILD extends TransitionOptions<CHILD,TranscodeType>,TranscodeType>",A base class for setting a transition to use on a resource when a load completes.
339,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class UnitBitmapDecoder,Passes through a (hopefully) non-owned Bitmap as a Bitmap based Resource so that the given Bitmap is not recycled.
340,resource/drawable,com.bumptech.glide.load.resource.drawable,Class UnitDrawableDecoder,Passes through a Drawable as a Drawable based Resource.
341,load/model,com.bumptech.glide.load.model,Class UnitModelLoader<Model>,A put of helper classes that performs no loading and instead always returns the given model as the data to decode.
342,load/model,com.bumptech.glide.load.model,Class UnitModelLoader.Factory<Model>,Factory for producing UnitModelLoaders.
343,resource/transcode,com.bumptech.glide.load.resource.transcode,Class UnitTranscoder<Z>,A simple ResourceTranscoder that simply returns the given resource.
344,load/resource,com.bumptech.glide.load.resource,Class UnitTransformation<T>,A no-op Transformation that simply returns the given resource.
345,load/model,com.bumptech.glide.load.model,Class UriLoader<Data>,A ModelLoader for Uris that handles local Uris directly and routes remote Uris to a wrapped ModelLoader that handles GlideUrls.
346,load/model,com.bumptech.glide.load.model,Class UriLoader.AssetFileDescriptorFactory,Loads AssetFileDescriptors from Uris.
347,load/model,com.bumptech.glide.load.model,Class UriLoader.FileDescriptorFactory,Loads ParcelFileDescriptors from Uris.
348,load/model,com.bumptech.glide.load.model,Interface UriLoader.LocalUriFetcherFactory<Data>,Factory for obtaining a DataFetcher for a data type for a particular Uri.
349,load/model,com.bumptech.glide.load.model,Class UriLoader.StreamFactory,Loads InputStreams from Uris.
350,model/stream,com.bumptech.glide.load.model.stream,Class UrlLoader,A wrapper class that translates URL objects into GlideUrl objects and then uses the wrapped ModelLoader for GlideUrls to load the data.
351,model/stream,com.bumptech.glide.load.model.stream,Class UrlLoader.StreamFactory,Factory for loading InputStreams from URLs.
352,load/model,com.bumptech.glide.load.model,Class UrlUriLoader<Data>,Handles http/https Uris by delegating to the ModelLoader for GlideUrls.
353,load/model,com.bumptech.glide.load.model,Class UrlUriLoader.StreamFactory,Loads InputStreams from Uris with http or https schemes.
354,glide/util,com.bumptech.glide.util,Class Util,A collection of assorted utility classes.
355,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class VideoBitmapDecoder,Deprecated. Use VideoDecoder.parcel(BitmapPool) instead. This class may be removed and VideoDecoder may become final in a future version of Glide.
356,resource/bitmap,com.bumptech.glide.load.resource.bitmap,Class VideoDecoder<T>,Decodes video data to Bitmaps from ParcelFileDescriptors and AssetFileDescriptors.
357,request/transition,com.bumptech.glide.request.transition,Class ViewAnimationFactory<R>,A TransitionFactory that produces ViewTransitions.
358,glide/util,com.bumptech.glide.util,Class ViewPreloadSizeProvider<T>,A ListPreloader.PreloadSizeProvider that will extract the preload size from a given View.
359,request/transition,com.bumptech.glide.request.transition,Class ViewPropertyAnimationFactory<R>,A TransitionFactory that produces ViewPropertyAnimations.
360,request/transition,com.bumptech.glide.request.transition,Class ViewPropertyTransition<R>,A Transition that accepts an interface that can apply an animation like a ViewPropertyAnimator or a android.animation.ObjectAnimator that can be used to transition a resource into a View.
361,request/transition,com.bumptech.glide.request.transition,Interface ViewPropertyTransition.Animator,An interface that allows an animation to be applied on or started from an View.
362,request/target,com.bumptech.glide.request.target,"Class ViewTarget<T extends android.view.View,Z>",Deprecated. Use CustomViewTarget. Using this class is unsafe without implementing onLoadCleared(android.graphics.drawable.Drawable) and results in recycled bitmaps being referenced from the UI and hard to root-cause crashes.
363,request/transition,com.bumptech.glide.request.transition,Class ViewTransition<R>,A Transition that can apply a Animation to a View using View.startAnimation(android.view.animation.Animation).
364,integration/volley,com.bumptech.glide.integration.volley,Class VolleyGlideModule,Deprecated. Replaced with VolleyLibraryGlideModule.
365,integration/volley,com.bumptech.glide.integration.volley,Class VolleyLibraryGlideModule,"A GlideModule implementation to replace Glide's default HttpURLConnection based ModelLoader with a Volley based ModelLoader. For Applications that depend on this library and include an AppGlideModule and Glide's annotation processor, this class will be automatically included."
366,integration/volley,com.bumptech.glide.integration.volley,Interface VolleyRequestFactory,"Used to construct a custom Volley request, such as for authentication header decoration."
367,integration/volley,com.bumptech.glide.integration.volley,Class VolleyStreamFetcher,A DataFetcher backed by volley for fetching images via http.
368,integration/volley,com.bumptech.glide.integration.volley,Class VolleyStreamFetcher.GlideRequest,Default Request implementation for Glide that receives errors and results on volley's background thread.
369,integration/volley,com.bumptech.glide.integration.volley,Class VolleyUrlLoader,A simple model loader for fetching media over http/https using Volley.
370,integration/volley,com.bumptech.glide.integration.volley,Class VolleyUrlLoader.Factory,The default factory for VolleyUrlLoaders.
371,expanded/decoders,com.google.zxing.oned.rss.expanded.decoders,Class AbstractExpandedDecoder,
372,oned/rss,com.google.zxing.oned.rss,Class AbstractRSSReader,Superclass of OneDReader implementations that read barcodes in the RSS family of formats.
373,client/result,com.google.zxing.client.result,Class AddressBookAUResultParser,Implements KDDI AU's address book format. See http://www.au.kddi.com/ezfactory/tec/two_dimensions/index.html. (Thanks to Yuzo for translating!)
374,client/result,com.google.zxing.client.result,Class AddressBookDoCoMoResultParser,"Implements the ""MECARD"" address book entry format. Supported keys: N, SOUND, TEL, EMAIL, NOTE, ADR, BDAY, URL, plus ORG Unsupported keys: TEL-AV, NICKNAME Except for TEL, multiple values for keys are also not supported; the first one found takes precedence. Our understanding of the MECARD format is based on this document: http://www.mobicode.org.tw/files/OMIA%20Mobile%20Bar%20Code%20Standard%20v3.2.1.doc"
375,client/result,com.google.zxing.client.result,Class AddressBookParsedResult,"Represents a parsed result that encodes contact information, like that in an address book entry."
376,qrcode/detector,com.google.zxing.qrcode.detector,Class AlignmentPattern,"Encapsulates an alignment pattern, which are the smaller square patterns found in all but the simplest QR Codes."
377,aztec/encoder,com.google.zxing.aztec.encoder,Class AztecCode,Aztec 2D code representation
378,zxing/aztec,com.google.zxing.aztec,Class AztecDetectorResult,"Extends DetectorResult with more information specific to the Aztec format, like the number of layers and whether it's compact."
379,zxing/aztec,com.google.zxing.aztec,Class AztecReader,This implementation can detect and decode Aztec codes in an image.
380,zxing/aztec,com.google.zxing.aztec,Class AztecWriter,Renders an Aztec code as a BitMatrix.
381,google/zxing,com.google.zxing,Enum BarcodeFormat,Enumerates barcode formats known to this package. Please keep alphabetized.
382,pdf417/encoder,com.google.zxing.pdf417.encoder,Class BarcodeMatrix,Holds all of the information for a barcode in a format where it can be easily accessible
383,google/zxing,com.google.zxing,Class Binarizer,"This class hierarchy provides a set of methods to convert luminance data to 1 bit data. It allows the algorithm to vary polymorphically, for example allowing a very expensive thresholding technique for servers and a fast one for mobile. It also permits the implementation to vary, e.g. a JNI version for Android and a Java fallback version for other platforms."
384,google/zxing,com.google.zxing,Class BinaryBitmap,This class is the core bitmap class used by ZXing to represent 1 bit data. Reader objects accept a BinaryBitmap and attempt to decode it.
385,zxing/common,com.google.zxing.common,Class BitArray,"A simple, fast array of bits, represented compactly by an array of ints internally."
386,zxing/common,com.google.zxing.common,Class BitMatrix,"Represents a 2D matrix of bits. In function arguments below, and throughout the common module, x is the column position, and y is the row position. The ordering is always x, y. The origin is at the top-left.Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins with a new int. This is done intentionally so that we can copy out a row into a BitArray very efficiently.The ordering of bits is row-major. Within each int, the least significant bits are used first, meaning they represent lower x values. This is compatible with BitArray's implementation."
387,zxing/common,com.google.zxing.common,Class BitSource,"This provides an easy abstraction to read bits at a time from a sequence of bytes, where the number of bits read is not often a multiple of 8.This class is thread-safe but not reentrant -- unless the caller modifies the bytes array it passed in, in which case all bets are off."
388,client/result,com.google.zxing.client.result,Class BizcardResultParser,"Implements the ""BIZCARD"" address book entry format, though this has been largely reverse-engineered from examples observed in the wild -- still looking for a definitive reference."
389,client/result,com.google.zxing.client.result,Class BookmarkDoCoMoResultParser,
390,client/j2se,com.google.zxing.client.j2se,Class BufferedImageLuminanceSource,This LuminanceSource implementation is meant for J2SE clients and our blackbox unit tests.
391,zxing/multi,com.google.zxing.multi,Class ByQuadrantReader,"This class attempts to decode a barcode from an image, not by scanning the whole image, but by scanning subsets of the image. This is important when there may be multiple barcodes in an image, and detecting a barcode may find parts of multiple barcode and fail to decode (e.g. QR Codes). Instead this scans the four quadrants of the image -- and also the center 'quadrant' to cover the case where a barcode is found in the center."
392,qrcode/encoder,com.google.zxing.qrcode.encoder,Class ByteMatrix,"JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned -1, 0, and 1, I'm going to use less memory and go with bytes."
393,client/result,com.google.zxing.client.result,Class CalendarParsedResult,"Represents a parsed result that encodes a calendar event at a certain time, optionally with attendees and a location."
394,zxing/common,com.google.zxing.common,Enum CharacterSetECI,"Encapsulates a Character Set ECI, according to ""Extended Channel Interpretations"" 5.3.1.1 of ISO 18004."
395,zxing/web,com.google.zxing.web,Class ChartDoSFilter,Protect the /chart endpoint from too many requests.
396,zxing/web,com.google.zxing.web,Class ChartServlet,"A reimplementation of the Google Chart Server's QR code encoder, which is now deprecated. See the chart server parameters wiki page for docs."
397,google/zxing,com.google.zxing,Class ChecksumException,"Thrown when a barcode was successfully detected and decoded, but was not returned because its checksum feature failed."
398,zxing/oned,com.google.zxing.oned,Class CodaBarReader,Decodes Codabar barcodes.
399,zxing/oned,com.google.zxing.oned,Class CodaBarWriter,This class renders CodaBar as boolean[].
400,zxing/oned,com.google.zxing.oned,Class Code128Reader,Decodes Code 128 barcodes.
401,zxing/oned,com.google.zxing.oned,Class Code128Writer,This object renders a CODE128 code as a BitMatrix.
402,zxing/oned,com.google.zxing.oned,Class Code39Reader,"Decodes Code 39 barcodes. Supports ""Full ASCII Code 39"" if USE_CODE_39_EXTENDED_MODE is set."
403,zxing/oned,com.google.zxing.oned,Class Code39Writer,This object renders a CODE39 code as a BitMatrix.
404,zxing/oned,com.google.zxing.oned,Class Code93Reader,Decodes Code 93 barcodes.
405,zxing/oned,com.google.zxing.oned,Class Code93Writer,This object renders a CODE93 code as a BitMatrix
406,client/j2se,com.google.zxing.client.j2se,Class CommandLineEncoder,Command line utility for encoding barcodes.
407,client/j2se,com.google.zxing.client.j2se,Class CommandLineRunner,"This simple command line utility decodes files, directories of files, or URIs which are passed as arguments. By default it uses the normal decoding algorithms, but you can pass --try_harder to request that hint. The raw text of each barcode is printed, and when running against directories, summary statistics are also displayed."
408,pdf417/encoder,com.google.zxing.pdf417.encoder,Enum Compaction,Represents possible PDF417 barcode compaction types.
409,oned/rss,com.google.zxing.oned.rss,Class DataCharacter,"Encapsulates a since character value in an RSS barcode, including its checksum information."
410,zxing/datamatrix,com.google.zxing.datamatrix,Class DataMatrixReader,This implementation can detect and decode Data Matrix codes in an image.
411,zxing/datamatrix,com.google.zxing.datamatrix,Class DataMatrixWriter,This object renders a Data Matrix code as a BitMatrix 2D array of greyscale values.
412,zxing/web,com.google.zxing.web,Class DecodeDoSFilter,Protect the /decode endpoint from too many requests.
413,google/zxing,com.google.zxing,Enum DecodeHintType,"Encapsulates a type of hint that a caller may pass to a barcode reader to help it more quickly or accurately decode it. It is up to implementations to decide what, if anything, to do with the information that is supplied."
414,aztec/decoder,com.google.zxing.aztec.decoder,Class Decoder,The main class which implements Aztec Code decoding -- as opposed to locating and extracting the Aztec Code from an image.
415,datamatrix/decoder,com.google.zxing.datamatrix.decoder,Class Decoder,The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting the Data Matrix Code from an image.
416,maxicode/decoder,com.google.zxing.maxicode.decoder,Class Decoder,The main class which implements MaxiCode decoding -- as opposed to locating and extracting the MaxiCode from an image.
417,qrcode/decoder,com.google.zxing.qrcode.decoder,Class Decoder,The main class which implements QR Code decoding -- as opposed to locating and extracting the QR Code from an image.
418,zxing/common,com.google.zxing.common,Class DecoderResult,"Encapsulates the result of decoding a matrix of bits. This typically applies to 2D barcode formats. For now it contains the raw bytes obtained, as well as a String interpretation of those bytes, if applicable."
419,zxing/web,com.google.zxing.web,Class DecodeServlet,"HttpServlet which decodes images containing barcodes. Given a URL, it will retrieve the image and decode it. It can also process image files uploaded via POST."
420,zxing/common,com.google.zxing.common,Class DefaultGridSampler,
421,datamatrix/encoder,com.google.zxing.datamatrix.encoder,Class DefaultPlacement,Symbol Character Placement Program. Adapted from Annex M.1 in ISO/IEC 16022:2000(E).
422,aztec/detector,com.google.zxing.aztec.detector,Class Detector,"Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code is rotated or skewed, or partially obscured."
423,datamatrix/detector,com.google.zxing.datamatrix.detector,Class Detector,"Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code is rotated or skewed, or partially obscured."
424,pdf417/detector,com.google.zxing.pdf417.detector,Class Detector,"Encapsulates logic that can detect a PDF417 Code in an image, even if the PDF417 Code is rotated or skewed, or partially obscured."
425,qrcode/detector,com.google.zxing.qrcode.detector,Class Detector,"Encapsulates logic that can detect a QR Code in an image, even if the QR Code is rotated or skewed, or partially obscured."
426,zxing/common,com.google.zxing.common,Class DetectorResult,"Encapsulates the result of detecting a barcode in an image. This includes the raw matrix of black/white pixels corresponding to the barcode, and possibly points of interest in the image, like the location of finder patterns or corners of the barcode in the image."
427,google/zxing,com.google.zxing,Class Dimension,Simply encapsulates a width and height.
428,pdf417/encoder,com.google.zxing.pdf417.encoder,Class Dimensions,Data object to specify the minimum and maximum number of rows and columns for a PDF417 barcode.
429,zxing/web,com.google.zxing.web,Class DoSFilter,A simplistic Filter that rejects requests from hosts that are sending too many requests in too short a time.
430,zxing/oned,com.google.zxing.oned,Class EAN13Reader,Implements decoding of the EAN-13 format.
431,zxing/oned,com.google.zxing.oned,Class EAN13Writer,This object renders an EAN13 code as a BitMatrix.
432,zxing/oned,com.google.zxing.oned,Class EAN8Reader,Implements decoding of the EAN-8 format.
433,zxing/oned,com.google.zxing.oned,Class EAN8Writer,This object renders an EAN8 code as a BitMatrix.
434,client/result,com.google.zxing.client.result,Class EmailAddressParsedResult,"Represents a parsed result that encodes an email message including recipients, subject and body text."
435,client/result,com.google.zxing.client.result,Class EmailAddressResultParser,"Represents a result that encodes an e-mail address, either as a plain address like ""joe@example.org"" or a mailto: URL like ""mailto:joe@example.org""."
436,client/result,com.google.zxing.client.result,Class EmailDoCoMoResultParser,"Implements the ""MATMSG"" email message entry format. Supported keys: TO, SUB, BODY"
437,google/zxing,com.google.zxing,Enum EncodeHintType,These are a set of hints that you may pass to Writers to specify their behavior.
438,aztec/encoder,com.google.zxing.aztec.encoder,Class Encoder,Generates Aztec 2D barcodes.
439,qrcode/encoder,com.google.zxing.qrcode.encoder,Class Encoder,
440,datamatrix/encoder,com.google.zxing.datamatrix.encoder,Class ErrorCorrection,Error Correction Code for ECC200.
441,decoder/ec,com.google.zxing.pdf417.decoder.ec,Class ErrorCorrection,PDF417 error correction implementation.This example is quite useful in understanding the algorithm.
442,qrcode/decoder,com.google.zxing.qrcode.decoder,Enum ErrorCorrectionLevel,"See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels defined by the QR code standard."
443,client/result,com.google.zxing.client.result,Class ExpandedProductParsedResult,"Represents a parsed result that encodes extended product information as encoded by the RSS format, like weight, price, dates, etc."
444,client/result,com.google.zxing.client.result,Class ExpandedProductResultParser,Parses strings of digits that represent a RSS Extended code.
445,oned/rss,com.google.zxing.oned.rss,Class FinderPattern,"Encapsulates an RSS barcode finder pattern, including its start/end position and row."
446,qrcode/detector,com.google.zxing.qrcode.detector,Class FinderPattern,"Encapsulates a finder pattern, which are the three square patterns found in the corners of QR Codes. It also encapsulates a count of similar finder patterns, as a convenience to the finder's bookkeeping."
447,qrcode/detector,com.google.zxing.qrcode.detector,Class FinderPatternFinder,This class attempts to find finder patterns in a QR Code. Finder patterns are the square markers at three corners of a QR Code.This class is thread-safe but not reentrant. Each thread must allocate its own object.
448,qrcode/detector,com.google.zxing.qrcode.detector,Class FinderPatternInfo,"Encapsulates information about finder patterns in an image, including the location of the three finder patterns, and their estimated module size."
449,google/zxing,com.google.zxing,Class FormatException,"Thrown when a barcode was successfully detected, but some aspect of the content did not conform to the barcode's format rules. This could have been due to a mis-detection."
450,common/reedsolomon,com.google.zxing.common.reedsolomon,Class GenericGF,"This class contains utility methods for performing mathematical operations over the Galois Fields. Operations use a given primitive polynomial in calculations.Throughout this package, elements of the GF are represented as an int for convenience and speed (but at the cost of memory)."
451,zxing/multi,com.google.zxing.multi,Class GenericMultipleBarcodeReader,"Attempts to locate multiple barcodes in an image by repeatedly decoding portion of the image. After one barcode is found, the areas left, above, right and below the barcode's ResultPoints are scanned, recursively.A caller may want to also employ ByQuadrantReader when attempting to find multiple 2D barcodes, like QR Codes, in an image, where the presence of multiple barcodes might prevent detecting any one of them.That is, instead of passing a Reader a caller might pass new ByQuadrantReader(reader)."
452,client/result,com.google.zxing.client.result,Class GeoParsedResult,"Represents a parsed result that encodes a geographic coordinate, with latitude, longitude and altitude."
453,client/result,com.google.zxing.client.result,Class GeoResultParser,"Parses a ""geo:"" URI result, which specifies a location on the surface of the Earth as well as an optional altitude above the surface. See http://tools.ietf.org/html/draft-mayrhofer-geo-uri-00."
454,zxing/common,com.google.zxing.common,Class GlobalHistogramBinarizer,"This Binarizer implementation uses the old ZXing global histogram approach. It is suitable for low-end mobile devices which don't have enough CPU or memory to use a local thresholding algorithm. However, because it picks a global black point, it cannot handle difficult shadows and gradients. Faster mobile devices and all desktop applications should probably use HybridBinarizer instead."
455,zxing/common,com.google.zxing.common,Class GridSampler,"Implementations of this class can, given locations of finder patterns for a QR code in an image, sample the right points in the image to reconstruct the QR code, accounting for perspective distortion. It is abstracted since it is relatively expensive and should be allowed to take advantage of platform-specific optimized implementations, like Sun's Java Advanced Imaging library, but which may not be available in other environments such as J2ME, and vice versa. The implementation used can be controlled by calling setGridSampler(GridSampler) with an instance of a class which implements this interface."
456,client/j2se,com.google.zxing.client.j2se,Class GUIRunner,"Simple GUI frontend to the library. Right now, only decodes a local file. This definitely needs some improvement. Just throwing something down to start."
457,aztec/encoder,com.google.zxing.aztec.encoder,Class HighLevelEncoder,"This produces nearly optimal encodings of text into the first-level of encoding used by Aztec code. It uses a dynamic algorithm. For each prefix of the string, it determines a set of encodings that could lead to this prefix. We repeatedly add a character and generate a new set of optimal encodings until we have read through the entire input."
458,datamatrix/encoder,com.google.zxing.datamatrix.encoder,Class HighLevelEncoder,DataMatrix ECC 200 data encoder following the algorithm described in ISO/IEC 16022:200(E) in annex S.
459,client/j2se,com.google.zxing.client.j2se,Class HtmlAssetTranslator,"A utility which auto-translates the English-language text in a directory of HTML documents using Google Translate.Pass the Android client assets/ directory as first argument, and the language to translate to second as a comma-separated list. Specify ""all"" for language to try to translate for all existing translations. Each argument after this is the name of a file to translate; if the first one is ""all"", all files will be translated.Usage: HtmlAssetTranslator android/assets/ (all|lang1[,lang2 ...]) (all|file1.html[ file2.html ...])android/assets/ es all will translate .html files in subdirectory html-en to directory html-es, for example. Note that only text nodes in the HTML document are translated. Any text that is a child of a node with class=""notranslate"" will not be translated. It will also add a note at the end of the translated page that indicates it was automatically translated."
460,zxing/web,com.google.zxing.web,Class HTTPSFilter,"Redirects things to HTTPS, like the main decode page, which should prefer HTTPS."
461,zxing/common,com.google.zxing.common,Class HybridBinarizer,"This class implements a local thresholding algorithm, which while slower than the GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for high frequency images of barcodes with black data on white backgrounds. For this application, it does a much better job than a global blackpoint with severe shadows and gradients. However it tends to produce artifacts on lower frequency images and is therefore not a good general purpose binarizer for uses outside ZXing. This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers, and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already inherently local, and only fails for horizontal gradients. We can revisit that problem later, but for now it was not a win to use local blocks for 1D. This Binarizer is the default for the unit tests and the recommended class for library users."
462,client/j2se,com.google.zxing.client.j2se,Class ImageReader,Encapsulates reading URIs as images.
463,google/zxing,com.google.zxing,Class InvertedLuminanceSource,"A wrapper implementation of LuminanceSource which inverts the luminances it returns -- black becomes white and vice versa, and each value becomes (255-value)."
464,client/result,com.google.zxing.client.result,Class ISBNParsedResult,Represents a parsed result that encodes a product ISBN number.
465,client/result,com.google.zxing.client.result,Class ISBNResultParser,Parses strings of digits that represent a ISBN.
466,zxing/oned,com.google.zxing.oned,Class ITFReader,"Implements decoding of the ITF format, or Interleaved Two of Five.This Reader will scan ITF barcodes of certain lengths only. At the moment it reads length 6, 8, 10, 12, 14, 16, 18, 20, 24, and 44 as these have appeared ""in the wild"". Not all lengths are scanned, especially shorter ones, to avoid false positives. This in turn is due to a lack of required checksum function.The checksum is optional and is not applied by this Reader. The consumer of the decoded value will have to apply a checksum if required.http://en.wikipedia.org/wiki/Interleaved_2_of_5 is a great reference for Interleaved 2 of 5 information."
467,zxing/oned,com.google.zxing.oned,Class ITFWriter,This object renders a ITF code as a BitMatrix.
468,google/zxing,com.google.zxing,Class LuminanceSource,The purpose of this class hierarchy is to abstract different bitmap implementations across platforms into a standard interface for requesting greyscale luminance values. The interface only provides immutable methods; therefore crop and rotation create copies. This is to ensure that one Reader does not modify the original luminance source and leave it in an unknown state for other Readers in the chain.
469,common/detector,com.google.zxing.common.detector,Class MathUtils,General math-related and numeric utility functions.
470,client/j2se,com.google.zxing.client.j2se,Class MatrixToImageConfig,Encapsulates custom configuration used in methods of MatrixToImageWriter.
471,client/j2se,com.google.zxing.client.j2se,Class MatrixToImageWriter,"Writes a BitMatrix to BufferedImage, file or stream. Provided here instead of core since it depends on Java SE libraries."
472,zxing/maxicode,com.google.zxing.maxicode,Class MaxiCodeReader,This implementation can detect and decode a MaxiCode in an image.
473,qrcode/decoder,com.google.zxing.qrcode.decoder,Enum Mode,"See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which data can be encoded to bits in the QR code standard."
474,decoder/ec,com.google.zxing.pdf417.decoder.ec,Class ModulusGF,"A field based on powers of a generator integer, modulo some modulus."
475,common/detector,com.google.zxing.common.detector,Class MonochromeRectangleDetector,Deprecated. without replacement since 3.3.0
476,qrcode/detector,com.google.zxing.multi.qrcode.detector,Class MultiDetector,"Encapsulates logic that can detect one or more QR Codes in an image, even if the QR Code is rotated or skewed, or partially obscured."
477,qrcode/detector,com.google.zxing.multi.qrcode.detector,Class MultiFinderPatternFinder,"This class attempts to find finder patterns in a QR Code. Finder patterns are the square markers at three corners of a QR Code.This class is thread-safe but not reentrant. Each thread must allocate its own object. In contrast to FinderPatternFinder, this class will return an array of all possible QR code locations in the image.Use the TRY_HARDER hint to ask for a more thorough detection."
478,zxing/oned,com.google.zxing.oned,Class MultiFormatOneDReader,
479,google/zxing,com.google.zxing,Class MultiFormatReader,"MultiFormatReader is a convenience class and the main entry point into the library for most uses. By default it attempts to decode all barcode formats that the library supports. Optionally, you can provide a hints object to request different behavior, for example only decoding QR codes."
480,zxing/oned,com.google.zxing.oned,Class MultiFormatUPCEANReader,"A reader that can read all available UPC/EAN formats. If a caller wants to try to read all such formats, it is most efficient to use this implementation rather than invoke individual readers."
481,google/zxing,com.google.zxing,Class MultiFormatWriter,This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat requested and encodes the barcode with the supplied contents.
482,zxing/multi,com.google.zxing.multi,Interface MultipleBarcodeReader,Implementation of this interface attempt to read several barcodes from one image.
483,google/zxing,com.google.zxing,Class NotFoundException,Thrown when a barcode was not found in the image. It might have been partially detected but could not be confirmed.
484,zxing/oned,com.google.zxing.oned,Class OneDimensionalCodeWriter,Encapsulates functionality and implementation that is common to one-dimensional barcodes.
485,zxing/oned,com.google.zxing.oned,Class OneDReader,Encapsulates functionality and implementation that is common to all families of one-dimensional barcodes.
486,zxing/web,com.google.zxing.web,Class OutputUtils,Utility functions for decoderesult.jspx.
487,client/result,com.google.zxing.client.result,Class ParsedResult,"Abstract class representing the result of decoding a barcode, as more than a String -- as some type of structured data. This might be a subclass which represents a URL, or an e-mail address. ResultParser.parseResult(com.google.zxing.Result) will turn a raw decoded string into the most appropriate type of structured representation.Thanks to Jeff Griffin for proposing rewrite of these classes that relies less on exception-based mechanisms during parsing."
488,client/result,com.google.zxing.client.result,Enum ParsedResultType,"Represents the type of data encoded by a barcode -- from plain text, to a URI, to an e-mail address, etc."
489,pdf417/encoder,com.google.zxing.pdf417.encoder,Class PDF417,Top-level class for the logic part of the PDF417 implementation.
490,zxing/pdf417,com.google.zxing.pdf417,Class PDF417Common,
491,pdf417/detector,com.google.zxing.pdf417.detector,Class PDF417DetectorResult,
492,zxing/pdf417,com.google.zxing.pdf417,Class PDF417Reader,This implementation can detect and decode PDF417 codes in an image.
493,zxing/pdf417,com.google.zxing.pdf417,Class PDF417ResultMetadata,
494,pdf417/decoder,com.google.zxing.pdf417.decoder,Class PDF417ScanningDecoder,
495,zxing/pdf417,com.google.zxing.pdf417,Class PDF417Writer,
496,zxing/common,com.google.zxing.common,Class PerspectiveTransform,"This class implements a perspective transform in two dimensions. Given four source and four destination points, it will compute the transformation implied between them. The code is based directly upon section 3.4.2 of George Wolberg's ""Digital Image Warping""; see pages 54-56."
497,google/zxing,com.google.zxing,Class PlanarYUVLuminanceSource,"This object extends LuminanceSource around an array of YUV data returned from the camera driver, with the option to crop to a rectangle within the full data. This can be used to exclude superfluous pixels around the perimeter and speed up decoding. It works for any pixel format where the Y channel is planar and appears first, including YCbCr_420_SP and YCbCr_422_SP."
498,client/result,com.google.zxing.client.result,Class ProductParsedResult,Represents a parsed result that encodes a product by an identifier of some kind.
499,client/result,com.google.zxing.client.result,Class ProductResultParser,Parses strings of digits that represent a UPC code.
500,qrcode/encoder,com.google.zxing.qrcode.encoder,Class QRCode,
501,qrcode/decoder,com.google.zxing.qrcode.decoder,Class QRCodeDecoderMetaData,Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the decoding caller. Callers are expected to process this.
502,multi/qrcode,com.google.zxing.multi.qrcode,Class QRCodeMultiReader,This implementation can detect and decode multiple QR Codes in an image.
503,zxing/qrcode,com.google.zxing.qrcode,Class QRCodeReader,This implementation can detect and decode QR Codes in an image.
504,zxing/qrcode,com.google.zxing.qrcode,Class QRCodeWriter,This object renders a QR Code as a BitMatrix 2D array of greyscale values.
505,google/zxing,com.google.zxing,Interface Reader,"Implementations of this interface can decode an image of a barcode in some format into the String it encodes. For example, QRCodeReader can decode a QR code. The decoder may optionally receive hints from the caller which may help it decode more quickly or accurately. See MultiFormatReader, which attempts to determine what barcode format is present within the image as well, and then decodes it accordingly."
506,google/zxing,com.google.zxing,Class ReaderException,"The general exception class throw when something goes wrong during decoding of a barcode. This includes, but is not limited to, failing checksums / error correction algorithms, being unable to locate finder timing patterns, and so on."
507,common/reedsolomon,com.google.zxing.common.reedsolomon,Class ReedSolomonDecoder,"Implements Reed-Solomon decoding, as the name implies.The algorithm will not be explained here, but the following references were helpful in creating this implementation:Bruce Maggs. ""Decoding Reed-Solomon Codes"" (see discussion of Forney's Formula)J.I. Hall. ""Chapter 5. Generalized Reed-Solomon Codes"" (see discussion of Euclidean algorithm)Much credit is due to William Rucklidge since portions of this code are an indirect port of his C++ Reed-Solomon implementation."
508,common/reedsolomon,com.google.zxing.common.reedsolomon,Class ReedSolomonEncoder,"Implements Reed-Solomon encoding, as the name implies."
509,common/reedsolomon,com.google.zxing.common.reedsolomon,Class ReedSolomonException,"Thrown when an exception occurs during Reed-Solomon decoding, such as when there are too many errors to correct."
510,google/zxing,com.google.zxing,Class Result,Encapsulates the result of decoding a barcode within an image.
511,google/zxing,com.google.zxing,Enum ResultMetadataType,Represents some type of metadata about the result of the decoding that the decoder wishes to communicate back to the caller.
512,client/result,com.google.zxing.client.result,Class ResultParser,"Abstract class representing the result of decoding a barcode, as more than a String -- as some type of structured data. This might be a subclass which represents a URL, or an e-mail address. parseResult(Result) will turn a raw decoded string into the most appropriate type of structured representation.Thanks to Jeff Griffin for proposing rewrite of these classes that relies less on exception-based mechanisms during parsing."
513,google/zxing,com.google.zxing,Class ResultPoint,"Encapsulates a point of interest in an image containing a barcode. Typically, this would be the location of a finder pattern or the corner of the barcode, for example."
514,google/zxing,com.google.zxing,Interface ResultPointCallback,Callback which is invoked when a possible result point (significant point in the barcode image such as a corner) is found.
515,google/zxing,com.google.zxing,Class RGBLuminanceSource,This class is used to help decode images from files which arrive as RGB data from an ARGB pixel array. It does not support rotation.
516,oned/rss,com.google.zxing.oned.rss,Class RSS14Reader,"Decodes RSS-14, including truncated and stacked variants. See ISO/IEC 24724:2006."
517,rss/expanded,com.google.zxing.oned.rss.expanded,Class RSSExpandedReader,
518,oned/rss,com.google.zxing.oned.rss,Class RSSUtils,Adapted from listings in ISO/IEC 24724 Appendix B and Appendix G.
519,client/result,com.google.zxing.client.result,Class SMSMMSResultParser,"Parses an ""sms:"" URI result, which specifies a number to SMS. See RFC 5724 on this.This class supports ""via"" syntax for numbers, which is not part of the spec. For example ""+12125551212;via=+12124440101"" may appear as a number. It also supports a ""subject"" query parameter, which is not mentioned in the spec. These are included since they were mentioned in earlier IETF drafts and might be used.This actually also parses URIs starting with ""mms:"" and treats them all the same way, and effectively converts them to an ""sms:"" URI for purposes of forwarding to the platform."
520,client/result,com.google.zxing.client.result,Class SMSParsedResult,"Represents a parsed result that encodes an SMS message, including recipients, subject and body text."
521,client/result,com.google.zxing.client.result,Class SMSTOMMSTOResultParser,"Parses an ""smsto:"" URI result, whose format is not standardized but appears to be like: smsto:number(:body).This actually also parses URIs starting with ""smsto:"", ""mmsto:"", ""SMSTO:"", and ""MMSTO:"", and treats them all the same way, and effectively converts them to an ""sms:"" URI for purposes of forwarding to the platform."
522,client/result,com.google.zxing.client.result,Class SMTPResultParser,"Parses an ""smtp:"" URI result, whose format is not standardized but appears to be like: smtp[:subject[:body]]."
523,client/j2se,com.google.zxing.client.j2se,Class StringsResourceTranslator,"A utility which auto-translates English strings in Android string resources using Google Translate.Pass the Android client res/ directory as first argument, and optionally message keys who should be forced to retranslate. Usage: StringsResourceTranslator android/res/ [key_1 ...]You must set your Google Translate API key into the environment with -DtranslateAPI.key=..."
524,zxing/common,com.google.zxing.common,Class StringUtils,Common string-related functions.
525,datamatrix/encoder,com.google.zxing.datamatrix.encoder,Class SymbolInfo,Symbol info table for DataMatrix.
526,datamatrix/encoder,com.google.zxing.datamatrix.encoder,Enum SymbolShapeHint,Enumeration for DataMatrix symbol shape hint. It can be used to force square or rectangular symbols.
527,client/result,com.google.zxing.client.result,Class TelParsedResult,Represents a parsed result that encodes a telephone number.
528,client/result,com.google.zxing.client.result,Class TelResultParser,"Parses a ""tel:"" URI result, which specifies a phone number."
529,client/result,com.google.zxing.client.result,Class TextParsedResult,A simple result type encapsulating a string that has no further interpretation.
530,zxing/oned,com.google.zxing.oned,Class UPCAReader,Implements decoding of the UPC-A format.
531,zxing/oned,com.google.zxing.oned,Class UPCAWriter,This object renders a UPC-A code as a BitMatrix.
532,zxing/oned,com.google.zxing.oned,Class UPCEANReader,Encapsulates functionality and implementation that is common to UPC and EAN families of one-dimensional barcodes.
533,zxing/oned,com.google.zxing.oned,Class UPCEANWriter,Encapsulates functionality and implementation that is common to UPC and EAN families of one-dimensional barcodes.
534,zxing/oned,com.google.zxing.oned,Class UPCEReader,Implements decoding of the UPC-E format.This is a great reference for UPC-E information.
535,zxing/oned,com.google.zxing.oned,Class UPCEWriter,This object renders an UPC-E code as a BitMatrix.
536,client/result,com.google.zxing.client.result,Class URIParsedResult,A simple result type encapsulating a URI that has no further interpretation.
537,client/result,com.google.zxing.client.result,Class URIResultParser,Tries to parse results that are a URI of some kind.
538,client/result,com.google.zxing.client.result,Class URLTOResultParser,"Parses the ""URLTO"" result format, which is of the form ""URLTO:[title]:[url]"". This seems to be used sometimes, but I am not able to find documentation on its origin or official format?"
539,client/result,com.google.zxing.client.result,Class VCardResultParser,Parses contact information formatted according to the VCard (2.1) format. This is not a complete implementation but should parse information as commonly encoded in 2D barcodes.
540,datamatrix/decoder,com.google.zxing.datamatrix.decoder,Class Version,The Version object encapsulates attributes about a particular size Data Matrix Code.
541,qrcode/decoder,com.google.zxing.qrcode.decoder,Class Version,See ISO 18004:2006 Annex D
542,qrcode/decoder,com.google.zxing.qrcode.decoder,Class Version.ECB,"Encapsulates the parameters for one error-correction block in one symbol version. This includes the number of data codewords, and the number of times a block with these parameters is used consecutively in the QR code version's format."
543,qrcode/decoder,com.google.zxing.qrcode.decoder,Class Version.ECBlocks,"Encapsulates a set of error-correction blocks in one symbol version. Most versions will use blocks of differing sizes within one version, so, this encapsulates the parameters for each set of blocks. It also holds the number of error-correction codewords per block since it will be the same across all blocks within one version."
544,client/result,com.google.zxing.client.result,Class VEventResultParser,"Partially implements the iCalendar format's ""VEVENT"" format for specifying a calendar event. See RFC 2445. This supports SUMMARY, LOCATION, GEO, DTSTART and DTEND fields."
545,client/result,com.google.zxing.client.result,Class VINParsedResult,Represents a parsed result that encodes a Vehicle Identification Number (VIN).
546,client/result,com.google.zxing.client.result,Class VINResultParser,Detects a result that is likely a vehicle identification number.
547,zxing/web,com.google.zxing.web,Class WelcomeFilter,Handles redirects to the app landing page.
548,common/detector,com.google.zxing.common.detector,Class WhiteRectangleDetector,"Detects a candidate barcode-like rectangular region within an image. It starts around the center of the image, increases the size of the candidate region until it finds a white rectangular region. By keeping track of the last black points it encountered, it determines the corners of the barcode."
549,client/result,com.google.zxing.client.result,Class WifiParsedResult,"Represents a parsed result that encodes wifi network information, like SSID and password."
550,client/result,com.google.zxing.client.result,Class WifiResultParser,"Parses a WIFI configuration string. Strings will be of the form:WIFI:T:[network type];S:[network SSID];P:[network password];H:[hidden?];;For WPA2 enterprise (EAP), strings will be of the form:WIFI:T:WPA2-EAP;S:[network SSID];H:[hidden?];E:[EAP method];PH2:[Phase 2 method];A:[anonymous identity];I:[username];P:[password];;""EAP method"" can e.g. be ""TTLS"" or ""PWD"" or one of the other fields in WifiEnterpriseConfig.Eap and ""Phase 2 method"" can e.g. be ""MSCHAPV2"" or any of the other fields in WifiEnterpriseConfig.Phase2The fields can appear in any order. Only ""S:"" is required."
551,google/zxing,com.google.zxing,Interface Writer,The base class for all objects which encode/generate a barcode image.
552,google/zxing,com.google.zxing,Class WriterException,A base class which covers the range of exceptions which may occur when encoding a barcode using the Writer framework.
553,butterknife/butterknife,butterknife,Class ButterKnife,"Field and method binding for Android views. Use this class to simplify finding views and attaching listeners by binding them with annotations. Finding views from your activity is as easy as: public class ExampleActivity extends Activity { @BindView(R.id.title) EditText titleView; @BindView(R.id.subtitle) EditText subtitleView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.example_activity); ButterKnife.bind(this); } } Binding can be performed directly on an activity, a view, or a dialog. Alternate objects to bind can be specified along with an activity, view, or dialog. Group multiple views together into a List or array. @BindView({R.id.first_name, R.id.middle_name, R.id.last_name}) List nameViews; To bind listeners to your views you can annotate your methods: @OnClick(R.id.submit) void onSubmit() { // React to button click. } Any number of parameters from the listener may be used on the method. @OnItemClick(R.id.tweet_list) void onTweetClicked(int position) { // React to tweet click. } Be default, views are required to be present in the layout for both field and method bindings. If a view is optional add a @Nullable annotation for fields (such as the one in the support-annotations library) or the @Optional annotation for methods. @Nullable @BindView(R.id.title) TextView subtitleView; Resources can also be bound to fields to simplify programmatically working with views: @BindBool(R.bool.is_tablet) boolean isTablet; @BindInt(R.integer.columns) int columns; @BindColor(R.color.error_red) int errorRed;"
554,common/cache,com.google.common.cache,"Class AbstractCache<K,V>","This class provides a skeletal implementation of the Cache interface to minimize the effort required to implement this interface. To implement a cache, the programmer needs only to extend this class and provide an implementation for the put(K, V) and Cache.getIfPresent(java.lang.Object) methods. getAllPresent(java.lang.Iterable<?>) is implemented in terms of Cache.getIfPresent(java.lang.Object); putAll(java.util.Map<? extends K, ? extends V>) is implemented in terms of put(K, V), invalidateAll(Iterable) is implemented in terms of invalidate(java.lang.Object). The method cleanUp() is a no-op. All other methods throw an UnsupportedOperationException."
555,common/cache,com.google.common.cache,Class AbstractCache.SimpleStatsCounter,A thread-safe AbstractCache.StatsCounter implementation for use by Cache implementors.
556,common/cache,com.google.common.cache,Interface AbstractCache.StatsCounter,Accumulates statistics during the operation of a Cache for presentation by Cache.stats(). This is solely intended for consumption by Cache implementors.
557,util/concurrent,com.google.common.util.concurrent,Class AbstractExecutionThreadService,"Base class for services that can implement startUp(), run() and shutDown() methods. This class uses a single thread to execute the service; consider AbstractService if you would like to manage any threading manually."
558,util/concurrent,com.google.common.util.concurrent,Class AbstractFuture<V>,"An abstract implementation of ListenableFuture, intended for advanced users only. More common ways to create a ListenableFuture include instantiating a SettableFuture, submitting a task to a ListeningExecutorService, and deriving a Future from an existing one, typically using methods like Futures.transform and Futures.catching. This class implements all methods in ListenableFuture. Subclasses should provide a way to set the result of the computation through the protected methods set(Object), setFuture(ListenableFuture) and setException(Throwable). Subclasses may also override afterDone(), which will be invoked automatically when the future completes. Subclasses should rarely override other methods."
559,common/graph,com.google.common.graph,Class AbstractGraph<N>,This class provides a skeletal implementation of Graph. It is recommended to extend this class rather than implement Graph directly.
560,util/concurrent,com.google.common.util.concurrent,Class AbstractIdleService,"Base class for services that do not need a thread while ""running"" but may need one during startup and shutdown. Subclasses can implement startUp() and shutDown() methods, each which run in a executor which by default uses a separate thread for each method."
561,common/reflect,com.google.common.reflect,Class AbstractInvocationHandler,"Abstract implementation of InvocationHandler that handles Object.equals(java.lang.Object), Object.hashCode() and Object.toString(). For example: class Unsupported extends AbstractInvocationHandler { protected Object handleInvocation(Object proxy, Method method, Object[] args) { throw new UnsupportedOperationException(); } } CharSequence unsupported = Reflection.newProxy(CharSequence.class, new Unsupported());"
562,common/collect,com.google.common.collect,Class AbstractIterator<T>,"This class provides a skeletal implementation of the Iterator interface, to make this interface easier to implement for certain types of data sources. Iterator requires its implementations to support querying the end-of-data status without changing the iterator's state, using the hasNext() method. But many data sources, such as Reader.read(), do not expose this information; the only way to discover whether there is any data left is by trying to retrieve it. These types of data sources are ordinarily difficult to write iterators for. But using this class, one must implement only the computeNext() method, and invoke the endOfData() method when appropriate. Another example is an iterator that skips over null elements in a backing iterator. This could be implemented as: public static Iterator<String> skipNulls(final Iterator<String> in) { return new AbstractIterator<String>() { protected String computeNext() { while (in.hasNext()) { String s = in.next(); if (s != null) { return s; } } return endOfData(); } }; } This class supports iterators that include null elements."
563,util/concurrent,com.google.common.util.concurrent,Class AbstractListeningExecutorService,"Abstract ListeningExecutorService implementation that creates ListenableFuture instances for each Runnable and Callable submitted to it. These tasks are run with the abstract execute(Runnable) method. In addition to Executor.execute(java.lang.Runnable), subclasses must implement all methods related to shutdown and termination."
564,common/cache,com.google.common.cache,"Class AbstractLoadingCache<K,V>","This class provides a skeletal implementation of the Cache interface to minimize the effort required to implement this interface. To implement a cache, the programmer needs only to extend this class and provide an implementation for the LoadingCache.get(Object) and Cache.getIfPresent(java.lang.Object) methods. getUnchecked(K), AbstractCache.get(Object, Callable), and getAll(java.lang.Iterable<? extends K>) are implemented in terms of get; AbstractCache.getAllPresent(java.lang.Iterable<?>) is implemented in terms of getIfPresent; AbstractCache.putAll(java.util.Map<? extends K, ? extends V>) is implemented in terms of AbstractCache.put(K, V), AbstractCache.invalidateAll(Iterable) is implemented in terms of AbstractCache.invalidate(java.lang.Object). The method AbstractCache.cleanUp() is a no-op. All other methods throw an UnsupportedOperationException."
565,common/graph,com.google.common.graph,"Class AbstractNetwork<N,E>",This class provides a skeletal implementation of Network. It is recommended to extend this class rather than implement Network directly. The methods implemented in this class should not be overridden unless the subclass admits a more efficient implementation.
566,util/concurrent,com.google.common.util.concurrent,Class AbstractScheduledService,"Base class for services that can implement startUp() and shutDown() but while in the ""running"" state need to perform a periodic task. Subclasses can implement startUp(), shutDown() and also a runOneIteration() method that will be executed periodically. This class uses the ScheduledExecutorService returned from executor() to run the startUp() and shutDown() methods and also uses that service to schedule the runOneIteration() that will be executed periodically as specified by its AbstractScheduledService.Scheduler. When this service is asked to stop via stopAsync() it will cancel the periodic task (but not interrupt it) and wait for it to stop before running the shutDown() method. Subclasses are guaranteed that the life cycle methods (runOneIteration(), startUp() and shutDown()) will never run concurrently. Notably, if any execution of runOneIteration() takes longer than its schedule defines, then subsequent executions may start late. Also, all life cycle methods are executed with a lock held, so subclasses can safely modify shared state without additional synchronization necessary for visibility to later executions of the life cycle methods. Usage ExampleHere is a sketch of a service which crawls a website and uses the scheduling capabilities to rate limit itself. class CrawlingService extends AbstractScheduledService { private Set<Uri> visited; private Queue<Uri> toCrawl; protected void startUp() throws Exception { toCrawl = readStartingUris(); } protected void runOneIteration() throws Exception { Uri uri = toCrawl.remove(); Collection<Uri> newUris = crawl(uri); visited.add(uri); for (Uri newUri : newUris) { if (!visited.contains(newUri)) { toCrawl.add(newUri); } } } protected void shutDown() throws Exception { saveUris(toCrawl); } protected Scheduler scheduler() { return Scheduler.newFixedRateSchedule(0, 1, TimeUnit.SECONDS); } } This class uses the life cycle methods to read in a list of starting URIs and save the set of outstanding URIs when shutting down. Also, it takes advantage of the scheduling functionality to rate limit the number of queries we perform."
567,util/concurrent,com.google.common.util.concurrent,Class AbstractScheduledService.CustomScheduler,"A AbstractScheduledService.Scheduler that provides a convenient way for the AbstractScheduledService to use a dynamically changing schedule. After every execution of the task, assuming it hasn't been cancelled, the getNextSchedule() method will be called."
568,util/concurrent,com.google.common.util.concurrent,Class AbstractScheduledService.CustomScheduler.Schedule,A value object that represents an absolute delay until a task should be invoked.
569,util/concurrent,com.google.common.util.concurrent,Class AbstractScheduledService.Scheduler,"A scheduler defines the policy for how the AbstractScheduledService should run its task. Consider using the newFixedDelaySchedule(java.time.Duration, java.time.Duration) and newFixedRateSchedule(java.time.Duration, java.time.Duration) factory methods, these provide AbstractScheduledService.Scheduler instances for the common use case of running the service with a fixed schedule. If more flexibility is needed then consider subclassing AbstractScheduledService.CustomScheduler."
570,common/collect,com.google.common.collect,Class AbstractSequentialIterator<T>,"This class provides a skeletal implementation of the Iterator interface for sequences whose next element can always be derived from the previous element. Null elements are not supported, nor is the UnmodifiableIterator.remove() method. Example: Iterator<Integer> powersOfTwo = new AbstractSequentialIterator<Integer>(1) { protected Integer computeNext(Integer previous) { return (previous == 1 << 30) ? null : previous * 2; } };"
571,util/concurrent,com.google.common.util.concurrent,Class AbstractService,"Base class for implementing services that can handle doStart() and doStop() requests, responding to them with notifyStarted() and notifyStopped() callbacks. Its subclasses must manage threads manually; consider AbstractExecutionThreadService if you need only a single execution thread."
572,common/graph,com.google.common.graph,"Class AbstractValueGraph<N,V>",This class provides a skeletal implementation of ValueGraph. It is recommended to extend this class rather than implement ValueGraph directly. The methods implemented in this class should not be overridden unless the subclass admits a more efficient implementation.
573,common/eventbus,com.google.common.eventbus,Annotation Type AllowConcurrentEvents,"Marks an event subscriber method as being thread-safe. This annotation indicates that EventBus may invoke the event subscriber simultaneously from multiple threads. This does not mark the method, and so should be used in combination with Subscribe."
574,common/escape,com.google.common.escape,Class ArrayBasedCharEscaper,A CharEscaper that uses an array to quickly look up replacement characters for a given char value. An additional safe range is provided that determines whether char values without specific replacements are to be considered safe and left unescaped or should be escaped in a general way. A good example of usage of this class is for Java source code escaping where the replacement array contains information about special ASCII characters such as \\t and \\n while escapeUnsafe(char) is overridden to handle general escaping of the form \\uxxxx. The size of the data structure used by ArrayBasedCharEscaper is proportional to the highest valued character that requires escaping. For example a replacement map containing the single character '\u1000' will require approximately 16K of memory. If you need to create multiple escaper instances that have the same character replacement mapping consider using ArrayBasedEscaperMap.
575,common/escape,com.google.common.escape,Class ArrayBasedEscaperMap,An implementation-specific parameter class suitable for initializing ArrayBasedCharEscaper or ArrayBasedUnicodeEscaper instances. This class should be used when more than one escaper is created using the same character replacement mapping to allow the underlying (implementation specific) data structures to be shared. The size of the data structure used by ArrayBasedCharEscaper and ArrayBasedUnicodeEscaper is proportional to the highest valued character that has a replacement. For example a replacement map containing the single character '\u1000' will require approximately 16K of memory. As such sharing this data structure between escaper instances is the primary goal of this class.
576,common/escape,com.google.common.escape,Class ArrayBasedUnicodeEscaper,A UnicodeEscaper that uses an array to quickly look up replacement characters for a given code point. An additional safe range is provided that determines whether code points without specific replacements are to be considered safe and left unescaped or should be escaped in a general way. A good example of usage of this class is for HTML escaping where the replacement array contains information about the named HTML entities such as &amp; and &quot; while escapeUnsafe(int) is overridden to handle general escaping of the form &#NNNNN;. The size of the data structure used by ArrayBasedUnicodeEscaper is proportional to the highest valued code point that requires escaping. For example a replacement map containing the single character '\u1000' will require approximately 16K of memory. If you need to create multiple escaper instances that have the same character replacement mapping consider using ArrayBasedEscaperMap.
577,common/collect,com.google.common.collect,"Class ArrayListMultimap<K,V>","Implementation of Multimap that uses an ArrayList to store the values for a given key. A HashMap associates each key with an ArrayList of values. When iterating through the collections supplied by this class, the ordering of values for a given key agrees with the order in which the values were added. This multimap allows duplicate key-value pairs. After adding a new key-value pair equal to an existing key-value pair, the ArrayListMultimap will contain entries for both the new value and the old value. Keys and values may be null. All optional multimap methods are supported, and all returned views are modifiable. The lists returned by get(K), removeAll(java.lang.Object), and replaceValues(K, java.lang.Iterable<? extends V>) all implement RandomAccess. This class is not threadsafe when any concurrent operations update the multimap. Concurrent read operations will work correctly. To allow concurrent update operations, wrap your multimap with a call to Multimaps.synchronizedListMultimap(com.google.common.collect.ListMultimap<K, V>). See the Guava User Guide article on Multimap."
578,common/collect,com.google.common.collect,"Class ArrayTable<R,C,V>","Fixed-size Table implementation backed by a two-dimensional array. The allowed row and column keys must be supplied when the table is created. The table always contains a mapping for every row key / column pair. The value corresponding to a given row and column is null unless another value is provided. The table's size is constant: the product of the number of supplied row keys and the number of supplied column keys. The remove and clear methods are not supported by the table or its views. The erase(java.lang.Object, java.lang.Object) and eraseAll() methods may be used instead. The ordering of the row and column keys provided when the table is constructed determines the iteration ordering across rows and columns in the table's views. None of the view iterators support Iterator.remove(). If the table is modified after an iterator is created, the iterator remains valid. This class requires less memory than the HashBasedTable and TreeBasedTable implementations, except when the table is sparse. Null row keys or column keys are not permitted. This class provides methods involving the underlying array structure, where the array indices correspond to the position of a row or column in the lists of allowed keys and values. See the at(int, int), set(int, int, V), toArray(java.lang.Class<V>), rowKeyList(), and columnKeyList() methods for more details. Note that this implementation is not synchronized. If multiple threads access the same cell of an ArrayTable concurrently and one of the threads modifies its value, there is no guarantee that the new value will be fully visible to the other threads. To guarantee that modifications are visible, synchronize access to the table. Unlike other Table implementations, synchronization is unnecessary between a thread that writes to one cell and a thread that reads from another. See the Guava User Guide article on Table."
579,common/base,com.google.common.base,Class Ascii,"Static methods pertaining to ASCII characters (those in the range of values 0x00 through 0x7F), and to strings containing such characters. ASCII utilities also exist in other classes of this package: Charsets.US_ASCII specifies the Charset of ASCII characters. CharMatcher.ascii() matches ASCII characters and provides text processing methods which operate only on the ASCII characters of a string."
580,util/concurrent,com.google.common.util.concurrent,Interface AsyncCallable<V>,"Computes a value, possibly asynchronously. For an example usage and more information, see Futures.FutureCombiner.callAsync(AsyncCallable, java.util.concurrent.Executor). Much like Callable, but returning a ListenableFuture result."
581,common/eventbus,com.google.common.eventbus,Class AsyncEventBus,"An EventBus that takes the Executor of your choice and uses it to dispatch events, allowing dispatch to occur asynchronously."
582,util/concurrent,com.google.common.util.concurrent,"Interface AsyncFunction<I,O>","Transforms a value, possibly asynchronously. For an example usage and more information, see Futures.transformAsync(ListenableFuture, AsyncFunction, Executor)."
583,util/concurrent,com.google.common.util.concurrent,Class AtomicDouble,"A double value that may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables. An AtomicDouble is used in applications such as atomic accumulation, and cannot be used as a replacement for a Double. However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes. This class compares primitive double values in methods such as compareAndSet(double, double) by comparing their bitwise representation using Double.doubleToRawLongBits(double), which differs from both the primitive double == operator and from Double.equals(java.lang.Object), as if implemented by: static boolean bitEquals(double x, double y) { long xBits = Double.doubleToRawLongBits(x); long yBits = Double.doubleToRawLongBits(y); return xBits == yBits; } It is possible to write a more scalable updater, at the cost of giving up strict atomicity. See for example DoubleAdder."
584,util/concurrent,com.google.common.util.concurrent,Class AtomicDoubleArray,"A double array in which elements may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables. This class compares primitive double values in methods such as compareAndSet(int, double, double) by comparing their bitwise representation using Double.doubleToRawLongBits(double), which differs from both the primitive double == operator and from Double.equals(java.lang.Object), as if implemented by: static boolean bitEquals(double x, double y) { long xBits = Double.doubleToRawLongBits(x); long yBits = Double.doubleToRawLongBits(y); return xBits == yBits; }"
585,util/concurrent,com.google.common.util.concurrent,Class AtomicLongMap<K>,"A map containing long values that can be atomically updated. While writes to a traditional Map rely on put(K, V), the typical mechanism for writing to this map is addAndGet(K, long), which adds a long to the value currently associated with K. If a key has not yet been associated with a value, its implicit value is zero. Most methods in this class treat absent values and zero values identically, as individually documented. Exceptions to this are containsKey(java.lang.Object), size(), isEmpty(), asMap, and toString(). Instances of this class may be used by multiple threads concurrently. All operations are atomic unless otherwise noted. Note: If your values are always positive and less than 2^31, you may wish to use a Multiset such as ConcurrentHashMultiset instead. Warning: Unlike Multiset, entries whose values are zero are not automatically removed from the map. Instead they must be removed manually with removeAllZeros()."
586,util/concurrent,com.google.common.util.concurrent,Class Atomics,Static utility methods pertaining to classes in the java.util.concurrent.atomic package.
587,common/io,com.google.common.io,Class BaseEncoding,"A binary encoding scheme for reversibly translating between byte sequences and printable ASCII strings. This class includes several constants for encoding schemes specified by RFC 4648. For example, the expression: BaseEncoding.base32().encode(""foo"".getBytes(Charsets.US_ASCII)) returns the string ""MZXW6==="", and byte[] decoded = BaseEncoding.base32().decode(""MZXW6===""); ...returns the ASCII bytes of the string ""foo"". By default, BaseEncoding's behavior is relatively strict and in accordance with RFC 4648. Decoding rejects characters in the wrong case, though padding is optional. To modify encoding and decoding behavior, use configuration methods to obtain a new encoding with modified behavior: BaseEncoding.base16().lowerCase().decode(""deadbeef""); Warning: BaseEncoding instances are immutable. Invoking a configuration method has no effect on the receiving instance; you must store and use the new encoding instance it returns, instead. // Do NOT do this BaseEncoding hex = BaseEncoding.base16(); hex.lowerCase(); // does nothing! return hex.decode(""deadbeef""); // throws an IllegalArgumentException It is guaranteed that encoding.decode(encoding.encode(x)) is always equal to x, but the reverse does not necessarily hold. EncodingsEncoding Alphabet char:byte ratio Default padding Comments base16()0-9 A-F 2.00 N/A Traditional hexadecimal. Defaults to upper case. base32()A-Z 2-7 1.60 = Human-readable; no possibility of mixing up 0/O or 1/I. Defaults to upper case. base32Hex()0-9 A-V 1.60 = ""Numerical"" base 32; extended from the traditional hex alphabet. Defaults to upper case. base64()A-Z a-z 0-9 + / 1.33 = base64Url()A-Z a-z 0-9 - _ 1.33 = Safe to use as filenames, or to pass in URLs without escaping All instances of this class are immutable, so they may be stored safely as static constants."
588,common/io,com.google.common.io,Class BaseEncoding.DecodingException,Exception indicating invalid base-encoded input encountered while decoding.
589,common/annotations,com.google.common.annotations,Annotation Type Beta,"Signifies that a public API (public class, method or field) is subject to incompatible changes, or even removal, in a future release. An API bearing this annotation is exempt from any compatibility guarantees made by its containing library. Note that the presence of this annotation implies nothing about the quality or performance of the API in question, only the fact that it is not ""API-frozen."" It is generally safe for applications to depend on beta APIs, at the cost of some extra work during upgrades. However it is generally inadvisable for libraries (which get included on users' CLASSPATHs, outside the library developers' control) to do so."
590,common/math,com.google.common.math,Class BigDecimalMath,A class for arithmetic on BigDecimal that is not covered by its built-in methods.
591,common/math,com.google.common.math,Class BigIntegerMath,"A class for arithmetic on values of type BigInteger. The implementations of many methods in this class are based on material from Henry S. Warren, Jr.'s Hacker's Delight, (Addison Wesley, 2002). Similar functionality for int and for long can be found in IntMath and LongMath respectively."
592,common/collect,com.google.common.collect,"Interface BiMap<K,V>","A bimap (or ""bidirectional map"") is a map that preserves the uniqueness of its values as well as that of its keys. This constraint enables bimaps to support an ""inverse view"", which is another bimap containing the same entries as this bimap but with reversed keys and values. See the Guava User Guide article on BiMap."
593,common/hash,com.google.common.hash,Class BloomFilter<T>,"A Bloom filter for instances of T. A Bloom filter offers an approximate containment test with one-sided error: if it claims that an element is contained in it, this might be in error, but if it claims that an element is not contained in it, then this is definitely true. If you are unfamiliar with Bloom filters, this nice tutorial may help you understand how they work. The false positive probability (FPP) of a Bloom filter is defined as the probability that mightContain(Object) will erroneously return true for an object that has not actually been put in the BloomFilter. Bloom filters are serializable. They also support a more compact serial representation via the writeTo(java.io.OutputStream) and readFrom(java.io.InputStream, com.google.common.hash.Funnel<? super T>) methods. Both serialized forms will continue to be supported by future versions of this library. However, serial forms generated by newer versions of the code may not be readable by older versions of the code (e.g., a serialized Bloom filter generated today may not be readable by a binary that was compiled 6 months ago). As of Guava 23.0, this class is thread-safe and lock-free. It internally uses atomics and compare-and-swap to ensure correctness when multiple threads are used to access it."
594,common/primitives,com.google.common.primitives,Class Booleans,"Static utility methods pertaining to boolean primitives, that are not already found in either Boolean or Arrays. See the Guava User Guide article on primitive utilities."
595,common/collect,com.google.common.collect,Enum BoundType,"Indicates whether an endpoint of some range is contained in the range itself (""closed"") or not (""open""). If a range is unbounded on a side, it is neither open nor closed on that side; the bound simply does not exist."
596,common/io,com.google.common.io,Interface ByteArrayDataInput,"An extension of DataInput for reading from in-memory byte arrays; its methods offer identical functionality but do not throw IOException. Warning: The caller is responsible for not attempting to read past the end of the array. If any method encounters the end of the array prematurely, it throws IllegalStateException to signify programmer error. This behavior is a technical violation of the supertype's contract, which specifies a checked exception."
597,common/io,com.google.common.io,Interface ByteArrayDataOutput,An extension of DataOutput for writing to in-memory byte arrays; its methods offer identical functionality but do not throw IOException.
598,common/io,com.google.common.io,Interface ByteProcessor<T>,"A callback interface to process bytes from a stream. processBytes(byte[], int, int) will be called for each chunk of data that is read, and should return false when you want to stop processing."
599,common/primitives,com.google.common.primitives,Class Bytes,"Static utility methods pertaining to byte primitives, that are not already found in either Byte or Arrays, and interpret bytes as neither signed nor unsigned. The methods which specifically treat bytes as signed or unsigned are found in SignedBytes and UnsignedBytes. See the Guava User Guide article on primitive utilities."
600,common/io,com.google.common.io,Class ByteSink,"A destination to which bytes can be written, such as a file. Unlike an OutputStream, a ByteSink is not an open, stateful stream that can be written to and closed. Instead, it is an immutable supplier of OutputStream instances. ByteSink provides two kinds of methods: Methods that return a stream: These methods should return a new, independent instance each time they are called. The caller is responsible for ensuring that the returned stream is closed. Convenience methods: These are implementations of common operations that are typically implemented by opening a stream using one of the methods in the first category, doing something and finally closing the stream or channel that was opened."
601,common/io,com.google.common.io,Class ByteSource,"A readable source of bytes, such as a file. Unlike an InputStream, a ByteSource is not an open, stateful stream for input that can be read and closed. Instead, it is an immutable supplier of InputStream instances. ByteSource provides two kinds of methods: Methods that return a stream: These methods should return a new, independent instance each time they are called. The caller is responsible for ensuring that the returned stream is closed. Convenience methods: These are implementations of common operations that are typically implemented by opening a stream using one of the methods in the first category, doing something and finally closing the stream that was opened."
602,common/io,com.google.common.io,Class ByteStreams,Provides utility methods for working with byte arrays and I/O streams.
603,common/cache,com.google.common.cache,"Interface Cache<K,V>","A semi-persistent mapping from keys to values. Cache entries are manually added using get(Object, Callable) or put(Object, Object), and are stored in the cache until either evicted or manually invalidated. The common way to build instances is using CacheBuilder. Implementations of this interface are expected to be thread-safe, and can be safely accessed by multiple concurrent threads."
604,common/cache,com.google.common.cache,"Class CacheBuilder<K,V>","A builder of LoadingCache and Cache instances having any combination of the following features: automatic loading of entries into the cache least-recently-used eviction when a maximum size is exceeded time-based expiration of entries, measured since last access or last write keys automatically wrapped in WeakReferencevalues automatically wrapped in WeakReference or SoftReferencenotification of evicted (or otherwise removed) entries accumulation of cache access statistics These features are all optional; caches can be created using all or none of them. By default cache instances created by CacheBuilder will not perform any type of eviction. Usage example: LoadingCache<Key, Graph> graphs = CacheBuilder.newBuilder() .maximumSize(10000) .expireAfterWrite(Duration.ofMinutes(10)) .removalListener(MY_LISTENER) .build( new CacheLoader<Key, Graph>() { public Graph load(Key key) throws AnyException { return createExpensiveGraph(key); } }); Or equivalently, // In real life this would come from a command-line flag or config file String spec = ""maximumSize=10000,expireAfterWrite=10m""; LoadingCache<Key, Graph> graphs = CacheBuilder.from(spec) .removalListener(MY_LISTENER) .build( new CacheLoader<Key, Graph>() { public Graph load(Key key) throws AnyException { return createExpensiveGraph(key); } }); The returned cache is implemented as a hash table with similar performance characteristics to ConcurrentHashMap. It implements all optional operations of the LoadingCache and Cache interfaces. The asMap view (and its collection views) have weakly consistent iterators. This means that they are safe for concurrent use, but if other threads modify the cache after the iterator is created, it is undefined which of these changes, if any, are reflected in that iterator. These iterators never throw ConcurrentModificationException. Note: by default, the returned cache uses equality comparisons (the equals method) to determine equality for keys or values. However, if weakKeys() was specified, the cache uses identity (==) comparisons instead for keys. Likewise, if weakValues() or softValues() was specified, the cache uses identity comparisons for values. Entries are automatically evicted from the cache when any of maximumSize, maximumWeight, expireAfterWrite, expireAfterAccess, weakKeys, weakValues, or softValues are requested. If maximumSize or maximumWeight is requested entries may be evicted on each cache modification. If expireAfterWrite or expireAfterAccess is requested entries may be evicted on each cache modification, on occasional cache accesses, or on calls to Cache.cleanUp(). Expired entries may be counted by Cache.size(), but will never be visible to read or write operations. If weakKeys, weakValues, or softValues are requested, it is possible for a key or value present in the cache to be reclaimed by the garbage collector. Entries with reclaimed keys or values may be removed from the cache on each cache modification, on occasional cache accesses, or on calls to Cache.cleanUp(); such entries may be counted in Cache.size(), but will never be visible to read or write operations. Certain cache configurations will result in the accrual of periodic maintenance tasks which will be performed during write operations, or during occasional read operations in the absence of writes. The Cache.cleanUp() method of the returned cache will also perform maintenance, but calling it should not be necessary with a high throughput cache. Only caches built with removalListener, expireAfterWrite, expireAfterAccess, weakKeys, weakValues, or softValues perform periodic maintenance. The caches produced by CacheBuilder are serializable, and the deserialized caches retain all the configuration properties of the original cache. Note that the serialized form does not include cache contents, but only configuration. See the Guava User Guide article on caching for a higher-level explanation."
605,common/cache,com.google.common.cache,Class CacheBuilderSpec,"A specification of a CacheBuilder configuration. CacheBuilderSpec supports parsing configuration off of a string, which makes it especially useful for command-line configuration of a CacheBuilder. The string syntax is a series of comma-separated keys or key-value pairs, each corresponding to a CacheBuilder method. concurrencyLevel=[integer]: sets CacheBuilder.concurrencyLevel. initialCapacity=[integer]: sets CacheBuilder.initialCapacity. maximumSize=[long]: sets CacheBuilder.maximumSize. maximumWeight=[long]: sets CacheBuilder.maximumWeight. expireAfterAccess=[duration]: sets CacheBuilder.expireAfterAccess(java.time.Duration). expireAfterWrite=[duration]: sets CacheBuilder.expireAfterWrite(java.time.Duration). refreshAfterWrite=[duration]: sets CacheBuilder.refreshAfterWrite(java.time.Duration). weakKeys: sets CacheBuilder.weakKeys(). softValues: sets CacheBuilder.softValues(). weakValues: sets CacheBuilder.weakValues(). recordStats: sets CacheBuilder.recordStats(). The set of supported keys will grow as CacheBuilder evolves, but existing keys will never be removed. Durations are represented by an integer, followed by one of ""d"", ""h"", ""m"", or ""s"", representing days, hours, minutes, or seconds respectively. (There is currently no syntax to request expiration in milliseconds, microseconds, or nanoseconds.) Whitespace before and after commas and equal signs is ignored. Keys may not be repeated; it is also illegal to use the following pairs of keys in a single value: maximumSize and maximumWeightsoftValues and weakValuesCacheBuilderSpec does not support configuring CacheBuilder methods with non-value parameters. These must be configured in code. A new CacheBuilder can be instantiated from a CacheBuilderSpec using CacheBuilder.from(CacheBuilderSpec) or CacheBuilder.from(String)."
606,common/cache,com.google.common.cache,"Class CacheLoader<K,V>","Computes or retrieves values, based on a key, for use in populating a LoadingCache. Most implementations will only need to implement load(K). Other methods may be overridden as desired. Usage example: CacheLoader<Key, Graph> loader = new CacheLoader<Key, Graph>() { public Graph load(Key key) throws AnyException { return createExpensiveGraph(key); } }; LoadingCache<Key, Graph> cache = CacheBuilder.newBuilder().build(loader); Since this example doesn't support reloading or bulk loading, it can also be specified much more simply: CacheLoader<Key, Graph> loader = CacheLoader.from(key -> createExpensiveGraph(key));"
607,common/cache,com.google.common.cache,Class CacheLoader.InvalidCacheLoadException,Thrown to indicate that an invalid response was returned from a call to CacheLoader.
608,common/cache,com.google.common.cache,Class CacheLoader.UnsupportedLoadingOperationException,Exception thrown by loadAll() to indicate that it is not supported.
609,common/cache,com.google.common.cache,Class CacheStats,"Statistics about the performance of a Cache. Instances of this class are immutable. Cache statistics are incremented according to the following rules: When a cache lookup encounters an existing cache entry hitCount is incremented. When a cache lookup first encounters a missing cache entry, a new entry is loaded. After successfully loading an entry missCount and loadSuccessCount are incremented, and the total loading time, in nanoseconds, is added to totalLoadTime. When an exception is thrown while loading an entry, missCount and loadExceptionCount are incremented, and the total loading time, in nanoseconds, is added to totalLoadTime. Cache lookups that encounter a missing cache entry that is still loading will wait for loading to complete (whether successful or not) and then increment missCount. When an entry is evicted from the cache, evictionCount is incremented. No stats are modified when a cache entry is invalidated or manually removed. No stats are modified by operations invoked on the asMap view of the cache. A lookup is specifically defined as an invocation of one of the methods LoadingCache.get(Object), LoadingCache.getUnchecked(Object), Cache.get(Object, Callable), or LoadingCache.getAll(Iterable)."
610,util/concurrent,com.google.common.util.concurrent,Class Callables,Static utility methods pertaining to the Callable interface.
611,common/base,com.google.common.base,Enum CaseFormat,Utility class for converting between various ASCII case formats. Behavior is undefined for non-ASCII input.
612,common/escape,com.google.common.escape,Class CharEscaper,"An object that converts literal text into a format safe for inclusion in a particular context (such as an XML document). Typically (but not always), the inverse process of ""unescaping"" the text is performed automatically by the relevant parser. For example, an XML escaper would convert the literal string ""Foo<Bar>"" into ""Foo&lt;Bar&gt;"" to prevent ""<Bar>"" from being confused with an XML tag. When the resulting XML document is parsed, the parser API will return this text as the original literal string ""Foo<Bar>"". A CharEscaper instance is required to be stateless, and safe when used concurrently by multiple threads. Popular escapers are defined as constants in classes like HtmlEscapers and XmlEscapers. To create your own escapers extend this class and implement the escape(char) method."
613,common/escape,com.google.common.escape,Class CharEscaperBuilder,"Simple helper class to build a ""sparse"" array of objects based on the indexes that were added to it. The array will be from 0 to the maximum index given. All non-set indexes will contain null (so it's not really a sparse array, just a pseudo sparse array). The builder can also return a CharEscaper based on the generated array."
614,common/base,com.google.common.base,Class CharMatcher,"Determines a true or false value for any Java char value, just as Predicate does for any Object. Also offers basic text processing methods based on this function. Implementations are strongly encouraged to be side-effect-free and immutable. Throughout the documentation of this class, the phrase ""matching character"" is used to mean ""any char value c for which this.matches(c) returns true"". Warning: This class deals only with char values, that is, BMP characters. It does not understand supplementary Unicode code points in the range 0x10000 to 0x10FFFF which includes the majority of assigned characters, including important CJK characters and emoji. Supplementary characters are encoded into a String using surrogate pairs, and a CharMatcher treats these just as two separate characters. countIn(java.lang.CharSequence) counts each supplementary character as 2 chars. For up-to-date Unicode character properties (digit, letter, etc.) and support for supplementary code points, use ICU4J UCharacter and UnicodeSet (freeze() after building). For basic text processing based on UnicodeSet use the ICU4J UnicodeSetSpanner. Example usages: String trimmed = whitespace().trimFrom(userInput); if (ascii().matchesAllOf(s)) { ... }See the Guava User Guide article on CharMatcher."
615,common/primitives,com.google.common.primitives,Class Chars,"Static utility methods pertaining to char primitives, that are not already found in either Character or Arrays. All the operations in this class treat char values strictly numerically; they are neither Unicode-aware nor locale-dependent. See the Guava User Guide article on primitive utilities."
616,common/base,com.google.common.base,Class Charsets,"Contains constant definitions for the six standard Charset instances, which are guaranteed to be supported by all Java platform implementations. Assuming you're free to choose, note that UTF_8 is widely preferred. See the Guava User Guide article on Charsets."
617,common/io,com.google.common.io,Class CharSink,"A destination to which characters can be written, such as a text file. Unlike a Writer, a CharSink is not an open, stateful stream that can be written to and closed. Instead, it is an immutable supplier of Writer instances. CharSink provides two kinds of methods: Methods that return a writer: These methods should return a new, independent instance each time they are called. The caller is responsible for ensuring that the returned writer is closed. Convenience methods: These are implementations of common operations that are typically implemented by opening a writer using one of the methods in the first category, doing something and finally closing the writer that was opened. Any ByteSink may be viewed as a CharSink with a specific character encoding using ByteSink.asCharSink(Charset). Characters written to the resulting CharSink will written to the ByteSink as encoded bytes."
618,common/io,com.google.common.io,Class CharSource,"A readable source of characters, such as a text file. Unlike a Reader, a CharSource is not an open, stateful stream of characters that can be read and closed. Instead, it is an immutable supplier of Reader instances. CharSource provides two kinds of methods: Methods that return a reader: These methods should return a new, independent instance each time they are called. The caller is responsible for ensuring that the returned reader is closed. Convenience methods: These are implementations of common operations that are typically implemented by opening a reader using one of the methods in the first category, doing something and finally closing the reader that was opened. Several methods in this class, such as readLines(), break the contents of the source into lines. Like BufferedReader, these methods break lines on any of \n, \r or \r\n, do not include the line separator in each line and do not consider there to be an empty line at the end if the contents are terminated with a line separator. Any ByteSource containing text encoded with a specific character encoding may be viewed as a CharSource using ByteSource.asCharSource(Charset)."
619,common/io,com.google.common.io,Class CharStreams,Provides utility methods for working with character streams. All method parameters must be non-null unless documented otherwise. Some of the methods in this class take arguments with a generic type of Readable & Closeable. A Reader implements both of those interfaces. Similarly for Appendable & Closeable and Writer.
620,common/reflect,com.google.common.reflect,Class ClassPath,"Scans the source of a ClassLoader and finds all loadable classes and resources. Warning: Current limitations: Looks only for files and JARs in URLs available from URLClassLoader instances or the system class loader. Only understands file: URLs. In the case of directory classloaders, symlinks are supported but cycles are not traversed. This guarantees discovery of each unique loadable resource. However, not all possible aliases for resources on cyclic paths will be listed."
621,common/reflect,com.google.common.reflect,Class ClassPath.ClassInfo,Represents a class that can be loaded through load().
622,common/reflect,com.google.common.reflect,Class ClassPath.ResourceInfo,Represents a class path resource that can be either a class file or any other resource file loadable from the class path.
623,common/collect,com.google.common.collect,Interface ClassToInstanceMap<B>,"A map, each entry of which maps a Java raw type to an instance of that type. In addition to implementing Map, the additional type-safe operations putInstance(java.lang.Class<T>, T) and getInstance(java.lang.Class<T>) are available. Like any other Map<Class, Object>, this map may contain entries for primitive types, and a primitive type and its corresponding wrapper type may map to different values. See the Guava User Guide article on ClassToInstanceMap. To map a generic type to an instance of that type, use TypeToInstanceMap instead."
624,common/io,com.google.common.io,Class Closeables,Utility methods for working with Closeable objects.
625,common/io,com.google.common.io,Class Closer,"A Closeable that collects Closeable resources and closes them all when it is closed. This is intended to approximately emulate the behavior of Java 7's try-with-resources statement in JDK6-compatible code. Running on Java 7, code using this should be approximately equivalent in behavior to the same code written with try-with-resources. Running on Java 6, exceptions that cannot be thrown must be logged rather than being added to the thrown exception as a suppressed exception. This class is intended to be used in the following pattern: Closer closer = Closer.create(); try { InputStream in = closer.register(openInputStream()); OutputStream out = closer.register(openOutputStream()); // do stuff } catch (Throwable e) { // ensure that any checked exception types other than IOException that could be thrown are // provided here, e.g. throw closer.rethrow(e, CheckedException.class); throw closer.rethrow(e); } finally { closer.close(); } Note that this try-catch-finally block is not equivalent to a try-catch-finally block using try-with-resources. To get the equivalent of that, you must wrap the above code in another try block in order to catch any exception that may be thrown (including from the call to close()). This pattern ensures the following: Each Closeable resource that is successfully registered will be closed later. If a Throwable is thrown in the try block, no exceptions that occur when attempting to close resources will be thrown from the finally block. The throwable from the try block will be thrown. If no exceptions or errors were thrown in the try block, the first exception thrown by an attempt to close a resource will be thrown. Any exception caught when attempting to close a resource that is not thrown (because another exception is already being thrown) is suppressed. An exception that is suppressed is not thrown. The method of suppression used depends on the version of Java the code is running on: Java 7+: Exceptions are suppressed by adding them to the exception that will be thrown using Throwable.addSuppressed(Throwable). Java 6: Exceptions are suppressed by logging them instead."
626,util/concurrent,com.google.common.util.concurrent,Class ClosingFuture<V>,"A step in a pipeline of an asynchronous computation. When the last step in the computation is complete, some objects captured during the computation are closed. A pipeline of ClosingFutures is a tree of steps. Each step represents either an asynchronously-computed intermediate value, or else an exception that indicates the failure or cancellation of the operation so far. The only way to extract the value or exception from a step is by declaring that step to be the last step of the pipeline. Nevertheless, we refer to the ""value"" of a successful step or the ""result"" (value or exception) of any step. A pipeline starts at its leaf step (or steps), which is created from either a callable block or a ListenableFuture. Each other step is derived from one or more input steps. At each step, zero or more objects can be captured for later closing. There is one last step (the root of the tree), from which you can extract the final result of the computation. After that result is available (or the computation fails), all objects captured by any of the steps in the pipeline are closed. Starting a pipeline Start a ClosingFuture pipeline from a callable block that may capture objects for later closing. To start a pipeline from a ListenableFuture that doesn't create resources that should be closed later, you can use from(ListenableFuture) instead. Derived steps A ClosingFuture step can be derived from one or more input ClosingFuture steps in ways similar to FluentFutures: by transforming the value from a successful input step, by catching the exception from a failed input step, or by combining the results of several input steps. Each derivation can capture the next value or any intermediate objects for later closing. A step can be the input to at most one derived step. Once you transform its value, catch its exception, or combine it with others, you cannot do anything else with it, including declare it to be the last step of the pipeline. Transforming To derive the next step by asynchronously applying a function to an input step's value, call transform(ClosingFunction, Executor) or transformAsync(AsyncClosingFunction, Executor) on the input step. Catching To derive the next step from a failed input step, call catching(Class, ClosingFunction, Executor) or catchingAsync(Class, AsyncClosingFunction, Executor) on the input step. Combining To derive a ClosingFuture from two or more input steps, pass the input steps to whenAllComplete(Iterable) or whenAllSucceed(Iterable) or its overloads. Cancelling Any step in a pipeline can be cancelled, even after another step has been derived, with the same semantics as cancelling a Future. In addition, a successfully cancelled step will immediately start closing all objects captured for later closing by it and by its input steps. Ending a pipeline Each ClosingFuture pipeline must be ended. To end a pipeline, decide whether you want to close the captured objects automatically or manually. Automatically closing You can extract a Future that represents the result of the last step in the pipeline by calling finishToFuture(). When that final Future is done, all objects captured by all steps in the pipeline will be closed. FluentFuture<UserName> userName = ClosingFuture.submit( closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor), executor) .transformAsync((closer, transaction) -> transaction.queryClosingFuture(""...""), executor) .transform((closer, result) -> result.get(""userName""), directExecutor()) .catching(DBException.class, e -> ""no user"", directExecutor()) .finishToFuture(); In this example, when the userName Future is done, the transaction and the query result cursor will both be closed, even if the operation is cancelled or fails. Manually closing If you want to close the captured objects manually, after you've used the final result, call finishToValueAndCloser(ValueAndCloserConsumer, Executor) to get an object that holds the final result. You then call ClosingFuture.ValueAndCloser.closeAsync() to close the captured objects. ClosingFuture.submit( closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor), executor) .transformAsync((closer, transaction) -> transaction.queryClosingFuture(""...""), executor) .transform((closer, result) -> result.get(""userName""), directExecutor()) .catching(DBException.class, e -> ""no user"", directExecutor()) .finishToValueAndCloser( valueAndCloser -> this.userNameValueAndCloser = valueAndCloser, executor); // later try { // get() will throw if the operation failed or was cancelled. UserName userName = userNameValueAndCloser.get(); // do something with userName } finally { userNameValueAndCloser.closeAsync(); } In this example, when userNameValueAndCloser.closeAsync() is called, the transaction and the query result cursor will both be closed, even if the operation is cancelled or fails. Note that if you don't call closeAsync(), the captured objects will not be closed. The automatic-closing approach described above is safer."
627,util/concurrent,com.google.common.util.concurrent,Interface ClosingFuture.AsyncClosingCallable<V>,An operation that computes a ClosingFuture of a result.
628,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.AsyncClosingFunction<T,U>",A function from an input to a ClosingFuture of a result.
629,util/concurrent,com.google.common.util.concurrent,Interface ClosingFuture.ClosingCallable<V>,An operation that computes a result.
630,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.ClosingFunction<T,U>",A function from an input to a result.
631,util/concurrent,com.google.common.util.concurrent,Class ClosingFuture.Combiner,"A builder of a ClosingFuture step that is derived from more than one input step. See ClosingFuture.whenAllComplete(Iterable) and ClosingFuture.whenAllSucceed(Iterable) for how to instantiate this class. Example: final ClosingFuture<BufferedReader> file1ReaderFuture = ...; final ClosingFuture<BufferedReader> file2ReaderFuture = ...; ListenableFuture<Integer> numberOfDifferentLines = ClosingFuture.whenAllSucceed(file1ReaderFuture, file2ReaderFuture) .call( (closer, peeker) -> { BufferedReader file1Reader = peeker.getDone(file1ReaderFuture); BufferedReader file2Reader = peeker.getDone(file2ReaderFuture); return countDifferentLines(file1Reader, file2Reader); }, executor) .closing(executor);"
632,util/concurrent,com.google.common.util.concurrent,Interface ClosingFuture.Combiner.AsyncCombiningCallable<V>,An operation that returns a ClosingFuture result and may throw an exception.
633,util/concurrent,com.google.common.util.concurrent,Interface ClosingFuture.Combiner.CombiningCallable<V>,An operation that returns a result and may throw an exception.
634,util/concurrent,com.google.common.util.concurrent,"Class ClosingFuture.Combiner2<V1,V2>","A generic ClosingFuture.Combiner that lets you use a lambda or method reference to combine two ClosingFutures. Use ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture) to start this combination."
635,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner2.AsyncClosingFunction2<V1,V2,U>","A function that returns a ClosingFuture when applied to the values of the two futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture)."
636,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner2.ClosingFunction2<V1,V2,U>","A function that returns a value when applied to the values of the two futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture)."
637,util/concurrent,com.google.common.util.concurrent,"Class ClosingFuture.Combiner3<V1,V2,V3>","A generic ClosingFuture.Combiner that lets you use a lambda or method reference to combine three ClosingFutures. Use ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture) to start this combination."
638,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner3.AsyncClosingFunction3<V1,V2,V3,U>","A function that returns a ClosingFuture when applied to the values of the three futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)."
639,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner3.ClosingFunction3<V1,V2,V3,U>","A function that returns a value when applied to the values of the three futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)."
640,util/concurrent,com.google.common.util.concurrent,"Class ClosingFuture.Combiner4<V1,V2,V3,V4>","A generic ClosingFuture.Combiner that lets you use a lambda or method reference to combine four ClosingFutures. Use ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture) to start this combination."
641,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner4.AsyncClosingFunction4<V1,V2,V3,V4,U>","A function that returns a ClosingFuture when applied to the values of the four futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)."
642,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner4.ClosingFunction4<V1,V2,V3,V4,U>","A function that returns a value when applied to the values of the four futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)."
643,util/concurrent,com.google.common.util.concurrent,"Class ClosingFuture.Combiner5<V1,V2,V3,V4,V5>","A generic ClosingFuture.Combiner that lets you use a lambda or method reference to combine five ClosingFutures. Use ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture) to start this combination."
644,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner5.AsyncClosingFunction5<V1,V2,V3,V4,V5,U>","A function that returns a ClosingFuture when applied to the values of the five futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)."
645,util/concurrent,com.google.common.util.concurrent,"Interface ClosingFuture.Combiner5.ClosingFunction5<V1,V2,V3,V4,V5,U>","A function that returns a value when applied to the values of the five futures passed to ClosingFuture.whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)."
646,util/concurrent,com.google.common.util.concurrent,Class ClosingFuture.DeferredCloser,"An object that can capture objects to be closed later, when a ClosingFuture pipeline is done."
647,util/concurrent,com.google.common.util.concurrent,Class ClosingFuture.Peeker,An object that can return the value of the ClosingFutures that are passed to ClosingFuture.whenAllComplete(Iterable) or ClosingFuture.whenAllSucceed(Iterable). Only for use by a ClosingFuture.Combiner.CombiningCallable or ClosingFuture.Combiner.AsyncCombiningCallable object.
648,util/concurrent,com.google.common.util.concurrent,Class ClosingFuture.ValueAndCloser<V>,An object that holds the final result of an asynchronous ClosingFuture operation and allows the user to close all the closeable objects that were captured during it for later closing. The asynchronous operation will have completed before this object is created.
649,util/concurrent,com.google.common.util.concurrent,Interface ClosingFuture.ValueAndCloserConsumer<V>,Represents an operation that accepts a ClosingFuture.ValueAndCloser for the last step in a ClosingFuture pipeline.
650,common/collect,com.google.common.collect,Class Collections2,"Provides static methods for working with Collection instances. Java 8 users: several common uses for this class are now more comprehensively addressed by the new Stream library. Read the method documentation below for comparisons. These methods are not being deprecated, but we gently encourage you to migrate to streams."
651,common/collect,com.google.common.collect,Class Comparators,"Provides static methods for working with Comparator instances. For many other helpful comparator utilities, see either Comparator itself (for Java 8 or later), or com.google.common.collect.Ordering (otherwise). Relationship to OrderingIn light of the significant enhancements to Comparator in Java 8, the overwhelming majority of usages of Ordering can be written using only built-in JDK APIs. This class is intended to ""fill the gap"" and provide those features of Ordering not already provided by the JDK."
652,common/collect,com.google.common.collect,Class ComparisonChain,"A utility for performing a chained comparison statement. For example: public int compareTo(Foo that) { return ComparisonChain.start() .compare(this.aString, that.aString) .compare(this.anInt, that.anInt) .compare(this.anEnum, that.anEnum, Ordering.natural().nullsLast()) .result(); } The value of this expression will have the same sign as the first nonzero comparison result in the chain, or will be zero if every comparison result was zero. Note: ComparisonChain instances are immutable. For this utility to work correctly, calls must be chained as illustrated above. Performance note: Even though the ComparisonChain caller always invokes its compare methods unconditionally, the ComparisonChain implementation stops calling its inputs' compareTo and compare methods as soon as one of them returns a nonzero result. This optimization is typically important only in the presence of expensive compareTo and compare implementations. See the Guava User Guide article on ComparisonChain."
653,common/collect,com.google.common.collect,Class ComputationException,"Deprecated. This exception is no longer thrown by com.google.common. Previously, it was thrown by MapMaker computing maps. When support for computing maps was removed from MapMaker, it was added to CacheBuilder, which throws ExecutionException, UncheckedExecutionException, and ExecutionError. Any code that is still catching ComputationException may need to be updated to catch some of those types instead. (Note that this type, though deprecated, is not planned to be removed from Guava.)"
654,common/collect,com.google.common.collect,Class ConcurrentHashMultiset<E>,A multiset that supports concurrent modifications and that provides atomic versions of most Multiset operations (exceptions where noted). Null elements are not supported. See the Guava User Guide article on Multiset.
655,common/collect,com.google.common.collect,Class ContiguousSet<C extends Comparable>,"A sorted set of contiguous values in a given DiscreteDomain. Example: ContiguousSet.create(Range.closed(5, 42), DiscreteDomain.integers()) Note that because bounded ranges over int and long values are so common, this particular example can be written as just: ContiguousSet.closed(5, 42) Warning: Be extremely careful what you do with conceptually large instances (such as ContiguousSet.create(Range.greaterThan(0), DiscreteDomain.integers()). Certain operations on such a set can be performed efficiently, but others (such as Set.hashCode() or Collections.frequency(java.util.Collection<?>, java.lang.Object)) can cause major performance problems."
656,common/base,com.google.common.base,"Class Converter<A,B>","A function from A to B with an associated reverse function from B to A; used for converting back and forth between different representations of the same information. InvertibilityThe reverse operation may be a strict inverse (meaning that converter.reverse().convert(converter.convert(a)).equals(a) is always true). However, it is very common (perhaps more common) for round-trip conversion to be lossy. Consider an example round-trip using Doubles.stringConverter(): stringConverter().convert(""1.00"") returns the Double value 1.0stringConverter().reverse().convert(1.0) returns the string ""1.0"" -- not the same string (""1.00"") we started with Note that it should still be the case that the round-tripped and original objects are similar. NullabilityA converter always converts null to null and non-null references to non-null references. It would not make sense to consider null and a non-null reference to be ""different representations of the same information"", since one is distinguishable from missing information and the other is not. The convert(A) method handles this null behavior for all converters; implementations of doForward(A) and doBackward(B) are guaranteed to never be passed null, and must never return null. Common ways to useGetting a converter: Use a provided converter implementation, such as Enums.stringConverter(java.lang.Class<T>), Ints.stringConverter or the reverse views of these. Convert between specific preset values using Maps.asConverter. For example, use this to create a ""fake"" converter for a unit test. It is unnecessary (and confusing) to mock the Converter type using a mocking framework. Extend this class and implement its doForward(A) and doBackward(B) methods. Java 8 users: you may prefer to pass two lambda expressions or method references to the from factory method. Using a converter: Convert one instance in the ""forward"" direction using converter.convert(a). Convert multiple instances ""forward"" using converter.convertAll(as). Convert in the ""backward"" direction using converter.reverse().convert(b) or converter.reverse().convertAll(bs). Use converter or converter.reverse() anywhere a Function is accepted (for example Stream.map). Do not call doForward(A) or doBackward(B) directly; these exist only to be overridden. Example return new Converter<Integer, String>() { protected String doForward(Integer i) { return Integer.toHexString(i); } protected Integer doBackward(String s) { return parseUnsignedInt(s, 16); } };An alternative using Java 8: return Converter.from( Integer::toHexString, s -> parseUnsignedInt(s, 16));"
657,common/io,com.google.common.io,Class CountingInputStream,An InputStream that counts the number of bytes read.
658,common/io,com.google.common.io,Class CountingOutputStream,An OutputStream that counts the number of bytes written.
659,util/concurrent,com.google.common.util.concurrent,Class CycleDetectingLockFactory,"The CycleDetectingLockFactory creates ReentrantLock instances and ReentrantReadWriteLock instances that detect potential deadlock by checking for cycles in lock acquisition order. Potential deadlocks detected when calling the lock(), lockInterruptibly(), or tryLock() methods will result in the execution of the CycleDetectingLockFactory.Policy specified when creating the factory. The currently available policies are: DISABLED WARN THROW The locks created by a factory instance will detect lock acquisition cycles with locks created by other CycleDetectingLockFactory instances (except those with Policy.DISABLED). A lock's behavior when a cycle is detected, however, is defined by the Policy of the factory that created it. This allows detection of cycles across components while delegating control over lock behavior to individual components. Applications are encouraged to use a CycleDetectingLockFactory to create any locks for which external/unmanaged code is executed while the lock is held. (See caveats under Performance). Cycle DetectionDeadlocks can arise when locks are acquired in an order that forms a cycle. In a simple example involving two locks and two threads, deadlock occurs when one thread acquires Lock A, and then Lock B, while another thread acquires Lock B, and then Lock A: Thread1: acquire(LockA) --X acquire(LockB) Thread2: acquire(LockB) --X acquire(LockA) Neither thread will progress because each is waiting for the other. In more complex applications, cycles can arise from interactions among more than 2 locks: Thread1: acquire(LockA) --X acquire(LockB) Thread2: acquire(LockB) --X acquire(LockC) ... ThreadN: acquire(LockN) --X acquire(LockA) The implementation detects cycles by constructing a directed graph in which each lock represents a node and each edge represents an acquisition ordering between two locks. Each lock adds (and removes) itself to/from a ThreadLocal Set of acquired locks when the Thread acquires its first hold (and releases its last remaining hold). Before the lock is acquired, the lock is checked against the current set of acquired locks---to each of the acquired locks, an edge from the soon-to-be-acquired lock is either verified or created. If a new edge needs to be created, the outgoing edges of the acquired locks are traversed to check for a cycle that reaches the lock to be acquired. If no cycle is detected, a new ""safe"" edge is created. If a cycle is detected, an ""unsafe"" (cyclic) edge is created to represent a potential deadlock situation, and the appropriate Policy is executed. Note that detection of potential deadlock does not necessarily indicate that deadlock will happen, as it is possible that higher level application logic prevents the cyclic lock acquisition from occurring. One example of a false positive is: LockA -> LockB -> LockC LockA -> LockC -> LockB ReadWriteLocksWhile ReadWriteLock instances have different properties and can form cycles without potential deadlock, this class treats ReadWriteLock instances as equivalent to traditional exclusive locks. Although this increases the false positives that the locks detect (i.e. cycles that will not actually result in deadlock), it simplifies the algorithm and implementation considerably. The assumption is that a user of this factory wishes to eliminate any cyclic acquisition ordering. Explicit Lock Acquisition OrderingThe CycleDetectingLockFactory.WithExplicitOrdering class can be used to enforce an application-specific ordering in addition to performing general cycle detection. Garbage CollectionIn order to allow proper garbage collection of unused locks, the edges of the lock graph are weak references. PerformanceThe extra bookkeeping done by cycle detecting locks comes at some cost to performance. Benchmarks (as of December 2011) show that: for an unnested lock() and unlock(), a cycle detecting lock takes 38ns as opposed to the 24ns taken by a plain lock. for nested locking, the cost increases with the depth of the nesting: 2 levels: average of 64ns per lock()/unlock() 3 levels: average of 77ns per lock()/unlock() 4 levels: average of 99ns per lock()/unlock() 5 levels: average of 103ns per lock()/unlock() 10 levels: average of 184ns per lock()/unlock() 20 levels: average of 393ns per lock()/unlock() As such, the CycleDetectingLockFactory may not be suitable for performance-critical applications which involve tightly-looped or deeply-nested locking algorithms."
660,util/concurrent,com.google.common.util.concurrent,Enum CycleDetectingLockFactory.Policies,Pre-defined CycleDetectingLockFactory.Policy implementations.
661,util/concurrent,com.google.common.util.concurrent,Interface CycleDetectingLockFactory.Policy,Encapsulates the action to be taken when a potential deadlock is encountered. Clients can use one of the predefined CycleDetectingLockFactory.Policies or specify a custom implementation. Implementations must be thread-safe.
662,util/concurrent,com.google.common.util.concurrent,Class CycleDetectingLockFactory.PotentialDeadlockException,"Represents a detected cycle in lock acquisition ordering. The exception includes a causal chain of ExampleStackTrace instances to illustrate the cycle, e.g. com....PotentialDeadlockException: Potential Deadlock from LockC -> ReadWriteA at ... at ... Caused by: com...ExampleStackTrace: LockB -> LockC at ... at ... Caused by: com...ExampleStackTrace: ReadWriteA -> LockB at ... at ... Instances are logged for the Policies.WARN, and thrown for Policies.THROW."
663,util/concurrent,com.google.common.util.concurrent,Class CycleDetectingLockFactory.WithExplicitOrdering<E extends Enum<E>>,"A CycleDetectingLockFactory.WithExplicitOrdering provides the additional enforcement of an application-specified ordering of lock acquisitions. The application defines the allowed ordering with an Enum whose values each correspond to a lock type. The order in which the values are declared dictates the allowed order of lock acquisition. In other words, locks corresponding to smaller values of Enum.ordinal() should only be acquired before locks with larger ordinals. Example: enum MyLockOrder { FIRST, SECOND, THIRD; } CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory = CycleDetectingLockFactory.newInstanceWithExplicitOrdering(Policies.THROW); Lock lock1 = factory.newReentrantLock(MyLockOrder.FIRST); Lock lock2 = factory.newReentrantLock(MyLockOrder.SECOND); Lock lock3 = factory.newReentrantLock(MyLockOrder.THIRD); lock1.lock(); lock3.lock(); lock2.lock(); // will throw an IllegalStateException As with all locks created by instances of CycleDetectingLockFactory explicitly ordered locks participate in general cycle detection with all other cycle detecting locks, and a lock's behavior when detecting a cyclic lock acquisition is defined by the Policy of the factory that created it. Note, however, that although multiple locks can be created for a given Enum value, whether it be through separate factory instances or through multiple calls to the same factory, attempting to acquire multiple locks with the same Enum value (within the same thread) will result in an IllegalStateException regardless of the factory's policy. For example: CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory1 = CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...); CycleDetectingLockFactory.WithExplicitOrdering<MyLockOrder> factory2 = CycleDetectingLockFactory.newInstanceWithExplicitOrdering(...); Lock lockA = factory1.newReentrantLock(MyLockOrder.FIRST); Lock lockB = factory1.newReentrantLock(MyLockOrder.FIRST); Lock lockC = factory2.newReentrantLock(MyLockOrder.FIRST); lockA.lock(); lockB.lock(); // will throw an IllegalStateException lockC.lock(); // will throw an IllegalStateException lockA.lock(); // reentrant acquisition is okay It is the responsibility of the application to ensure that multiple lock instances with the same rank are never acquired in the same thread."
664,common/eventbus,com.google.common.eventbus,Class DeadEvent,"Wraps an event that was posted, but which had no subscribers and thus could not be delivered. Registering a DeadEvent subscriber is useful for debugging or logging, as it can detect misconfigurations in a system's event distribution."
665,common/base,com.google.common.base,Class Defaults,"This class provides default values for all Java types, as defined by the JLS."
666,common/collect,com.google.common.collect,Class DiscreteDomain<C extends Comparable>,"A descriptor for a discrete Comparable domain such as all Integer instances. A discrete domain is one that supports the three basic operations: next(C), previous(C) and distance(C, C), according to their specifications. The methods minValue() and maxValue() should also be overridden for bounded types. A discrete domain always represents the entire set of values of its type; it cannot represent partial domains such as ""prime integers"" or ""strings of length 5."" See the Guava User Guide section on DiscreteDomain."
667,common/math,com.google.common.math,Class DoubleMath,A class for arithmetic on doubles that is not covered by Math.
668,common/primitives,com.google.common.primitives,Class Doubles,"Static utility methods pertaining to double primitives, that are not already found in either Double or Arrays. See the Guava User Guide article on primitive utilities."
669,common/graph,com.google.common.graph,Class ElementOrder<T>,Used to represent the order of elements in a data structure that supports different options for iteration order guarantees. Example usage: MutableGraph<Integer> graph = GraphBuilder.directed().nodeOrder(ElementOrder.<Integer>natural()).build();
670,common/graph,com.google.common.graph,Enum ElementOrder.Type,The type of ordering that this object specifies. UNORDERED: no order is guaranteed. STABLE: ordering is guaranteed to follow a pattern that won't change between releases. Some methods may have stronger guarantees. INSERTION: insertion ordering is guaranteed. SORTED: ordering according to a supplied comparator is guaranteed.
671,common/graph,com.google.common.graph,Class EndpointPair<N>,"An immutable pair representing the two endpoints of an edge in a graph. The EndpointPair of a directed edge is an ordered pair of nodes (source() and target()). The EndpointPair of an undirected edge is an unordered pair of nodes (nodeU() and nodeV()). The edge is a self-loop if, and only if, the two endpoints are equal."
672,common/collect,com.google.common.collect,"Class EnumBiMap<K extends Enum<K>,V extends Enum<V>>",A BiMap backed by two EnumMap instances. Null keys and values are not permitted. An EnumBiMap and its inverse are both serializable. See the Guava User Guide article on BiMap.
673,common/collect,com.google.common.collect,"Class EnumHashBiMap<K extends Enum<K>,V>","A BiMap backed by an EnumMap instance for keys-to-values, and a HashMap instance for values-to-keys. Null keys are not permitted, but null values are. An EnumHashBiMap and its inverse are both serializable. See the Guava User Guide article on BiMap."
674,common/collect,com.google.common.collect,Class EnumMultiset<E extends Enum<E>>,"Multiset implementation specialized for enum elements, supporting all single-element operations in O(1). See the Guava User Guide article on Multiset."
675,common/base,com.google.common.base,Class Enums,Utility methods for working with Enum instances.
676,common/base,com.google.common.base,Class Equivalence<T>,"A strategy for determining whether two instances are considered equivalent, and for computing hash codes in a manner consistent with that equivalence. Two examples of equivalences are the identity equivalence and the ""equals"" equivalence."
677,common/base,com.google.common.base,Class Equivalence.Wrapper<T>,"Wraps an object so that equals(Object) and hashCode() delegate to an Equivalence. For example, given an Equivalence for strings named equiv that tests equivalence using their lengths: equiv.wrap(""a"").equals(equiv.wrap(""b"")) // true equiv.wrap(""a"").equals(equiv.wrap(""hello"")) // false Note in particular that an equivalence wrapper is never equal to the object it wraps. equiv.wrap(obj).equals(obj) // always false"
678,common/escape,com.google.common.escape,Class Escaper,"An object that converts literal text into a format safe for inclusion in a particular context (such as an XML document). Typically (but not always), the inverse process of ""unescaping"" the text is performed automatically by the relevant parser. For example, an XML escaper would convert the literal string ""Foo<Bar>"" into ""Foo&lt;Bar&gt;"" to prevent ""<Bar>"" from being confused with an XML tag. When the resulting XML document is parsed, the parser API will return this text as the original literal string ""Foo<Bar>"". An Escaper instance is required to be stateless, and safe when used concurrently by multiple threads. Because, in general, escaping operates on the code points of a string and not on its individual char values, it is not safe to assume that escape(s) is equivalent to escape(s.substring(0, n)) + escape(s.substring(n)) for arbitrary n. This is because of the possibility of splitting a surrogate pair. The only case in which it is safe to escape strings and concatenate the results is if you can rule out this possibility, either by splitting an existing long string into short strings adaptively around surrogate pairs, or by starting with short strings already known to be free of unpaired surrogates. The two primary implementations of this interface are CharEscaper and UnicodeEscaper. They are heavily optimized for performance and greatly simplify the task of implementing new escapers. It is strongly recommended that when implementing a new escaper you extend one of these classes. If you find that you are unable to achieve the desired behavior using either of these classes, please contact the Java libraries team for advice. Popular escapers are defined as constants in classes like HtmlEscapers and XmlEscapers. To create your own escapers, use CharEscaperBuilder, or extend CharEscaper or UnicodeEscaper."
679,common/escape,com.google.common.escape,Class Escapers,Static utility methods pertaining to Escaper instances.
680,common/escape,com.google.common.escape,Class Escapers.Builder,"A builder for simple, fast escapers. Typically an escaper needs to deal with the escaping of high valued characters or code points. In these cases it is necessary to extend either ArrayBasedCharEscaper or ArrayBasedUnicodeEscaper to provide the desired behavior. However this builder is suitable for creating escapers that replace a relative small set of characters."
681,common/eventbus,com.google.common.eventbus,Class EventBus,"Dispatches events to listeners, and provides ways for listeners to register themselves. The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-process event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication. Receiving EventsTo receive events, an object should: Expose a public method, known as the event subscriber, which accepts a single argument of the type of event desired; Mark it with a Subscribe annotation; Pass itself to an EventBus instance's register(Object) method. Posting EventsTo post an event, simply provide the event object to the post(Object) method. The EventBus instance will determine the type of event and route it to all registered listeners. Events are routed based on their type — an event will be delivered to any subscriber for any type to which the event is assignable. This includes implemented interfaces, all superclasses, and all interfaces implemented by superclasses. When post is called, all registered subscribers for an event are run in sequence, so subscribers should be reasonably quick. If an event may trigger an extended process (such as a database load), spawn a thread or queue it for later. (For a convenient way to do this, use an AsyncEventBus.) Subscriber MethodsEvent subscriber methods must accept only one argument: the event. Subscribers should not, in general, throw. If they do, the EventBus will catch and log the exception. This is rarely the right solution for error handling and should not be relied upon; it is intended solely to help find problems during development. The EventBus guarantees that it will not call a subscriber method from multiple threads simultaneously, unless the method explicitly allows it by bearing the AllowConcurrentEvents annotation. If this annotation is not present, subscriber methods need not worry about being reentrant, unless also called from outside the EventBus. Dead EventsIf an event is posted, but no registered subscribers can accept it, it is considered ""dead."" To give the system a second chance to handle dead events, they are wrapped in an instance of DeadEvent and reposted. If a subscriber for a supertype of all events (such as Object) is registered, no event will ever be considered dead, and no DeadEvents will be generated. Accordingly, while DeadEvent extends Object, a subscriber registered to receive any Object will never receive a DeadEvent. This class is safe for concurrent use. See the Guava User Guide article on EventBus."
682,common/collect,com.google.common.collect,Class EvictingQueue<E>,"A non-blocking queue which automatically evicts elements from the head of the queue when attempting to add new elements onto the queue and it is full. This queue orders elements FIFO (first-in-first-out). This data structure is logically equivalent to a circular buffer (i.e., cyclic buffer or ring buffer). An evicting queue must be configured with a maximum size. Each time an element is added to a full queue, the queue automatically removes its head element. This is different from conventional bounded queues, which either block or reject new elements when full. This class is not thread-safe, and does not accept null elements."
683,util/concurrent,com.google.common.util.concurrent,Class ExecutionError,"Error variant of ExecutionException. As with ExecutionException, the error's cause comes from a failed task, possibly run in another thread. That cause should itself be an Error; if not, use ExecutionException or UncheckedExecutionException. This allows the client code to continue to distinguish between exceptions and errors, even when they come from other threads."
684,util/concurrent,com.google.common.util.concurrent,Class ExecutionList,"A support class for ListenableFuture implementations to manage their listeners. An instance contains a list of listeners, each with an associated Executor, and guarantees that every Runnable that is added will be executed after execute() is called. Any Runnable added after the call to execute is still guaranteed to execute. There is no guarantee, however, that listeners will be executed in the order that they are added. Exceptions thrown by a listener will be propagated up to the executor. Any exception thrown during Executor.execute (e.g., a RejectedExecutionException or an exception thrown by direct execution) will be caught and logged."
685,util/concurrent,com.google.common.util.concurrent,Class ExecutionSequencer,"Serializes execution of tasks, somewhat like an ""asynchronous synchronized block."" Each enqueued callable will not be submitted to its associated executor until the previous callable has returned -- and, if the previous callable was an AsyncCallable, not until the Future it returned is done (successful, failed, or cancelled). This class has limited support for cancellation and other ""early completion"": While calls to submit and submitAsync return a Future that can be cancelled, cancellation never propagates to a task that has started to run -- neither to the callable itself nor to any Future returned by an AsyncCallable. (However, cancellation can prevent an unstarted task from running.) Therefore, the next task will wait for any running callable (or pending Future returned by an AsyncCallable) to complete, without interrupting it (and without calling cancel on the Future). So beware: Even if you cancel every precededing Future returned by this class, the next task may still have to wait.. Once an AsyncCallable returns a Future, this class considers that task to be ""done"" as soon as that Future completes in any way. Notably, a Future is ""completed"" even if it is cancelled while its underlying work continues on a thread, an RPC, etc. The Future is also ""completed"" if it fails ""early"" -- for example, if the deadline expires on a Future returned from Futures.withTimeout(com.google.common.util.concurrent.ListenableFuture<V>, java.time.Duration, java.util.concurrent.ScheduledExecutorService) while the Future it wraps continues its underlying work. So beware: Your AsyncCallable should not complete its Future until it is safe for the next task to start.An additional limitation: this class serializes execution of tasks but not any listeners of those tasks. This class is similar to MoreExecutors.newSequentialExecutor(java.util.concurrent.Executor). This class is different in a few ways: Each task may be associated with a different executor. Tasks may be of type AsyncCallable. Running tasks cannot be interrupted. (Note that newSequentialExecutor does not return Future objects, so it doesn't support interruption directly, either. However, utilities that use that executor have the ability to interrupt tasks running on it. This class, by contrast, does not expose an Executor API.) If you don't need the features of this class, you may prefer newSequentialExecutor for its simplicity and ability to accommodate interruption."
686,util/concurrent,com.google.common.util.concurrent,Class FakeTimeLimiter,"A TimeLimiter implementation which actually does not attempt to limit time at all. This may be desirable to use in some unit tests. More importantly, attempting to debug a call which is time-limited would be extremely annoying, so this gives you a time-limiter you can easily swap in for your real time-limiter while you're debugging."
687,common/io,com.google.common.io,Class FileBackedOutputStream,"An OutputStream that starts buffering to a byte array, but switches to file buffering once the data reaches a configurable size. Temporary files created by this stream may live in the local filesystem until either: reset() is called (removing the data in this stream and deleting the file), or... this stream (or, more precisely, its asByteSource() view) is finalized during garbage collection, AND this stream was not constructed with the 1-arg constructor or the 2-arg constructor passing false in the second parameter. This class is thread-safe."
688,common/io,com.google.common.io,Class Files,Provides utility methods for working with files. Path users will find similar utilities in MoreFiles and the JDK's Files class.
689,common/io,com.google.common.io,Enum FileWriteMode,Modes for opening a file for writing. The default when mode when none is specified is to truncate the file before writing.
690,common/base,com.google.common.base,Class FinalizablePhantomReference<T>,"Phantom reference with a finalizeReferent() method which a background thread invokes after the garbage collector reclaims the referent. This is a simpler alternative to using a ReferenceQueue. Unlike a normal phantom reference, this reference will be cleared automatically."
691,common/base,com.google.common.base,Interface FinalizableReference,Implemented by references that have code to run after garbage collection of their referents.
692,common/base,com.google.common.base,Class FinalizableReferenceQueue,"A reference queue with an associated background thread that dequeues references and invokes FinalizableReference.finalizeReferent() on them. Keep a strong reference to this object until all of the associated referents have been finalized. If this object is garbage collected earlier, the backing thread will not invoke finalizeReferent() on the remaining references. As an example of how this is used, imagine you have a class MyServer that creates a a ServerSocket, and you would like to ensure that the ServerSocket is closed even if the MyServer object is garbage-collected without calling its close method. You could use a finalizer to accomplish this, but that has a number of well-known problems. Here is how you might use this class instead: public class MyServer implements Closeable { private static final FinalizableReferenceQueue frq = new FinalizableReferenceQueue(); // You might also share this between several objects. private static final Set<Reference<?>> references = Sets.newConcurrentHashSet(); // This ensures that the FinalizablePhantomReference itself is not garbage-collected. private final ServerSocket serverSocket; private MyServer(...) { ... this.serverSocket = new ServerSocket(...); ... } public static MyServer create(...) { MyServer myServer = new MyServer(...); final ServerSocket serverSocket = myServer.serverSocket; Reference<?> reference = new FinalizablePhantomReference<MyServer>(myServer, frq) { public void finalizeReferent() { references.remove(this): if (!serverSocket.isClosed()) { ...log a message about how nobody called close()... try { serverSocket.close(); } catch (IOException e) { ... } } } }; references.add(reference); return myServer; } public void close() { serverSocket.close(); } }"
693,common/base,com.google.common.base,Class FinalizableSoftReference<T>,Soft reference with a finalizeReferent() method which a background thread invokes after the garbage collector reclaims the referent. This is a simpler alternative to using a ReferenceQueue.
694,common/base,com.google.common.base,Class FinalizableWeakReference<T>,Weak reference with a finalizeReferent() method which a background thread invokes after the garbage collector reclaims the referent. This is a simpler alternative to using a ReferenceQueue.
695,common/primitives,com.google.common.primitives,Class Floats,"Static utility methods pertaining to float primitives, that are not already found in either Float or Arrays. See the Guava User Guide article on primitive utilities."
696,util/concurrent,com.google.common.util.concurrent,Class FluentFuture<V>,"A ListenableFuture that supports fluent chains of operations. For example: ListenableFuture<Boolean> adminIsLoggedIn = FluentFuture.from(usersDatabase.getAdminUser()) .transform(User::getId, directExecutor()) .transform(ActivityService::isLoggedIn, threadPool) .catching(RpcException.class, e -> false, directExecutor()); AlternativesFrameworksWhen chaining together a graph of asynchronous operations, you will often find it easier to use a framework. Frameworks automate the process, often adding features like monitoring, debugging, and cancellation. Examples of frameworks include: Dagger ProducersCompletableFuture / CompletionStageUsers of CompletableFuture will likely want to continue using CompletableFuture. FluentFuture is targeted at people who use ListenableFuture, who can't use Java 8, or who want an API more focused than CompletableFuture. (If you need to adapt between CompletableFuture and ListenableFuture, consider Future Converter.) Extension If you want a class like FluentFuture but with extra methods, we recommend declaring your own subclass of ListenableFuture, complete with a method like from(com.google.common.util.concurrent.ListenableFuture<V>) to adapt an existing ListenableFuture, implemented atop a ForwardingListenableFuture that forwards to that future and adds the desired methods."
697,common/collect,com.google.common.collect,Class FluentIterable<E>,"A discouraged (but not deprecated) precursor to Java's superior Stream library. The following types of methods are provided: chaining methods which return a new FluentIterable based in some way on the contents of the current one (for example transform(com.google.common.base.Function<? super E, T>)) element extraction methods which facilitate the retrieval of certain elements (for example last()) query methods which answer questions about the FluentIterable's contents (for example anyMatch(com.google.common.base.Predicate<? super E>)) conversion methods which copy the FluentIterable's contents into a new collection or array (for example toList()) Several lesser-used features are currently available only as static methods on the Iterables class. Comparison to streamsStream is similar to this class, but generally more powerful, and certainly more standard. Key differences include: A stream is single-use; it becomes invalid as soon as any ""terminal operation"" such as findFirst() or iterator() is invoked. (Even though Stream contains all the right method signatures to implement Iterable, it does not actually do so, to avoid implying repeat-iterability.) FluentIterable, on the other hand, is multiple-use, and does implement Iterable. Streams offer many features not found here, including min/max, distinct, reduce, sorted, the very powerful collect, and built-in support for parallelizing stream operations. FluentIterable contains several features not available on Stream, which are noted in the method descriptions below. Streams include primitive-specialized variants such as IntStream, the use of which is strongly recommended. Streams are standard Java, not requiring a third-party dependency. ExampleHere is an example that accepts a list from a database call, filters it based on a predicate, transforms it by invoking toString() on each element, and returns the first 10 elements as a List: ImmutableList<String> results = FluentIterable.from(database.getClientList()) .filter(Client::isActiveInLastMonth) .transform(Object::toString) .limit(10) .toList(); The approximate stream equivalent is: List<String> results = database.getClientList() .stream() .filter(Client::isActiveInLastMonth) .map(Object::toString) .limit(10) .collect(Collectors.toList());"
698,common/io,com.google.common.io,Class Flushables,Utility methods for working with Flushable objects.
699,common/collect,com.google.common.collect,Class ForwardingBlockingDeque<E>,Deprecated. This class has moved to com.google.common.util.concurrent. Please use ForwardingBlockingDeque instead.
700,util/concurrent,com.google.common.util.concurrent,Class ForwardingBlockingDeque<E>,"A BlockingDeque which forwards all its method calls to another BlockingDeque. Subclasses should override one or more methods to modify the behavior of the backing deque as desired per the decorator pattern. Warning: The methods of ForwardingBlockingDeque forward indiscriminately to the methods of the delegate. For example, overriding ForwardingCollection.add(E) alone will not change the behaviour of offer(E, long, java.util.concurrent.TimeUnit) which can lead to unexpected behaviour. In this case, you should override offer as well, either providing your own implementation, or delegating to the provided standardOffer method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingBlockingDeque. The standard methods are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
701,util/concurrent,com.google.common.util.concurrent,Class ForwardingBlockingQueue<E>,"A BlockingQueue which forwards all its method calls to another BlockingQueue. Subclasses should override one or more methods to modify the behavior of the backing collection as desired per the decorator pattern. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingBlockingQueue."
702,common/cache,com.google.common.cache,"Class ForwardingCache<K,V>",A cache which forwards all its method calls to another cache. Subclasses should override one or more methods to modify the behavior of the backing cache as desired per the decorator pattern.
703,common/cache,com.google.common.cache,"Class ForwardingCache.SimpleForwardingCache<K,V>",A simplified version of ForwardingCache where subclasses can pass in an already constructed Cache as the delegate.
704,common/collect,com.google.common.collect,Class ForwardingCollection<E>,"A collection which forwards all its method calls to another collection. Subclasses should override one or more methods to modify the behavior of the backing collection as desired per the decorator pattern. Warning: The methods of ForwardingCollection forward indiscriminately to the methods of the delegate. For example, overriding add(E) alone will not change the behavior of addAll(java.util.Collection<? extends E>), which can lead to unexpected behavior. In this case, you should override addAll as well, either providing your own implementation, or delegating to the provided standardAddAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingCollection. The standard methods are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
705,common/collect,com.google.common.collect,"Class ForwardingConcurrentMap<K,V>","A concurrent map which forwards all its method calls to another concurrent map. Subclasses should override one or more methods to modify the behavior of the backing map as desired per the decorator pattern. default method warning: This class forwards calls to only some default methods. Specifically, it forwards calls only for methods that existed before default methods were introduced. For newer methods, like forEach, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingConcurrentMap."
706,common/collect,com.google.common.collect,Class ForwardingDeque<E>,"A deque which forwards all its method calls to another deque. Subclasses should override one or more methods to modify the behavior of the backing deque as desired per the decorator pattern. Warning: The methods of ForwardingDeque forward indiscriminately to the methods of the delegate. For example, overriding ForwardingCollection.add(E) alone will not change the behavior of ForwardingQueue.offer(E) which can lead to unexpected behavior. In this case, you should override offer as well. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingDeque."
707,util/concurrent,com.google.common.util.concurrent,Class ForwardingExecutorService,An executor service which forwards all its method calls to another executor service. Subclasses should override one or more methods to modify the behavior of the backing executor service as desired per the decorator pattern.
708,util/concurrent,com.google.common.util.concurrent,Class ForwardingFuture<V>,A Future which forwards all its method calls to another future. Subclasses should override one or more methods to modify the behavior of the backing future as desired per the decorator pattern. Most subclasses can just use ForwardingFuture.SimpleForwardingFuture.
709,util/concurrent,com.google.common.util.concurrent,Class ForwardingFuture.SimpleForwardingFuture<V>,A simplified version of ForwardingFuture where subclasses can pass in an already constructed Future as the delegate.
710,common/collect,com.google.common.collect,Class ForwardingIterator<T>,"An iterator which forwards all its method calls to another iterator. Subclasses should override one or more methods to modify the behavior of the backing iterator as desired per the decorator pattern. default method warning: This class forwards calls to only some default methods. Specifically, it forwards calls only for methods that existed before default methods were introduced. For newer methods, like forEachRemaining, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingIterator."
711,common/collect,com.google.common.collect,Class ForwardingList<E>,"A list which forwards all its method calls to another list. Subclasses should override one or more methods to modify the behavior of the backing list as desired per the decorator pattern. This class does not implement RandomAccess. If the delegate supports random access, the ForwardingList subclass should implement the RandomAccess interface. Warning: The methods of ForwardingList forward indiscriminately to the methods of the delegate. For example, overriding add(int, E) alone will not change the behavior of addAll(int, java.util.Collection<? extends E>), which can lead to unexpected behavior. In this case, you should override addAll as well, either providing your own implementation, or delegating to the provided standardAddAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingList. The standard methods and any collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
712,util/concurrent,com.google.common.util.concurrent,Class ForwardingListenableFuture<V>,A ListenableFuture which forwards all its method calls to another future. Subclasses should override one or more methods to modify the behavior of the backing future as desired per the decorator pattern. Most subclasses can just use ForwardingListenableFuture.SimpleForwardingListenableFuture.
713,util/concurrent,com.google.common.util.concurrent,Class ForwardingListenableFuture.SimpleForwardingListenableFuture<V>,A simplified version of ForwardingListenableFuture where subclasses can pass in an already constructed ListenableFuture as the delegate.
714,util/concurrent,com.google.common.util.concurrent,Class ForwardingListeningExecutorService,A listening executor service which forwards all its method calls to another listening executor service. Subclasses should override one or more methods to modify the behavior of the backing executor service as desired per the decorator pattern.
715,common/collect,com.google.common.collect,Class ForwardingListIterator<E>,"A list iterator which forwards all its method calls to another list iterator. Subclasses should override one or more methods to modify the behavior of the backing iterator as desired per the decorator pattern. default method warning: This class forwards calls to only some default methods. Specifically, it forwards calls only for methods that existed before default methods were introduced. For newer methods, like forEachRemaining, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingListIterator."
716,common/collect,com.google.common.collect,"Class ForwardingListMultimap<K,V>","A list multimap which forwards all its method calls to another list multimap. Subclasses should override one or more methods to modify the behavior of the backing multimap as desired per the decorator pattern. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingListMultimap."
717,common/cache,com.google.common.cache,"Class ForwardingLoadingCache<K,V>","A cache which forwards all its method calls to another cache. Subclasses should override one or more methods to modify the behavior of the backing cache as desired per the decorator pattern. Note that get(K), getUnchecked(K), and apply(K) all expose the same underlying functionality, so should probably be overridden as a group."
718,common/cache,com.google.common.cache,"Class ForwardingLoadingCache.SimpleForwardingLoadingCache<K,V>",A simplified version of ForwardingLoadingCache where subclasses can pass in an already constructed LoadingCache as the delegate.
719,common/collect,com.google.common.collect,"Class ForwardingMap<K,V>","A map which forwards all its method calls to another map. Subclasses should override one or more methods to modify the behavior of the backing map as desired per the decorator pattern. Warning: The methods of ForwardingMap forward indiscriminately to the methods of the delegate. For example, overriding put(K, V) alone will not change the behavior of putAll(java.util.Map<? extends K, ? extends V>), which can lead to unexpected behavior. In this case, you should override putAll as well, either providing your own implementation, or delegating to the provided standardPutAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingMap. Each of the standard methods, where appropriate, use Objects.equal(java.lang.Object, java.lang.Object) to test equality for both keys and values. This may not be the desired behavior for map implementations that use non-standard notions of key equality, such as a SortedMap whose comparator is not consistent with equals. The standard methods and the collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
720,common/collect,com.google.common.collect,"Class ForwardingMapEntry<K,V>","A map entry which forwards all its method calls to another map entry. Subclasses should override one or more methods to modify the behavior of the backing map entry as desired per the decorator pattern. Warning: The methods of ForwardingMapEntry forward indiscriminately to the methods of the delegate. For example, overriding getValue() alone will not change the behavior of equals(java.lang.Object), which can lead to unexpected behavior. In this case, you should override equals as well, either providing your own implementation, or delegating to the provided standardEquals method. Each of the standard methods, where appropriate, use Objects.equal(java.lang.Object, java.lang.Object) to test equality for both keys and values. This may not be the desired behavior for map implementations that use non-standard notions of key equality, such as the entry of a SortedMap whose comparator is not consistent with equals. The standard methods are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
721,common/collect,com.google.common.collect,"Class ForwardingMultimap<K,V>","A multimap which forwards all its method calls to another multimap. Subclasses should override one or more methods to modify the behavior of the backing multimap as desired per the decorator pattern. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingMultimap."
722,common/collect,com.google.common.collect,Class ForwardingMultiset<E>,"A multiset which forwards all its method calls to another multiset. Subclasses should override one or more methods to modify the behavior of the backing multiset as desired per the decorator pattern. Warning: The methods of ForwardingMultiset forward indiscriminately to the methods of the delegate. For example, overriding add(Object, int) alone will not change the behavior of ForwardingCollection.add(Object), which can lead to unexpected behavior. In this case, you should override add(Object) as well, either providing your own implementation, or delegating to the provided standardAdd method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingMultiset. The standard methods and any collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
723,common/collect,com.google.common.collect,"Class ForwardingNavigableMap<K,V>","A navigable map which forwards all its method calls to another navigable map. Subclasses should override one or more methods to modify the behavior of the backing map as desired per the decorator pattern. Warning: The methods of ForwardingNavigableMap forward indiscriminately to the methods of the delegate. For example, overriding ForwardingMap.put(K, V) alone will not change the behavior of ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>), which can lead to unexpected behavior. In this case, you should override putAll as well, either providing your own implementation, or delegating to the provided standardPutAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingNavigableMap. Each of the standard methods uses the map's comparator (or the natural ordering of the elements, if there is no comparator) to test element equality. As a result, if the comparator is not consistent with equals, some of the standard implementations may violate the Map contract. The standard methods and the collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
724,common/collect,com.google.common.collect,Class ForwardingNavigableSet<E>,"A navigable set which forwards all its method calls to another navigable set. Subclasses should override one or more methods to modify the behavior of the backing set as desired per the decorator pattern. Warning: The methods of ForwardingNavigableSet forward indiscriminately to the methods of the delegate. For example, overriding ForwardingCollection.add(E) alone will not change the behavior of ForwardingCollection.addAll(java.util.Collection<? extends E>), which can lead to unexpected behavior. In this case, you should override addAll as well, either providing your own implementation, or delegating to the provided standardAddAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingNavigableSet. Each of the standard methods uses the set's comparator (or the natural ordering of the elements, if there is no comparator) to test element equality. As a result, if the comparator is not consistent with equals, some of the standard implementations may violate the Set contract. The standard methods and the collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
725,common/collect,com.google.common.collect,Class ForwardingObject,"An abstract base class for implementing the decorator pattern. The delegate() method must be overridden to return the instance being decorated. This class does not forward the hashCode and equals methods through to the backing object, but relies on Object's implementation. This is necessary to preserve the symmetry of equals. Custom definitions of equality are usually based on an interface, such as Set or List, so that the implementation of equals can cast the object being tested for equality to the custom interface. ForwardingObject implements no such custom interfaces directly; they are implemented only in subclasses. Therefore, forwarding equals would break symmetry, as the forwarding object might consider itself equal to the object being tested, but the reverse could not be true. This behavior is consistent with the JDK's collection wrappers, such as Collections.unmodifiableCollection(java.util.Collection<? extends T>). Use an interface-specific subclass of ForwardingObject, such as ForwardingList, to preserve equality behavior, or override equals directly. The toString method is forwarded to the delegate. Although this class does not implement Serializable, a serializable subclass may be created since this class has a parameter-less constructor."
726,common/collect,com.google.common.collect,Class ForwardingQueue<E>,"A queue which forwards all its method calls to another queue. Subclasses should override one or more methods to modify the behavior of the backing queue as desired per the decorator pattern. Warning: The methods of ForwardingQueue forward indiscriminately to the methods of the delegate. For example, overriding ForwardingCollection.add(E) alone will not change the behavior of offer(E) which can lead to unexpected behavior. In this case, you should override offer as well, either providing your own implementation, or delegating to the provided standardOffer method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingQueue. The standard methods are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
727,common/collect,com.google.common.collect,Class ForwardingSet<E>,"A set which forwards all its method calls to another set. Subclasses should override one or more methods to modify the behavior of the backing set as desired per the decorator pattern. Warning: The methods of ForwardingSet forward indiscriminately to the methods of the delegate. For example, overriding ForwardingCollection.add(E) alone will not change the behavior of ForwardingCollection.addAll(java.util.Collection<? extends E>), which can lead to unexpected behavior. In this case, you should override addAll as well, either providing your own implementation, or delegating to the provided standardAddAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingSet. The standard methods are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
728,common/collect,com.google.common.collect,"Class ForwardingSetMultimap<K,V>","A set multimap which forwards all its method calls to another set multimap. Subclasses should override one or more methods to modify the behavior of the backing multimap as desired per the decorator pattern. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingSetMultimap."
729,common/collect,com.google.common.collect,"Class ForwardingSortedMap<K,V>","A sorted map which forwards all its method calls to another sorted map. Subclasses should override one or more methods to modify the behavior of the backing sorted map as desired per the decorator pattern. Warning: The methods of ForwardingSortedMap forward indiscriminately to the methods of the delegate. For example, overriding ForwardingMap.put(K, V) alone will not change the behavior of ForwardingMap.putAll(java.util.Map<? extends K, ? extends V>), which can lead to unexpected behavior. In this case, you should override putAll as well, either providing your own implementation, or delegating to the provided standardPutAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingSortedMap. Each of the standard methods, where appropriate, use the comparator of the map to test equality for both keys and values, unlike ForwardingMap. The standard methods and the collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
730,common/collect,com.google.common.collect,Class ForwardingSortedMultiset<E>,"A sorted multiset which forwards all its method calls to another sorted multiset. Subclasses should override one or more methods to modify the behavior of the backing multiset as desired per the decorator pattern. Warning: The methods of ForwardingSortedMultiset forward indiscriminately to the methods of the delegate. For example, overriding ForwardingMultiset.add(Object, int) alone will not change the behavior of ForwardingCollection.add(Object), which can lead to unexpected behavior. In this case, you should override add(Object) as well, either providing your own implementation, or delegating to the provided standardAdd method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingSortedMultiset. The standard methods and any collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
731,common/collect,com.google.common.collect,Class ForwardingSortedSet<E>,"A sorted set which forwards all its method calls to another sorted set. Subclasses should override one or more methods to modify the behavior of the backing sorted set as desired per the decorator pattern. Warning: The methods of ForwardingSortedSet forward indiscriminately to the methods of the delegate. For example, overriding ForwardingCollection.add(E) alone will not change the behavior of ForwardingCollection.addAll(java.util.Collection<? extends E>), which can lead to unexpected behavior. In this case, you should override addAll as well, either providing your own implementation, or delegating to the provided standardAddAll method. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingSortedSet. Each of the standard methods, where appropriate, uses the set's comparator (or the natural ordering of the elements, if there is no comparator) to test element equality. As a result, if the comparator is not consistent with equals, some of the standard implementations may violate the Set contract. The standard methods and the collection views they return are not guaranteed to be thread-safe, even when all of the methods that they depend on are thread-safe."
732,common/collect,com.google.common.collect,"Class ForwardingSortedSetMultimap<K,V>","A sorted set multimap which forwards all its method calls to another sorted set multimap. Subclasses should override one or more methods to modify the behavior of the backing multimap as desired per the decorator pattern. default method warning: This class does not forward calls to default methods. Instead, it inherits their default implementations. When those implementations invoke methods, they invoke methods on the ForwardingSortedSetMultimap."
733,common/collect,com.google.common.collect,"Class ForwardingTable<R,C,V>",A table which forwards all its method calls to another table. Subclasses should override one or more methods to modify the behavior of the backing map as desired per the decorator pattern.
734,common/base,com.google.common.base,"Interface Function<F,T>","Legacy version of java.util.function.Function. The Functions class provides common functions and related utilities. As this interface extends java.util.function.Function, an instance of this type can be used as a java.util.function.Function directly. To use a java.util.function.Function in a context where a com.google.common.base.Function is needed, use function::apply. This interface is now a legacy type. Use java.util.function.Function (or the appropriate primitive specialization such as ToIntFunction) instead whenever possible. Otherwise, at least reduce explicit dependencies on this type by using lambda expressions or method references instead of classes, leaving your code easier to migrate in the future. See the Guava User Guide article on the use of Function."
735,common/base,com.google.common.base,Class Functions,Static utility methods pertaining to com.google.common.base.Function instances; see that class for information about migrating to java.util.function. All methods return serializable functions as long as they're given serializable parameters. See the Guava User Guide article on the use of Function.
736,common/hash,com.google.common.hash,Interface Funnel<T>,"An object which can send data from an object of type T into a PrimitiveSink. Implementations for common types can be found in Funnels. Note that serialization of bloom filters requires the proper serialization of funnels. When possible, it is recommended that funnels be implemented as a single-element enum to maintain serialization guarantees. See Effective Java (2nd Edition), Item 3: ""Enforce the singleton property with a private constructor or an enum type"". For example: public enum PersonFunnel implements Funnel<Person> { INSTANCE; public void funnel(Person person, PrimitiveSink into) { into.putUnencodedChars(person.getFirstName()) .putUnencodedChars(person.getLastName()) .putInt(person.getAge()); } }"
737,common/hash,com.google.common.hash,Class Funnels,Funnels for common types. All implementations are serializable.
738,util/concurrent,com.google.common.util.concurrent,Interface FutureCallback<V>,"A callback for accepting the results of a Future computation asynchronously. To attach to a ListenableFuture use Futures.addCallback(com.google.common.util.concurrent.ListenableFuture<V>, com.google.common.util.concurrent.FutureCallback<? super V>, java.util.concurrent.Executor)."
739,util/concurrent,com.google.common.util.concurrent,Class Futures,"Static utility methods pertaining to the Future interface. Many of these methods use the ListenableFuture API; consult the Guava User Guide article on ListenableFuture. The main purpose of ListenableFuture is to help you chain together a graph of asynchronous operations. You can chain them together manually with calls to methods like Futures.transform, but you will often find it easier to use a framework. Frameworks automate the process, often adding features like monitoring, debugging, and cancellation. Examples of frameworks include: Dagger ProducersIf you do chain your operations manually, you may want to use FluentFuture."
740,util/concurrent,com.google.common.util.concurrent,Class Futures.FutureCombiner<V>,"A helper to create a new ListenableFuture whose result is generated from a combination of input futures. See Futures.whenAllComplete(com.google.common.util.concurrent.ListenableFuture<? extends V>...) and Futures.whenAllSucceed(com.google.common.util.concurrent.ListenableFuture<? extends V>...) for how to instantiate this class. Example: final ListenableFuture<Instant> loginDateFuture = loginService.findLastLoginDate(username); final ListenableFuture<List<String>> recentCommandsFuture = recentCommandsService.findRecentCommands(username); ListenableFuture<UsageHistory> usageFuture = Futures.whenAllSucceed(loginDateFuture, recentCommandsFuture) .call( () -> new UsageHistory( username, Futures.getDone(loginDateFuture), Futures.getDone(recentCommandsFuture)), executor);"
741,common/graph,com.google.common.graph,Interface Graph<N>,"An interface for graph-structured data, whose edges are anonymous entities with no identity or information of their own. A graph is composed of a set of nodes and a set of edges connecting pairs of nodes. There are three primary interfaces provided to represent graphs. In order of increasing complexity they are: Graph, ValueGraph, and Network. You should generally prefer the simplest interface that satisfies your use case. See the ""Choosing the right graph type"" section of the Guava User Guide for more details. CapabilitiesGraph supports the following use cases (definitions of terms): directed graphs undirected graphs graphs that do/don't allow self-loops graphs whose nodes/edges are insertion-ordered, sorted, or unordered Graph explicitly does not support parallel edges, and forbids implementations or extensions with parallel edges. If you need parallel edges, use Network. Building a GraphThe implementation classes that common.graph provides are not public, by design. To create an instance of one of the built-in implementations of Graph, use the GraphBuilder class: MutableGraph<Integer> graph = GraphBuilder.undirected().build(); GraphBuilder.build() returns an instance of MutableGraph, which is a subtype of Graph that provides methods for adding and removing nodes and edges. If you do not need to mutate a graph (e.g. if you write a method than runs a read-only algorithm on the graph), you should use the non-mutating Graph interface, or an ImmutableGraph. You can create an immutable copy of an existing Graph using ImmutableGraph.copyOf(Graph): ImmutableGraph<Integer> immutableGraph = ImmutableGraph.copyOf(graph); Instances of ImmutableGraph do not implement MutableGraph (obviously!) and are contractually guaranteed to be unmodifiable and thread-safe. The Guava User Guide has more information on (and examples of) building graphs. Additional documentationSee the Guava User Guide for the common.graph package (""Graphs Explained"") for additional documentation, including: equals(), hashCode(), and graph equivalence Synchronization policyNotes for implementors"
742,common/graph,com.google.common.graph,Class GraphBuilder<N>,"A builder for constructing instances of MutableGraph or ImmutableGraph with user-defined properties. A graph built by this class will have the following properties by default: does not allow self-loops orders Graph.nodes() in the order in which the elements were added Examples of use: // Building a mutable graph MutableGraph<String> graph = GraphBuilder.undirected().allowsSelfLoops(true).build(); graph.putEdge(""bread"", ""bread""); graph.putEdge(""chocolate"", ""peanut butter""); graph.putEdge(""peanut butter"", ""jelly""); // Building an immutable graph ImmutableGraph<String> immutableGraph = GraphBuilder.undirected() .allowsSelfLoops(true) .<String>immutable() .putEdge(""bread"", ""bread"") .putEdge(""chocolate"", ""peanut butter"") .putEdge(""peanut butter"", ""jelly"") .build();"
743,common/graph,com.google.common.graph,Class Graphs,"Static utility methods for Graph, ValueGraph, and Network instances."
744,common/annotations,com.google.common.annotations,Annotation Type GwtCompatible,"The presence of this annotation on a type indicates that the type may be used with the Google Web Toolkit (GWT). When applied to a method, the return type of the method is GWT compatible. It's useful to indicate that an instance created by factory methods has a GWT serializable type. In the following example, @GwtCompatible class Lists { ... @GwtCompatible(serializable = true) static <E> List<E> newArrayList(E... elements) { ... } } The return value of Lists.newArrayList(E[]) has GWT serializable type. It is also useful in specifying contracts of interface methods. In the following example, @GwtCompatible interface ListFactory { ... @GwtCompatible(serializable = true) <E> List<E> newArrayList(E... elements); } The newArrayList(E[]) method of all implementations of ListFactory is expected to return a value with a GWT serializable type. Note that a GwtCompatible type may have some GwtIncompatible methods."
745,common/annotations,com.google.common.annotations,Annotation Type GwtIncompatible,The presence of this annotation on an API indicates that the method may not be used with the Google Web Toolkit (GWT). This annotation behaves identically to the @GwtIncompatible annotation in GWT itself.
746,common/collect,com.google.common.collect,"Class HashBasedTable<R,C,V>","Implementation of Table using linked hash tables. This guarantees predictable iteration order of the various views. The views returned by column(C), columnKeySet(), and columnMap() have iterators that don't support remove(). Otherwise, all optional operations are supported. Null row keys, columns keys, and values are not supported. Lookups by row key are often faster than lookups by column key, because the data is stored in a Map<R, Map<C, V>>. A method call like column(columnKey).get(rowKey) still runs quickly, since the row key is provided. However, column(columnKey).size() takes longer, since an iteration across all row keys occurs. Note that this implementation is not synchronized. If multiple threads access this table concurrently and one of the threads modifies the table, it must be synchronized externally. See the Guava User Guide article on Table."
747,common/collect,com.google.common.collect,"Class HashBiMap<K,V>",A BiMap backed by two hash tables. This implementation allows null keys and values. A HashBiMap and its inverse are both serializable. This implementation guarantees insertion-based iteration order of its keys. See the Guava User Guide article on BiMap .
748,common/hash,com.google.common.hash,Class HashCode,An immutable hash code of arbitrary bit length.
749,common/hash,com.google.common.hash,Interface Hasher,"A PrimitiveSink that can compute a hash code after reading the input. Each hasher should translate all multibyte values (putInt(int), putLong(long), etc) to bytes in little-endian order. Warning: The result of calling any methods after calling hash() is undefined. Warning: Using a specific character encoding when hashing a CharSequence with putString(CharSequence, Charset) is generally only useful for cross-language compatibility (otherwise prefer putUnencodedChars(java.lang.CharSequence)). However, the character encodings must be identical across languages. Also beware that Charset definitions may occasionally change between Java releases. Warning: Chunks of data that are put into the Hasher are not delimited. The resulting HashCode is dependent only on the bytes inserted, and the order in which they were inserted, not how those bytes were chunked into discrete put() operations. For example, the following three expressions all generate colliding hash codes: newHasher().putByte(b1).putByte(b2).putByte(b3).hash() newHasher().putByte(b1).putBytes(new byte[] { b2, b3 }).hash() newHasher().putBytes(new byte[] { b1, b2, b3 }).hash() If you wish to avoid this, you should either prepend or append the size of each chunk. Keep in mind that when dealing with char sequences, the encoded form of two concatenated char sequences is not equivalent to the concatenation of their encoded form. Therefore, putString(CharSequence, Charset) should only be used consistently with complete sequences and not broken into chunks."
750,common/hash,com.google.common.hash,Interface HashFunction,"A hash function is a collision-averse pure function that maps an arbitrary block of data to a number called a hash code. DefinitionUnpacking this definition: block of data: the input for a hash function is always, in concept, an ordered byte array. This hashing API accepts an arbitrary sequence of byte and multibyte values (via Hasher), but this is merely a convenience; these are always translated into raw byte sequences under the covers. hash code: each hash function always yields hash codes of the same fixed bit length (given by bits()). For example, Hashing.sha1() produces a 160-bit number, while Hashing.murmur3_32() yields only 32 bits. Because a long value is clearly insufficient to hold all hash code values, this API represents a hash code as an instance of HashCode. pure function: the value produced must depend only on the input bytes, in the order they appear. Input data is never modified. HashFunction instances should always be stateless, and therefore thread-safe. collision-averse: while it can't be helped that a hash function will sometimes produce the same hash code for distinct inputs (a ""collision""), every hash function strives to some degree to make this unlikely. (Without this condition, a function that always returns zero could be called a hash function. It is not.) Summarizing the last two points: ""equal yield equal always; unequal yield unequal often."" This is the most important characteristic of all hash functions. Desirable propertiesA high-quality hash function strives for some subset of the following virtues: collision-resistant: while the definition above requires making at least some token attempt, one measure of the quality of a hash function is how well it succeeds at this goal. Important note: it may be easy to achieve the theoretical minimum collision rate when using completely random sample input. The true test of a hash function is how it performs on representative real-world data, which tends to contain many hidden patterns and clumps. The goal of a good hash function is to stamp these patterns out as thoroughly as possible. bit-dispersing: masking out any single bit from a hash code should yield only the expected twofold increase to all collision rates. Informally, the ""information"" in the hash code should be as evenly ""spread out"" through the hash code's bits as possible. The result is that, for example, when choosing a bucket in a hash table of size 2^8, any eight bits could be consistently used. cryptographic: certain hash functions such as Hashing.sha512() are designed to make it as infeasible as possible to reverse-engineer the input that produced a given hash code, or even to discover any two distinct inputs that yield the same result. These are called cryptographic hash functions. But, whenever it is learned that either of these feats has become computationally feasible, the function is deemed ""broken"" and should no longer be used for secure purposes. (This is the likely eventual fate of all cryptographic hashes.) fast: perhaps self-explanatory, but often the most important consideration. Providing input to a hash functionThe primary way to provide the data that your hash function should act on is via a Hasher. Obtain a new hasher from the hash function using newHasher(), ""push"" the relevant data into it using methods like Hasher.putBytes(byte[]), and finally ask for the HashCode when finished using Hasher.hash(). (See an example of this.) If all you want to hash is a single byte array, string or long value, there are convenient shortcut methods defined directly on HashFunction to make this easier. Hasher accepts primitive data types, but can also accept any Object of type T provided that you implement a Funnel<T> to specify how to ""feed"" data from that object into the function. (See an example of this.) Compatibility note: Throughout this API, multibyte values are always interpreted in little-endian order. That is, hashing the byte array {0x01, 0x02, 0x03, 0x04} is equivalent to hashing the int value 0x04030201. If this isn't what you need, methods such as Integer.reverseBytes(int) and Ints.toByteArray(int) will help. Relationship to Object.hashCode()Java's baked-in concept of hash codes is constrained to 32 bits, and provides no separation between hash algorithms and the data they act on, so alternate hash algorithms can't be easily substituted. Also, implementations of hashCode tend to be poor-quality, in part because they end up depending on other existing poor-quality hashCode implementations, including those in many JDK classes. Object.hashCode implementations tend to be very fast, but have weak collision prevention and no expectation of bit dispersion. This leaves them perfectly suitable for use in hash tables, because extra collisions cause only a slight performance hit, while poor bit dispersion is easily corrected using a secondary hash function (which all reasonable hash table implementations in Java use). For the many uses of hash functions beyond data structures, however, Object.hashCode almost always falls short -- hence this library."
751,common/hash,com.google.common.hash,Class Hashing,"Static methods to obtain HashFunction instances, and other static hashing-related utilities. A comparison of the various hash functions can be found here."
752,common/hash,com.google.common.hash,Class HashingInputStream,An InputStream that maintains a hash of the data read from it.
753,common/hash,com.google.common.hash,Class HashingOutputStream,An OutputStream that maintains a hash of the data written to it.
754,common/collect,com.google.common.collect,"Class HashMultimap<K,V>","Implementation of Multimap using hash tables. The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an existing key-value pair has no effect. Keys and values may be null. All optional multimap methods are supported, and all returned views are modifiable. This class is not threadsafe when any concurrent operations update the multimap. Concurrent read operations will work correctly if the last write happens-before any reads. To allow concurrent update operations, wrap your multimap with a call to Multimaps.synchronizedSetMultimap(com.google.common.collect.SetMultimap<K, V>)."
755,common/collect,com.google.common.collect,Class HashMultiset<E>,Multiset implementation backed by a HashMap.
756,common/net,com.google.common.net,Class HostAndPort,"An immutable representation of a host and port. Example usage: HostAndPort hp = HostAndPort.fromString(""[2001:db8::1]"") .withDefaultPort(80) .requireBracketsForIPv6(); hp.getHost(); // returns ""2001:db8::1"" hp.getPort(); // returns 80 hp.toString(); // returns ""[2001:db8::1]:80"" Here are some examples of recognized formats: example.com example.com:80 192.0.2.1 192.0.2.1:80 [2001:db8::1] - getHost() omits brackets [2001:db8::1]:80 - getHost() omits brackets 2001:db8::1 - Use requireBracketsForIPv6() to prohibit this Note that this is not an exhaustive list, because these methods are only concerned with brackets, colons, and port numbers. Full validation of the host field (if desired) is the caller's responsibility."
757,common/net,com.google.common.net,Class HostSpecifier,"A syntactically valid host specifier, suitable for use in a URI. This may be either a numeric IP address in IPv4 or IPv6 notation, or a domain name. Because this class is intended to represent host specifiers which can reasonably be used in a URI, the domain name case is further restricted to include only those domain names which end in a recognized public suffix; see InternetDomainName.isPublicSuffix() for details. Note that no network lookups are performed by any HostSpecifier methods. No attempt is made to verify that a provided specifier corresponds to a real or accessible host. Only syntactic and pattern-based checks are performed. If you know that a given string represents a numeric IP address, use InetAddresses to obtain and manipulate a InetAddress instance from it rather than using this class. Similarly, if you know that a given string represents a domain name, use InternetDomainName rather than this class."
758,common/html,com.google.common.html,Class HtmlEscapers,"Escaper instances suitable for strings to be included in HTML attribute values and most elements' text contents. When possible, avoid manual escaping by using templating systems and high-level APIs that provide autoescaping. One Google-authored templating system available for external use is Closure Templates. HTML escaping is particularly tricky: For example, some elements' text contents must not be HTML escaped. As a result, it is impossible to escape an HTML document correctly without domain-specific knowledge beyond what HtmlEscapers provides. We strongly encourage the use of HTML templating systems."
759,common/net,com.google.common.net,Class HttpHeaders,Contains constant definitions for the HTTP header field names. See: RFC 2109RFC 2183RFC 2616RFC 2965RFC 5988
760,common/net,com.google.common.net,Class HttpHeaders.ReferrerPolicyValues,Values for the Referrer-Policy header.
761,common/collect,com.google.common.collect,"Class ImmutableBiMap<K,V>","A BiMap whose contents will never change, with many other important properties detailed at ImmutableCollection."
762,common/collect,com.google.common.collect,"Class ImmutableBiMap.Builder<K,V>","A builder for creating immutable bimap instances, especially public static final bimaps (""constant bimaps""). Example: static final ImmutableBiMap<String, Integer> WORD_TO_INT = new ImmutableBiMap.Builder<String, Integer>() .put(""one"", 1) .put(""two"", 2) .put(""three"", 3) .build(); For small immutable bimaps, the ImmutableBiMap.of() methods are even more convenient. By default, a Builder will generate bimaps that iterate over entries in the order they were inserted into the builder. For example, in the above example, WORD_TO_INT.entrySet() is guaranteed to iterate over the entries in the order ""one""=1, ""two""=2, ""three""=3, and keySet() and values() respect the same order. If you want a different order, consider using orderEntriesByValue(Comparator), which changes this builder to sort entries by value. Builder instances can be reused - it is safe to call build() multiple times to build multiple bimaps in series. Each bimap is a superset of the bimaps created before it."
763,common/collect,com.google.common.collect,Class ImmutableClassToInstanceMap<B>,"A ClassToInstanceMap whose contents will never change, with many other important properties detailed at ImmutableCollection."
764,common/collect,com.google.common.collect,Class ImmutableClassToInstanceMap.Builder<B>,"A builder for creating immutable class-to-instance maps. Example: static final ImmutableClassToInstanceMap<Handler> HANDLERS = new ImmutableClassToInstanceMap.Builder<Handler>() .put(FooHandler.class, new FooHandler()) .put(BarHandler.class, new SubBarHandler()) .put(Handler.class, new QuuxHandler()) .build(); After invoking build() it is still possible to add more entries and build again. Thus each map generated by this builder will be a superset of any map generated before it."
765,common/collect,com.google.common.collect,Class ImmutableCollection<E>,"A Collection whose contents will never change, and which offers a few additional guarantees detailed below. Warning: avoid direct usage of ImmutableCollection as a type (just as with Collection itself). Prefer subtypes such as ImmutableSet or ImmutableList, which have well-defined Object.equals(java.lang.Object) semantics, thus avoiding a common source of bugs and confusion. About all Immutable- collectionsThe remainder of this documentation applies to every public Immutable- type in this package, whether it is a subtype of ImmutableCollection or not. GuaranteesEach makes the following guarantees: Shallow immutability. Elements can never be added, removed or replaced in this collection. This is a stronger guarantee than that of Collections.unmodifiableCollection(java.util.Collection<? extends T>), whose contents change whenever the wrapped collection is modified. Null-hostility. This collection will never contain a null element. Deterministic iteration. The iteration order is always well-defined, depending on how the collection was created. Typically this is insertion order unless an explicit ordering is otherwise specified (e.g. ImmutableSortedSet.naturalOrder()). See the appropriate factory method for details. View collections such as ImmutableMultiset.elementSet() iterate in the same order as the parent, except as noted. Thread safety. It is safe to access this collection concurrently from multiple threads. Integrity. This type cannot be subclassed outside this package (which would allow these guarantees to be violated). ""Interfaces"", not implementationsThese are classes instead of interfaces to prevent external subtyping, but should be thought of as interfaces in every important sense. Each public class such as ImmutableSet is a type offering meaningful behavioral guarantees. This is substantially different from the case of (say) HashSet, which is an implementation, with semantics that were largely defined by its supertype. For field types and method return types, you should generally use the immutable type (such as ImmutableList) instead of the general collection interface type (such as List). This communicates to your callers all of the semantic guarantees listed above, which is almost always very useful information. On the other hand, a parameter type of ImmutableList is generally a nuisance to callers. Instead, accept Iterable and have your method or constructor body pass it to the appropriate copyOf method itself. Expressing the immutability guarantee directly in the type that user code references is a powerful advantage. Although Java offers certain immutable collection factory methods, such as Collections.singleton(Object) and Set.of, we recommend using these classes instead for this reason (as well as for consistency). CreationExcept for logically ""abstract"" types like ImmutableCollection itself, each Immutable type provides the static operations you need to obtain instances of that type. These usually include: Static methods named of, accepting an explicit list of elements or entries. Static methods named copyOf (or copyOfSorted), accepting an existing collection whose contents should be copied. A static nested Builder class which can be used to populate a new immutable instance. WarningsWarning: as with any collection, it is almost always a bad idea to modify an element (in a way that affects its Object.equals(java.lang.Object) behavior) while it is contained in a collection. Undefined behavior and bugs will result. It's generally best to avoid using mutable objects as elements at all, as many users may expect your ""immutable"" object to be deeply immutable. Performance notesImplementations can be generally assumed to prioritize memory efficiency, then speed of access, and lastly speed of creation. The copyOf methods will sometimes recognize that the actual copy operation is unnecessary; for example, copyOf(copyOf(anArrayList)) should copy the data only once. This reduces the expense of habitually making defensive copies at API boundaries. However, the precise conditions for skipping the copy operation are undefined. Warning: a view collection such as ImmutableMap.keySet or ImmutableList.subList(int, int) may retain a reference to the entire data set, preventing it from being garbage collected. If some of the data is no longer reachable through other means, this constitutes a memory leak. Pass the view collection to the appropriate copyOf method to obtain a correctly-sized copy. The performance of using the associated Builder class can be assumed to be no worse, and possibly better, than creating a mutable collection and copying it. Implementations generally do not cache hash codes. If your element or key type has a slow hashCode implementation, it should cache it itself. Example usage class Foo { private static final ImmutableSet<String> RESERVED_CODES = ImmutableSet.of(""AZ"", ""CQ"", ""ZX""); private final ImmutableSet<String> codes; public Foo(Iterable<String> codes) { this.codes = ImmutableSet.copyOf(codes); checkArgument(Collections.disjoint(this.codes, RESERVED_CODES)); } } See alsoSee the Guava User Guide article on immutable collections."
766,common/collect,com.google.common.collect,Class ImmutableCollection.Builder<E>,Abstract base class for builders of ImmutableCollection types.
767,common/primitives,com.google.common.primitives,Class ImmutableDoubleArray,"An immutable array of double values, with an API resembling List. Advantages compared to double[]: All the many well-known advantages of immutability (read Effective Java, third edition, Item 17). Has the value-based (not identity-based) equals(java.lang.Object), hashCode(), and toString() behavior you expect. Offers useful operations beyond just get and length, so you don't have to hunt through classes like Arrays and Doubles for them. Supports a copy-free subArray(int, int) view, so methods that accept this type don't need to add overloads that accept start and end indexes. Can be streamed without ""breaking the chain"": foo.getBarDoubles().stream().... Access to all collection-based utilities via asList() (though at the cost of allocating garbage). Disadvantages compared to double[]: Memory footprint has a fixed overhead (about 24 bytes per instance). Some construction use cases force the data to be copied (though several construction APIs are offered that don't). Can't be passed directly to methods that expect double[] (though the most common utilities do have replacements here). Dependency on com.google.common / Guava. Advantages compared to ImmutableList<Double>: Improved memory compactness and locality. Can be queried without allocating garbage. Access to DoubleStream features (like DoubleStream.sum()) using stream() instead of the awkward stream().mapToDouble(v -> v). Disadvantages compared to ImmutableList<Double>: Can't be passed directly to methods that expect Iterable, Collection, or List (though the most common utilities do have replacements here, and there is a lazy asList() view)."
768,common/primitives,com.google.common.primitives,Class ImmutableDoubleArray.Builder,A builder for ImmutableDoubleArray instances; obtained using ImmutableDoubleArray.builder(int).
769,common/graph,com.google.common.graph,Class ImmutableGraph<N>,A Graph whose elements and structural relationships will never change. Instances of this class may be obtained with copyOf(Graph). See the Guava User's Guide's discussion of the Immutable* types for more information on the properties and guarantees provided by this class.
770,common/graph,com.google.common.graph,Class ImmutableGraph.Builder<N>,"A builder for creating ImmutableGraph instances, especially static final graphs. Example: static final ImmutableGraph<Country> COUNTRY_ADJACENCY_GRAPH = GraphBuilder.undirected() .<Country>immutable() .putEdge(FRANCE, GERMANY) .putEdge(FRANCE, BELGIUM) .putEdge(GERMANY, BELGIUM) .addNode(ICELAND) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple graphs in series. Each new graph contains all the elements of the ones created before it."
771,common/primitives,com.google.common.primitives,Class ImmutableIntArray,"An immutable array of int values, with an API resembling List. Advantages compared to int[]: All the many well-known advantages of immutability (read Effective Java, third edition, Item 17). Has the value-based (not identity-based) equals(java.lang.Object), hashCode(), and toString() behavior you expect. Offers useful operations beyond just get and length, so you don't have to hunt through classes like Arrays and Ints for them. Supports a copy-free subArray(int, int) view, so methods that accept this type don't need to add overloads that accept start and end indexes. Can be streamed without ""breaking the chain"": foo.getBarInts().stream().... Access to all collection-based utilities via asList() (though at the cost of allocating garbage). Disadvantages compared to int[]: Memory footprint has a fixed overhead (about 24 bytes per instance). Some construction use cases force the data to be copied (though several construction APIs are offered that don't). Can't be passed directly to methods that expect int[] (though the most common utilities do have replacements here). Dependency on com.google.common / Guava. Advantages compared to ImmutableList<Integer>: Improved memory compactness and locality. Can be queried without allocating garbage. Access to IntStream features (like IntStream.sum()) using stream() instead of the awkward stream().mapToInt(v -> v). Disadvantages compared to ImmutableList<Integer>: Can't be passed directly to methods that expect Iterable, Collection, or List (though the most common utilities do have replacements here, and there is a lazy asList() view)."
772,common/primitives,com.google.common.primitives,Class ImmutableIntArray.Builder,A builder for ImmutableIntArray instances; obtained using ImmutableIntArray.builder(int).
773,common/collect,com.google.common.collect,Class ImmutableList<E>,"A List whose contents will never change, with many other important properties detailed at ImmutableCollection. See the Guava User Guide article on immutable collections."
774,common/collect,com.google.common.collect,Class ImmutableList.Builder<E>,"A builder for creating immutable list instances, especially public static final lists (""constant lists""). Example: public static final ImmutableList<Color> GOOGLE_COLORS = new ImmutableList.Builder<Color>() .addAll(WEBSAFE_COLORS) .add(new Color(0, 191, 255)) .build(); Elements appear in the resulting list in the same order they were added to the builder. Builder instances can be reused; it is safe to call build() multiple times to build multiple lists in series. Each new list contains all the elements of the ones created before it."
775,common/collect,com.google.common.collect,"Class ImmutableListMultimap<K,V>","A ListMultimap whose contents will never change, with many other important properties detailed at ImmutableCollection. See the Guava User Guide article on immutable collections."
776,common/collect,com.google.common.collect,"Class ImmutableListMultimap.Builder<K,V>","A builder for creating immutable ListMultimap instances, especially public static final multimaps (""constant multimaps""). Example: static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP = new ImmutableListMultimap.Builder<String, Integer>() .put(""one"", 1) .putAll(""several"", 1, 2, 3) .putAll(""many"", 1, 2, 3, 4, 5) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple multimaps in series. Each multimap contains the key-value mappings in the previously created multimaps."
777,common/primitives,com.google.common.primitives,Class ImmutableLongArray,"An immutable array of long values, with an API resembling List. Advantages compared to long[]: All the many well-known advantages of immutability (read Effective Java, third edition, Item 17). Has the value-based (not identity-based) equals(java.lang.Object), hashCode(), and toString() behavior you expect. Offers useful operations beyond just get and length, so you don't have to hunt through classes like Arrays and Longs for them. Supports a copy-free subArray(int, int) view, so methods that accept this type don't need to add overloads that accept start and end indexes. Can be streamed without ""breaking the chain"": foo.getBarLongs().stream().... Access to all collection-based utilities via asList() (though at the cost of allocating garbage). Disadvantages compared to long[]: Memory footprint has a fixed overhead (about 24 bytes per instance). Some construction use cases force the data to be copied (though several construction APIs are offered that don't). Can't be passed directly to methods that expect long[] (though the most common utilities do have replacements here). Dependency on com.google.common / Guava. Advantages compared to ImmutableList<Long>: Improved memory compactness and locality. Can be queried without allocating garbage. Access to LongStream features (like LongStream.sum()) using stream() instead of the awkward stream().mapToLong(v -> v). Disadvantages compared to ImmutableList<Long>: Can't be passed directly to methods that expect Iterable, Collection, or List (though the most common utilities do have replacements here, and there is a lazy asList() view)."
778,common/primitives,com.google.common.primitives,Class ImmutableLongArray.Builder,A builder for ImmutableLongArray instances; obtained using ImmutableLongArray.builder(int).
779,common/collect,com.google.common.collect,"Class ImmutableMap<K,V>","A Map whose contents will never change, with many other important properties detailed at ImmutableCollection. See the Guava User Guide article on immutable collections."
780,common/collect,com.google.common.collect,"Class ImmutableMap.Builder<K,V>","A builder for creating immutable map instances, especially public static final maps (""constant maps""). Example: static final ImmutableMap<String, Integer> WORD_TO_INT = new ImmutableMap.Builder<String, Integer>() .put(""one"", 1) .put(""two"", 2) .put(""three"", 3) .build(); For small immutable maps, the ImmutableMap.of() methods are even more convenient. By default, a Builder will generate maps that iterate over entries in the order they were inserted into the builder, equivalently to LinkedHashMap. For example, in the above example, WORD_TO_INT.entrySet() is guaranteed to iterate over the entries in the order ""one""=1, ""two""=2, ""three""=3, and keySet() and values() respect the same order. If you want a different order, consider using ImmutableSortedMap to sort by keys, or call orderEntriesByValue(Comparator), which changes this builder to sort entries by value. Builder instances can be reused - it is safe to call build() multiple times to build multiple maps in series. Each map is a superset of the maps created before it."
781,common/collect,com.google.common.collect,"Class ImmutableMultimap<K,V>","A Multimap whose contents will never change, with many other important properties detailed at ImmutableCollection. Warning: avoid direct usage of ImmutableMultimap as a type (as with Multimap itself). Prefer subtypes such as ImmutableSetMultimap or ImmutableListMultimap, which have well-defined equals(java.lang.Object) semantics, thus avoiding a common source of bugs and confusion. Note: every ImmutableMultimap offers an inverse() view, so there is no need for a distinct ImmutableBiMultimap type. Key-grouped iteration. All view collections follow the same iteration order. In all current implementations, the iteration order always keeps multiple entries with the same key together. Any creation method that would customarily respect insertion order (such as copyOf(Multimap)) instead preserves key-grouped order by inserting entries for an existing key immediately after the last entry having that key. See the Guava User Guide article on immutable collections."
782,common/collect,com.google.common.collect,"Class ImmutableMultimap.Builder<K,V>","A builder for creating immutable multimap instances, especially public static final multimaps (""constant multimaps""). Example: static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP = new ImmutableMultimap.Builder<String, Integer>() .put(""one"", 1) .putAll(""several"", 1, 2, 3) .putAll(""many"", 1, 2, 3, 4, 5) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple multimaps in series. Each multimap contains the key-value mappings in the previously created multimaps."
783,common/collect,com.google.common.collect,Class ImmutableMultiset<E>,"A Multiset whose contents will never change, with many other important properties detailed at ImmutableCollection. Grouped iteration. In all current implementations, duplicate elements always appear consecutively when iterating. Elements iterate in order by the first appearance of that element when the multiset was created. See the Guava User Guide article on immutable collections."
784,common/collect,com.google.common.collect,Class ImmutableMultiset.Builder<E>,"A builder for creating immutable multiset instances, especially public static final multisets (""constant multisets""). Example: public static final ImmutableMultiset<Bean> BEANS = new ImmutableMultiset.Builder<Bean>() .addCopies(Bean.COCOA, 4) .addCopies(Bean.GARDEN, 6) .addCopies(Bean.RED, 8) .addCopies(Bean.BLACK_EYED, 10) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple multisets in series."
785,common/graph,com.google.common.graph,"Class ImmutableNetwork<N,E>",A Network whose elements and structural relationships will never change. Instances of this class may be obtained with copyOf(Network). See the Guava User's Guide's discussion of the Immutable* types for more information on the properties and guarantees provided by this class.
786,common/graph,com.google.common.graph,"Class ImmutableNetwork.Builder<N,E>","A builder for creating ImmutableNetwork instances, especially static final networks. Example: static final ImmutableNetwork<City, Train> TRAIN_NETWORK = NetworkBuilder.undirected() .allowsParallelEdges(true) .<City, Train>immutable() .addEdge(PARIS, BRUSSELS, Thalys.trainNumber(""1111"")) .addEdge(PARIS, BRUSSELS, RegionalTrain.trainNumber(""2222"")) .addEdge(LONDON, PARIS, Eurostar.trainNumber(""3333"")) .addEdge(LONDON, BRUSSELS, Eurostar.trainNumber(""4444"")) .addNode(REYKJAVIK) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple networks in series. Each new network contains all the elements of the ones created before it."
787,common/collect,com.google.common.collect,"Class ImmutableRangeMap<K extends Comparable<?>,V>","A RangeMap whose contents will never change, with many other important properties detailed at ImmutableCollection."
788,common/collect,com.google.common.collect,"Class ImmutableRangeMap.Builder<K extends Comparable<?>,V>",A builder for immutable range maps. Overlapping ranges are prohibited.
789,common/collect,com.google.common.collect,Class ImmutableRangeSet<C extends Comparable>,"A RangeSet whose contents will never change, with many other important properties detailed at ImmutableCollection."
790,common/collect,com.google.common.collect,Class ImmutableRangeSet.Builder<C extends Comparable<?>>,A builder for immutable range sets.
791,common/collect,com.google.common.collect,Class ImmutableSet<E>,"A Set whose contents will never change, with many other important properties detailed at ImmutableCollection."
792,common/collect,com.google.common.collect,Class ImmutableSet.Builder<E>,"A builder for creating ImmutableSet instances. Example: static final ImmutableSet<Color> GOOGLE_COLORS = ImmutableSet.<Color>builder() .addAll(WEBSAFE_COLORS) .add(new Color(0, 191, 255)) .build(); Elements appear in the resulting set in the same order they were first added to the builder. Building does not change the state of the builder, so it is still possible to add more elements and to build again."
793,common/collect,com.google.common.collect,"Class ImmutableSetMultimap<K,V>","A SetMultimap whose contents will never change, with many other important properties detailed at ImmutableCollection. See the Guava User Guide article on immutable collections."
794,common/collect,com.google.common.collect,"Class ImmutableSetMultimap.Builder<K,V>","A builder for creating immutable SetMultimap instances, especially public static final multimaps (""constant multimaps""). Example: static final Multimap<String, Integer> STRING_TO_INTEGER_MULTIMAP = new ImmutableSetMultimap.Builder<String, Integer>() .put(""one"", 1) .putAll(""several"", 1, 2, 3) .putAll(""many"", 1, 2, 3, 4, 5) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple multimaps in series. Each multimap contains the key-value mappings in the previously created multimaps."
795,common/collect,com.google.common.collect,"Class ImmutableSortedMap<K,V>","A NavigableMap whose contents will never change, with many other important properties detailed at ImmutableCollection. Warning: as with any sorted collection, you are strongly advised not to use a Comparator or Comparable type whose comparison behavior is inconsistent with equals. That is, a.compareTo(b) or comparator.compare(a, b) should equal zero if and only if a.equals(b). If this advice is not followed, the resulting map will not correctly obey its specification. See the Guava User Guide article on immutable collections."
796,common/collect,com.google.common.collect,"Class ImmutableSortedMap.Builder<K,V>","A builder for creating immutable sorted map instances, especially public static final maps (""constant maps""). Example: static final ImmutableSortedMap<Integer, String> INT_TO_WORD = new ImmutableSortedMap.Builder<Integer, String>(Ordering.natural()) .put(1, ""one"") .put(2, ""two"") .put(3, ""three"") .build(); For small immutable sorted maps, the ImmutableSortedMap.of() methods are even more convenient. Builder instances can be reused - it is safe to call build() multiple times to build multiple maps in series. Each map is a superset of the maps created before it."
797,common/collect,com.google.common.collect,Class ImmutableSortedMultiset<E>,"A SortedMultiset whose contents will never change, with many other important properties detailed at ImmutableCollection. Warning: as with any sorted collection, you are strongly advised not to use a Comparator or Comparable type whose comparison behavior is inconsistent with equals. That is, a.compareTo(b) or comparator.compare(a, b) should equal zero if and only if a.equals(b). If this advice is not followed, the resulting collection will not correctly obey its specification. See the Guava User Guide article on immutable collections."
798,common/collect,com.google.common.collect,Class ImmutableSortedMultiset.Builder<E>,"A builder for creating immutable multiset instances, especially public static final multisets (""constant multisets""). Example: public static final ImmutableSortedMultiset<Bean> BEANS = new ImmutableSortedMultiset.Builder<Bean>(colorComparator()) .addCopies(Bean.COCOA, 4) .addCopies(Bean.GARDEN, 6) .addCopies(Bean.RED, 8) .addCopies(Bean.BLACK_EYED, 10) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple multisets in series."
799,common/collect,com.google.common.collect,Class ImmutableSortedSet<E>,"A NavigableSet whose contents will never change, with many other important properties detailed at ImmutableCollection. Warning: as with any sorted collection, you are strongly advised not to use a Comparator or Comparable type whose comparison behavior is inconsistent with equals. That is, a.compareTo(b) or comparator.compare(a, b) should equal zero if and only if a.equals(b). If this advice is not followed, the resulting collection will not correctly obey its specification. See the Guava User Guide article on immutable collections."
800,common/collect,com.google.common.collect,Class ImmutableSortedSet.Builder<E>,"A builder for creating immutable sorted set instances, especially public static final sets (""constant sets""), with a given comparator. Example: public static final ImmutableSortedSet<Number> LUCKY_NUMBERS = new ImmutableSortedSet.Builder<Number>(ODDS_FIRST_COMPARATOR) .addAll(SINGLE_DIGIT_PRIMES) .add(42) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple sets in series. Each set is a superset of the set created before it."
801,common/collect,com.google.common.collect,"Class ImmutableTable<R,C,V>","A Table whose contents will never change, with many other important properties detailed at ImmutableCollection. See the Guava User Guide article on immutable collections."
802,common/collect,com.google.common.collect,"Class ImmutableTable.Builder<R,C,V>","A builder for creating immutable table instances, especially public static final tables (""constant tables""). Example: static final ImmutableTable<Integer, Character, String> SPREADSHEET = new ImmutableTable.Builder<Integer, Character, String>() .put(1, 'A', ""foo"") .put(1, 'B', ""bar"") .put(2, 'A', ""baz"") .build(); By default, the order in which cells are added to the builder determines the iteration ordering of all views in the returned table, with putAll(com.google.common.collect.Table<? extends R, ? extends C, ? extends V>) following the Table.cellSet() iteration order. However, if orderRowsBy(java.util.Comparator<? super R>) or orderColumnsBy(java.util.Comparator<? super C>) is called, the views are sorted by the supplied comparators. For empty or single-cell immutable tables, ImmutableTable.of() and ImmutableTable.of(Object, Object, Object) are even more convenient. Builder instances can be reused - it is safe to call build() multiple times to build multiple tables in series. Each table is a superset of the tables created before it."
803,common/reflect,com.google.common.reflect,Class ImmutableTypeToInstanceMap<B>,A type-to-instance map backed by an ImmutableMap. See also MutableTypeToInstanceMap.
804,common/reflect,com.google.common.reflect,Class ImmutableTypeToInstanceMap.Builder<B>,"A builder for creating immutable type-to-instance maps. Example: static final ImmutableTypeToInstanceMap<Handler<?>> HANDLERS = ImmutableTypeToInstanceMap.<Handler<?>>builder() .put(new TypeToken<Handler<Foo>>() {}, new FooHandler()) .put(new TypeToken<Handler<Bar>>() {}, new SubBarHandler()) .build(); After invoking build() it is still possible to add more entries and build again. Thus each map generated by this builder will be a superset of any map generated before it."
805,common/graph,com.google.common.graph,"Class ImmutableValueGraph<N,V>",A ValueGraph whose elements and structural relationships will never change. Instances of this class may be obtained with copyOf(ValueGraph). See the Guava User's Guide's discussion of the Immutable* types for more information on the properties and guarantees provided by this class.
806,common/graph,com.google.common.graph,"Class ImmutableValueGraph.Builder<N,V>","A builder for creating ImmutableValueGraph instances, especially static final graphs. Example: static final ImmutableValueGraph<City, Distance> CITY_ROAD_DISTANCE_GRAPH = ValueGraphBuilder.undirected() .<City, Distance>immutable() .putEdgeValue(PARIS, BERLIN, kilometers(1060)) .putEdgeValue(PARIS, BRUSSELS, kilometers(317)) .putEdgeValue(BERLIN, BRUSSELS, kilometers(764)) .addNode(REYKJAVIK) .build(); Builder instances can be reused; it is safe to call build() multiple times to build multiple graphs in series. Each new graph contains all the elements of the ones created before it."
807,common/net,com.google.common.net,Class InetAddresses,"Static utility methods pertaining to InetAddress instances. Important note: Unlike InetAddress.getByName(), the methods of this class never cause DNS services to be accessed. For this reason, you should prefer these methods as much as possible over their JDK equivalents whenever you are expecting to handle only IP address string literals -- there is no blocking DNS penalty for a malformed string. When dealing with Inet4Address and Inet6Address objects as byte arrays (vis. InetAddress.getAddress()) they are 4 and 16 bytes in length, respectively, and represent the address in network byte order. Examples of IP addresses and their byte representations: The IPv4 loopback address, ""127.0.0.1"". 7f 00 00 01The IPv6 loopback address, ""::1"". 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01From the IPv6 reserved documentation prefix (2001:db8::/32), ""2001:db8::1"". 20 01 0d b8 00 00 00 00 00 00 00 00 00 00 00 01An IPv6 ""IPv4 compatible"" (or ""compat"") address, ""::192.168.0.1"". 00 00 00 00 00 00 00 00 00 00 00 00 c0 a8 00 01An IPv6 ""IPv4 mapped"" address, ""::ffff:192.168.0.1"". 00 00 00 00 00 00 00 00 00 00 ff ff c0 a8 00 01A few notes about IPv6 ""IPv4 mapped"" addresses and their observed use in Java. ""IPv4 mapped"" addresses were originally a representation of IPv4 addresses for use on an IPv6 socket that could receive both IPv4 and IPv6 connections (by disabling the IPV6_V6ONLY socket option on an IPv6 socket). Yes, it's confusing. Nevertheless, these ""mapped"" addresses were never supposed to be seen on the wire. That assumption was dropped, some say mistakenly, in later RFCs with the apparent aim of making IPv4-to-IPv6 transition simpler. Technically one can create a 128bit IPv6 address with the wire format of a ""mapped"" address, as shown above, and transmit it in an IPv6 packet header. However, Java's InetAddress creation methods appear to adhere doggedly to the original intent of the ""mapped"" address: all ""mapped"" addresses return Inet4Address objects. For added safety, it is common for IPv6 network operators to filter all packets where either the source or destination address appears to be a ""compat"" or ""mapped"" address. Filtering suggestions usually recommend discarding any packets with source or destination addresses in the invalid range ::/3, which includes both of these bizarre address formats. For more information on ""bogons"", including lists of IPv6 bogon space, see: http://en.wikipedia. org/wiki/Bogon_filteringhttp://www.cymru.com/Bogons/ ipv6.txthttp://www.cymru.com/ Bogons/v6bogon.htmlhttp://www. space.net/~gert/RIPE/ipv6-filters.html"
808,common/net,com.google.common.net,Class InetAddresses.TeredoInfo,A simple immutable data class to encapsulate the information to be found in a Teredo address. All of the fields in this class are encoded in various portions of the IPv6 address as part of the protocol. More protocols details can be found at: http://en.wikipedia. org/wiki/Teredo_tunneling. The RFC can be found here: RFC 4380.
809,common/io,com.google.common.io,Class InsecureRecursiveDeleteException,"Exception indicating that a recursive delete can't be performed because the file system does not have the support necessary to guarantee that it is not vulnerable to race conditions that would allow it to delete files and directories outside of the directory being deleted (i.e., SecureDirectoryStream is not supported). RecursiveDeleteOption.ALLOW_INSECURE can be used to force the recursive delete method to proceed anyway."
810,common/collect,com.google.common.collect,Interface Interner<E>,"Provides similar behavior to String.intern() for any immutable type. Common implementations are available from the Interners class. Note that String.intern() has some well-known performance limitations, and should generally be avoided. Prefer Interners.newWeakInterner() or another Interner implementation even for String interning."
811,common/collect,com.google.common.collect,Class Interners,Contains static methods pertaining to instances of Interner.
812,common/collect,com.google.common.collect,Class Interners.InternerBuilder,Builder for Interner instances.
813,common/net,com.google.common.net,Class InternetDomainName,"An immutable well-formed internet domain name, such as com or foo.co.uk. Only syntactic analysis is performed; no DNS lookups or other network interactions take place. Thus there is no guarantee that the domain actually exists on the internet. One common use of this class is to determine whether a given string is likely to represent an addressable domain on the web -- that is, for a candidate string ""xxx"", might browsing to ""http://xxx/"" result in a webpage being displayed? In the past, this test was frequently done by determining whether the domain ended with a public suffix but was not itself a public suffix. However, this test is no longer accurate. There are many domains which are both public suffixes and addressable as hosts; ""uk.com"" is one example. Using the subset of public suffixes that are registry suffixes, one can get a better result, as only a few registry suffixes are addressable. However, the most useful test to determine if a domain is a plausible web host is hasPublicSuffix(). This will return true for many domains which (currently) are not hosts, such as ""com"", but given that any public suffix may become a host without warning, it is better to err on the side of permissiveness and thus avoid spurious rejection of valid sites. Of course, to actually determine addressability of any host, clients of this class will need to perform their own DNS lookups. During construction, names are normalized in two ways: ASCII uppercase characters are converted to lowercase. Unicode dot separators other than the ASCII period ('.') are converted to the ASCII period. The normalized values will be returned from toString() and parts(), and will be reflected in the result of equals(Object). Internationalized domain names such as 网络.cn are supported, as are the equivalent IDNA Punycode-encoded versions."
814,common/math,com.google.common.math,Class IntMath,"A class for arithmetic on values of type int. Where possible, methods are defined and named analogously to their BigInteger counterparts. The implementations of many methods in this class are based on material from Henry S. Warren, Jr.'s Hacker's Delight, (Addison Wesley, 2002). Similar functionality for long and for BigInteger can be found in LongMath and BigIntegerMath respectively. For other common operations on int values, see Ints."
815,common/primitives,com.google.common.primitives,Class Ints,"Static utility methods pertaining to int primitives, that are not already found in either Integer or Arrays. See the Guava User Guide article on primitive utilities."
816,common/reflect,com.google.common.reflect,"Class Invokable<T,R>","Wrapper around either a Method or a Constructor. Convenience API is provided to make common reflective operation easier to deal with, such as isPublic(), getParameters() etc. In addition to convenience methods, TypeToken.method(java.lang.reflect.Method) and TypeToken.constructor(java.lang.reflect.Constructor<?>) will resolve the type parameters of the method or constructor in the context of the owner type, which may be a subtype of the declaring class. For example: Method getMethod = List.class.getMethod(""get"", int.class); Invokable<List<String>, ?> invokable = new TypeToken<List<String>>() {}.method(getMethod); assertEquals(TypeToken.of(String.class), invokable.getReturnType()); // Not Object.class! assertEquals(new TypeToken<List<String>>() {}, invokable.getOwnerType());"
817,common/collect,com.google.common.collect,Class Iterables,"An assortment of mainly legacy static utility methods that operate on or return objects of type Iterable. Except as noted, each method has a corresponding Iterator-based method in the Iterators class. Java 8 users: several common uses for this class are now more comprehensively addressed by the new Stream library. Read the method documentation below for comparisons. This class is not being deprecated, but we gently encourage you to migrate to streams. Performance notes: Unless otherwise noted, all of the iterables produced in this class are lazy, which means that their iterators only advance the backing iteration when absolutely necessary. See the Guava User Guide article on Iterables."
818,common/collect,com.google.common.collect,Class Iterators,"This class contains static utility methods that operate on or return objects of type Iterator. Except as noted, each method has a corresponding Iterable-based method in the Iterables class. Performance notes: Unless otherwise noted, all of the iterators produced in this class are lazy, which means that they only advance the backing iteration when absolutely necessary. See the Guava User Guide section on Iterators."
819,util/concurrent,com.google.common.util.concurrent,Class JdkFutureAdapters,"Utilities necessary for working with libraries that supply plain Future instances. Note that, whenever possible, it is strongly preferred to modify those libraries to return ListenableFuture directly."
820,common/base,com.google.common.base,Class Joiner,"An object which joins pieces of text (specified as an array, Iterable, varargs or even a Map) with a separator. It either appends the results to an Appendable or returns them as a String. Example: Joiner joiner = Joiner.on(""; "").skipNulls(); . . . return joiner.join(""Harry"", null, ""Ron"", ""Hermione""); This returns the string ""Harry; Ron; Hermione"". Note that all input elements are converted to strings using Object.toString() before being appended. If neither skipNulls() nor useForNull(String) is specified, the joining methods will throw NullPointerException if any given element is null. Warning: joiner instances are always immutable; a configuration method such as useForNull has no effect on the instance it is invoked on! You must store and use the new joiner instance returned by the method. This makes joiners thread-safe, and safe to store as static final constants. // Bad! Do not do this! Joiner joiner = Joiner.on(','); joiner.skipNulls(); // does nothing! return joiner.join(""wrong"", null, ""wrong""); See the Guava User Guide article on Joiner."
821,common/base,com.google.common.base,Class Joiner.MapJoiner,"An object that joins map entries in the same manner as Joiner joins iterables and arrays. Like Joiner, it is thread-safe and immutable. In addition to operating on Map instances, MapJoiner can operate on Multimap entries in two distinct modes: To output a separate entry for each key-value pair, pass multimap.entries() to a MapJoiner method that accepts entries as input, and receive output of the form key1=A&key1=B&key2=C. To output a single entry for each key, pass multimap.asMap() to a MapJoiner method that accepts a map as input, and receive output of the form key1=[A, B]&key2=C."
822,common/math,com.google.common.math,Class LinearTransformation,"The representation of a linear transformation between real numbers x and y. Graphically, this is the specification of a straight line on a plane. The transformation can be expressed as y = m * x + c for finite m and c, unless it is a vertical transformation in which case x has a constant value for all y. In the non-vertical case, m is the slope of the transformation (and a horizontal transformation has zero slope)."
823,common/math,com.google.common.math,Class LinearTransformation.LinearTransformationBuilder,"This is an intermediate stage in the construction process. It is returned by LinearTransformation.mapping(double, double). You almost certainly don't want to keep instances around, but instead use method chaining. This represents a single point mapping, i.e. a mapping between one x and y value pair."
824,common/io,com.google.common.io,Interface LineProcessor<T>,"A callback to be used with the streaming readLines methods. processLine(java.lang.String) will be called for each line that is read, and should return false when you want to stop processing."
825,common/io,com.google.common.io,Class LineReader,"A class for reading lines of text. Provides the same functionality as BufferedReader.readLine() but for all Readable objects, not just instances of Reader."
826,common/collect,com.google.common.collect,"Class LinkedHashMultimap<K,V>","Implementation of Multimap that does not allow duplicate key-value entries and that returns collections whose iterators follow the ordering in which the data was added to the multimap. The collections returned by keySet, keys, and asMap iterate through the keys in the order they were first added to the multimap. Similarly, get, removeAll, and replaceValues return collections that iterate through the values in the order they were added. The collections generated by entries and values iterate across the key-value mappings in the order they were added to the multimap. The iteration ordering of the collections generated by keySet, keys, and asMap has a few subtleties. As long as the set of keys remains unchanged, adding or removing mappings does not affect the key iteration order. However, if you remove all values associated with a key and then add the key back to the multimap, that key will come last in the key iteration order. The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an existing key-value pair has no effect. Keys and values may be null. All optional multimap methods are supported, and all returned views are modifiable. This class is not threadsafe when any concurrent operations update the multimap. Concurrent read operations will work correctly. To allow concurrent update operations, wrap your multimap with a call to Multimaps.synchronizedSetMultimap(com.google.common.collect.SetMultimap<K, V>). See the Guava User Guide article on Multimap."
827,common/collect,com.google.common.collect,Class LinkedHashMultiset<E>,"A Multiset implementation with predictable iteration order. Its iterator orders elements according to when the first occurrence of the element was added. When the multiset contains multiple instances of an element, those instances are consecutive in the iteration order. If all occurrences of an element are removed, after which that element is added to the multiset, the element will appear at the end of the iteration. See the Guava User Guide article on Multiset."
828,common/collect,com.google.common.collect,"Class LinkedListMultimap<K,V>","An implementation of ListMultimap that supports deterministic iteration order for both keys and values. The iteration order is preserved across non-distinct key values. For example, for the following multimap definition: Multimap<K, V> multimap = LinkedListMultimap.create(); multimap.put(key1, foo); multimap.put(key2, bar); multimap.put(key1, baz); ... the iteration order for keys() is [key1, key2, key1], and similarly for entries(). Unlike LinkedHashMultimap, the iteration order is kept consistent between keys, entries and values. For example, calling: multimap.remove(key1, foo); changes the entries iteration order to [key2=bar, key1=baz] and the key iteration order to [key2, key1]. The entries() iterator returns mutable map entries, and replaceValues(K, java.lang.Iterable<? extends V>) attempts to preserve iteration order as much as possible. The collections returned by keySet() and asMap iterate through the keys in the order they were first added to the multimap. Similarly, get(K), removeAll(java.lang.Object), and replaceValues(K, java.lang.Iterable<? extends V>) return collections that iterate through the values in the order they were added. The collections generated by entries(), keys(), and values() iterate across the key-value mappings in the order they were added to the multimap. The values() and entries() methods both return a List, instead of the Collection specified by the ListMultimap interface. The methods get(K), keySet(), keys(), values(), entries(), and asMap return collections that are views of the multimap. If the multimap is modified while an iteration over any of those collections is in progress, except through the iterator's methods, the results of the iteration are undefined. Keys and values may be null. All optional multimap methods are supported, and all returned views are modifiable. This class is not threadsafe when any concurrent operations update the multimap. Concurrent read operations will work correctly. To allow concurrent update operations, wrap your multimap with a call to Multimaps.synchronizedListMultimap(com.google.common.collect.ListMultimap<K, V>). See the Guava User Guide article on Multimap."
829,util/concurrent,com.google.common.util.concurrent,Interface ListenableFuture<V>,"A Future that accepts completion listeners. Each listener has an associated executor, and it is invoked using this executor once the future's computation is complete. If the computation has already completed when the listener is added, the listener will execute immediately. See the Guava User Guide article on ListenableFuture. This class is GWT-compatible. PurposeThe main purpose of ListenableFuture is to help you chain together a graph of asynchronous operations. You can chain them together manually with calls to methods like Futures.transform, but you will often find it easier to use a framework. Frameworks automate the process, often adding features like monitoring, debugging, and cancellation. Examples of frameworks include: Dagger ProducersThe main purpose of addListener is to support this chaining. You will rarely use it directly, in part because it does not provide direct access to the Future result. (If you want such access, you may prefer Futures.addCallback.) Still, direct addListener calls are occasionally useful: final String name = ...; inFlight.add(name); ListenableFuture<Result> future = service.query(name); future.addListener(new Runnable() { public void run() { processedCount.incrementAndGet(); inFlight.remove(name); lastProcessed.set(name); logger.info(""Done with {0}"", name); } }, executor); How to get an instanceWe encourage you to return ListenableFuture from your methods so that your users can take advantage of the utilities built atop the class. The way that you will create ListenableFuture instances depends on how you currently create Future instances: If you receive them from an java.util.concurrent.ExecutorService, convert that service to a ListeningExecutorService, usually by calling MoreExecutors.listeningDecorator. If you manually call FutureTask.set(V) or a similar method, create a SettableFuture instead. (If your needs are more complex, you may prefer AbstractFuture.) Test doubles: If you need a ListenableFuture for your test, try a SettableFuture or one of the methods in the Futures.immediate* family. Avoid creating a mock or stub Future. Mock and stub implementations are fragile because they assume that only certain methods will be called and because they often implement subtleties of the API improperly. Custom implementation: Avoid implementing ListenableFuture from scratch. If you can't get by with the standard implementations, prefer to derive a new Future instance with the methods in Futures or, if necessary, to extend AbstractFuture. Occasionally, an API will return a plain Future and it will be impossible to change the return type. For this case, we provide a more expensive workaround in JdkFutureAdapters. However, when possible, it is more efficient and reliable to create a ListenableFuture directly."
830,util/concurrent,com.google.common.util.concurrent,Class ListenableFutureTask<V>,"A FutureTask that also implements the ListenableFuture interface. Unlike FutureTask, ListenableFutureTask does not provide an overrideable done() method. For similar functionality, call addListener(java.lang.Runnable, java.util.concurrent.Executor). Few users should use this class. It is intended primarily for those who are implementing an ExecutorService. Most users should call ListeningExecutorService.submit on a service obtained from MoreExecutors.listeningDecorator(java.util.concurrent.ExecutorService)."
831,util/concurrent,com.google.common.util.concurrent,Interface ListenableScheduledFuture<V>,Helper interface to implement both ListenableFuture and ScheduledFuture.
832,util/concurrent,com.google.common.util.concurrent,Interface ListeningExecutorService,"An ExecutorService that returns ListenableFuture instances. To create an instance from an existing ExecutorService, call MoreExecutors.listeningDecorator(ExecutorService)."
833,util/concurrent,com.google.common.util.concurrent,Interface ListeningScheduledExecutorService,"A ScheduledExecutorService that returns ListenableFuture instances from its ExecutorService methods. To create an instance from an existing ScheduledExecutorService, call MoreExecutors.listeningDecorator(ScheduledExecutorService)."
834,common/collect,com.google.common.collect,"Interface ListMultimap<K,V>","A Multimap that can hold duplicate key-value pairs and that maintains the insertion ordering of values for a given key. See the Multimap documentation for information common to all multimaps. The get(K), removeAll(java.lang.Object), and replaceValues(K, java.lang.Iterable<? extends V>) methods each return a List of values. Though the method signature doesn't say so explicitly, the map returned by asMap() has List values. See the Guava User Guide article on Multimap."
835,common/collect,com.google.common.collect,Class Lists,"Static utility methods pertaining to List instances. Also see this class's counterparts Sets, Maps and Queues. See the Guava User Guide article on Lists."
836,common/io,com.google.common.io,Class LittleEndianDataInputStream,"An implementation of DataInput that uses little-endian byte ordering for reading short, int, float, double, and long values. Note: This class intentionally violates the specification of its supertype DataInput, which explicitly requires big-endian byte order."
837,common/io,com.google.common.io,Class LittleEndianDataOutputStream,"An implementation of DataOutput that uses little-endian byte ordering for writing char, short, int, float, double, and long values. Note: This class intentionally violates the specification of its supertype DataOutput, which explicitly requires big-endian byte order."
838,common/cache,com.google.common.cache,"Interface LoadingCache<K,V>","A semi-persistent mapping from keys to values. Values are automatically loaded by the cache, and are stored in the cache until either evicted or manually invalidated. The common way to build instances is using CacheBuilder. Implementations of this interface are expected to be thread-safe, and can be safely accessed by multiple concurrent threads. When evaluated as a Function, a cache yields the same result as invoking getUnchecked(K)."
839,common/math,com.google.common.math,Class LongMath,"A class for arithmetic on values of type long. Where possible, methods are defined and named analogously to their BigInteger counterparts. The implementations of many methods in this class are based on material from Henry S. Warren, Jr.'s Hacker's Delight, (Addison Wesley, 2002). Similar functionality for int and for BigInteger can be found in IntMath and BigIntegerMath respectively. For other common operations on long values, see Longs."
840,common/primitives,com.google.common.primitives,Class Longs,"Static utility methods pertaining to long primitives, that are not already found in either Long or Arrays. See the Guava User Guide article on primitive utilities."
841,common/collect,com.google.common.collect,"Interface MapDifference<K,V>",An object representing the differences between two maps.
842,common/collect,com.google.common.collect,Interface MapDifference.ValueDifference<V>,"A difference between the mappings from two maps with the same key. The leftValue() and rightValue() are not equal, and one but not both of them may be null."
843,common/collect,com.google.common.collect,Class MapMaker,"A builder of ConcurrentMap instances that can have keys or values automatically wrapped in weak references. Usage example: ConcurrentMap<Request, Stopwatch> timers = new MapMaker() .concurrencyLevel(4) .weakKeys() .makeMap(); These features are all optional; new MapMaker().makeMap() returns a valid concurrent map that behaves similarly to a ConcurrentHashMap. The returned map is implemented as a hash table with similar performance characteristics to ConcurrentHashMap. It supports all optional operations of the ConcurrentMap interface. It does not permit null keys or values. Note: by default, the returned map uses equality comparisons (the equals method) to determine equality for keys or values. However, if weakKeys() was specified, the map uses identity (==) comparisons instead for keys. Likewise, if weakValues() was specified, the map uses identity comparisons for values. The view collections of the returned map have weakly consistent iterators. This means that they are safe for concurrent use, but if other threads modify the map after the iterator is created, it is undefined which of these changes, if any, are reflected in that iterator. These iterators never throw ConcurrentModificationException. If weakKeys() or weakValues() are requested, it is possible for a key or value present in the map to be reclaimed by the garbage collector. Entries with reclaimed keys or values may be removed from the map on each map modification or on occasional map accesses; such entries may be counted by Map.size(), but will never be visible to read or write operations. A partially-reclaimed entry is never exposed to the user. Any Map.Entry instance retrieved from the map's entry set is a snapshot of that entry's state at the time of retrieval; such entries do, however, support Map.Entry#setValue, which simply calls Map.put(K, V) on the entry's key. The maps produced by MapMaker are serializable, and the deserialized maps retain all the configuration properties of the original map. During deserialization, if the original map had used weak references, the entries are reconstructed as they were, but it's not unlikely they'll be quickly garbage-collected before they are ever accessed. new MapMaker().weakKeys().makeMap() is a recommended replacement for WeakHashMap, but note that it compares keys using object identity whereas WeakHashMap uses Object.equals(java.lang.Object)."
844,common/collect,com.google.common.collect,Class Maps,"Static utility methods pertaining to Map instances (including instances of SortedMap, BiMap, etc.). Also see this class's counterparts Lists, Sets and Queues. See the Guava User Guide article on Maps."
845,common/collect,com.google.common.collect,"Interface Maps.EntryTransformer<K,V1,V2>","A transformation of the value of a key-value pair, using both key and value as inputs. To apply the transformation to a map, use Maps.transformEntries(Map, EntryTransformer)."
846,common/net,com.google.common.net,Class MediaType,"Represents an Internet Media Type (also known as a MIME Type or Content Type). This class also supports the concept of media ranges defined by HTTP/1.1. As such, the * character is treated as a wildcard and is used to represent any acceptable type or subtype value. A media type may not have wildcard type with a declared subtype. The * character has no special meaning as part of a parameter. All values for type, subtype, parameter attributes or parameter values must be valid according to RFCs 2045 and 2046. All portions of the media type that are case-insensitive (type, subtype, parameter attributes) are normalized to lowercase. The value of the charset parameter is normalized to lowercase, but all others are left as-is. Note that this specifically does not represent the value of the MIME Content-Type header and as such has no support for header-specific considerations such as line folding and comments. For media types that take a charset the predefined constants default to UTF-8 and have a ""_UTF_8"" suffix. To get a version without a character set, use withoutParameters()."
847,common/collect,com.google.common.collect,Class MinMaxPriorityQueue<E>,"A double-ended priority queue, which provides constant-time access to both its least element and its greatest element, as determined by the queue's specified comparator. If no comparator is given at creation time, the natural order of elements is used. If no maximum size is given at creation time, the queue is unbounded. Usage example: MinMaxPriorityQueue<User> users = MinMaxPriorityQueue.orderedBy(userComparator) .maximumSize(1000) .create(); As a Queue it functions exactly as a PriorityQueue: its head element -- the implicit target of the methods peek(), poll() and AbstractQueue.remove() -- is defined as the least element in the queue according to the queue's comparator. But unlike a regular priority queue, the methods peekLast(), pollLast() and removeLast() are also provided, to act on the greatest element in the queue instead. A min-max priority queue can be configured with a maximum size. If so, each time the size of the queue exceeds that value, the queue automatically removes its greatest element according to its comparator (which might be the element that was just added). This is different from conventional bounded queues, which either block or reject new elements when full. This implementation is based on the min-max heap developed by Atkinson, et al. Unlike many other double-ended priority queues, it stores elements in a single array, as compact as the traditional heap data structure used in PriorityQueue. This class is not thread-safe, and does not accept null elements. Performance notes:If you only access one end of the queue, and do use a maximum size, this class will perform significantly worse than a PriorityQueue with manual eviction above the maximum size. In many cases Ordering.leastOf(java.lang.Iterable<E>, int) may work for your use case with significantly improved (and asymptotically superior) performance. The retrieval operations peek(), peekFirst(), peekLast(), AbstractQueue.element(), and size are constant-time. The enqueuing and dequeuing operations (offer(E), add(E), and all the forms of poll() and AbstractQueue.remove()) run in O(log n) time. The AbstractCollection.remove(Object) and AbstractCollection.contains(java.lang.Object) operations require linear (O(n)) time. If you only access one end of the queue, and don't use a maximum size, this class is functionally equivalent to PriorityQueue, but significantly slower."
848,common/collect,com.google.common.collect,Class MinMaxPriorityQueue.Builder<B>,"The builder class used in creation of min-max priority queues. Instead of constructing one directly, use MinMaxPriorityQueue.orderedBy(Comparator), MinMaxPriorityQueue.expectedSize(int) or MinMaxPriorityQueue.maximumSize(int)."
849,util/concurrent,com.google.common.util.concurrent,Class Monitor,"A synchronization abstraction supporting waiting on arbitrary boolean conditions. This class is intended as a replacement for ReentrantLock. Code using Monitor is less error-prone and more readable than code using ReentrantLock, without significant performance loss. Monitor even has the potential for performance gain by optimizing the evaluation and signaling of conditions. Signaling is entirely implicit. By eliminating explicit signaling, this class can guarantee that only one thread is awakened when a condition becomes true (no ""signaling storms"" due to use of Condition.signalAll) and that no signals are lost (no ""hangs"" due to incorrect use of Condition.signal). A thread is said to occupy a monitor if it has entered the monitor but not yet left. Only one thread may occupy a given monitor at any moment. A monitor is also reentrant, so a thread may enter a monitor any number of times, and then must leave the same number of times. The enter and leave operations have the same synchronization semantics as the built-in Java language synchronization primitives. A call to any of the enter methods with void return type should always be followed immediately by a try/finally block to ensure that the current thread leaves the monitor cleanly: monitor.enter(); try { // do things while occupying the monitor } finally { monitor.leave(); } A call to any of the enter methods with boolean return type should always appear as the condition of an if statement containing a try/finally block to ensure that the current thread leaves the monitor cleanly: if (monitor.tryEnter()) { try { // do things while occupying the monitor } finally { monitor.leave(); } } else { // do other things since the monitor was not available } Comparison with synchronized and ReentrantLockThe following examples show a simple threadsafe holder expressed using synchronized, ReentrantLock, and Monitor. synchronizedThis version is the fewest lines of code, largely because the synchronization mechanism used is built into the language and runtime. But the programmer has to remember to avoid a couple of common bugs: The wait() must be inside a while instead of an if, and notifyAll() must be used instead of notify() because there are two different logical conditions being awaited. public class SafeBox<V> { private V value; public synchronized V get() throws InterruptedException { while (value == null) { wait(); } V result = value; value = null; notifyAll(); return result; } public synchronized void set(V newValue) throws InterruptedException { while (value != null) { wait(); } value = newValue; notifyAll(); } } ReentrantLockThis version is much more verbose than the synchronized version, and still suffers from the need for the programmer to remember to use while instead of if. However, one advantage is that we can introduce two separate Condition objects, which allows us to use signal() instead of signalAll(), which may be a performance benefit. public class SafeBox<V> { private V value; private final ReentrantLock lock = new ReentrantLock(); private final Condition valuePresent = lock.newCondition(); private final Condition valueAbsent = lock.newCondition(); public V get() throws InterruptedException { lock.lock(); try { while (value == null) { valuePresent.await(); } V result = value; value = null; valueAbsent.signal(); return result; } finally { lock.unlock(); } } public void set(V newValue) throws InterruptedException { lock.lock(); try { while (value != null) { valueAbsent.await(); } value = newValue; valuePresent.signal(); } finally { lock.unlock(); } } } MonitorThis version adds some verbosity around the Guard objects, but removes that same verbosity, and more, from the get and set methods. Monitor implements the same efficient signaling as we had to hand-code in the ReentrantLock version above. Finally, the programmer no longer has to hand-code the wait loop, and therefore doesn't have to remember to use while instead of if. public class SafeBox<V> { private V value; private final Monitor monitor = new Monitor(); private final Monitor.Guard valuePresent = monitor.newGuard(() -> value != null); private final Monitor.Guard valueAbsent = monitor.newGuard(() -> value == null); public V get() throws InterruptedException { monitor.enterWhen(valuePresent); try { V result = value; value = null; return result; } finally { monitor.leave(); } } public void set(V newValue) throws InterruptedException { monitor.enterWhen(valueAbsent); try { value = newValue; } finally { monitor.leave(); } } }"
850,util/concurrent,com.google.common.util.concurrent,Class Monitor.Guard,"A boolean condition for which a thread may wait. A Guard is associated with a single Monitor. The monitor may check the guard at arbitrary times from any thread occupying the monitor, so code should not be written to rely on how often a guard might or might not be checked. If a Guard is passed into any method of a Monitor other than the one it is associated with, an IllegalMonitorStateException is thrown."
851,common/collect,com.google.common.collect,Class MoreCollectors,Collectors not present in java.util.stream.Collectors that are not otherwise associated with a com.google.common type.
852,util/concurrent,com.google.common.util.concurrent,Class MoreExecutors,"Factory and utility methods for Executor, ExecutorService, and ThreadFactory."
853,common/io,com.google.common.io,Class MoreFiles,"Static utilities for use with Path instances, intended to complement Files. Many methods provided by Guava's Files class for File instances are now available via the JDK's Files class for Path - check the JDK's class if a sibling method from Files appears to be missing from this class."
854,common/base,com.google.common.base,Class MoreObjects,"Helper functions that operate on any Object, and are not already provided in Objects. See the Guava User Guide on writing Object methods with MoreObjects."
855,common/base,com.google.common.base,Class MoreObjects.ToStringHelper,Support class for MoreObjects.toStringHelper(java.lang.Object).
856,common/collect,com.google.common.collect,"Interface Multimap<K,V>","A collection that maps keys to values, similar to Map, but in which each key may be associated with multiple values. You can visualize the contents of a multimap either as a map from keys to nonempty collections of values: a → 1, 2 b → 3 ... or as a single ""flattened"" collection of key-value pairs: a → 1 a → 2 b → 3 Important: although the first interpretation resembles how most multimaps are implemented, the design of the Multimap API is based on the second form. So, using the multimap shown above as an example, the size() is 3, not 2, and the values() collection is [1, 2, 3], not [[1, 2], [3]]. For those times when the first style is more useful, use the multimap's asMap() view (or create a Map<K, Collection<V>> in the first place). ExampleThe following code: ListMultimap<String, String> multimap = ArrayListMultimap.create(); for (President pres : US_PRESIDENTS_IN_ORDER) { multimap.put(pres.firstName(), pres.lastName()); } for (String firstName : multimap.keySet()) { List<String> lastNames = multimap.get(firstName); out.println(firstName + "": "" + lastNames); } ... produces output such as: Zachary: [Taylor] John: [Adams, Adams, Tyler, Kennedy] // Remember, Quincy! George: [Washington, Bush, Bush] Grover: [Cleveland, Cleveland] // Two, non-consecutive terms, rep'ing NJ! ... ViewsMuch of the power of the multimap API comes from the view collections it provides. These always reflect the latest state of the multimap itself. When they support modification, the changes are write-through (they automatically update the backing multimap). These view collections are: asMap(), mentioned above keys(), keySet(), values(), entries(), which are similar to the corresponding view collections of Mapand, notably, even the collection returned by get(key) is an active view of the values corresponding to keyThe collections returned by the replaceValues and removeAll methods, which contain values that have just been removed from the multimap, are naturally not views. SubinterfacesInstead of using the Multimap interface directly, prefer the subinterfaces ListMultimap and SetMultimap. These take their names from the fact that the collections they return from get behave like (and, of course, implement) List and Set, respectively. For example, the ""presidents"" code snippet above used a ListMultimap; if it had used a SetMultimap instead, two presidents would have vanished, and last names might or might not appear in chronological order. Warning: instances of type Multimap may not implement Object.equals(java.lang.Object) in the way you expect. Multimaps containing the same key-value pairs, even in the same order, may or may not be equal and may or may not have the same hashCode. The recommended subinterfaces provide much stronger guarantees. Comparison to a map of collectionsMultimaps are commonly used in places where a Map<K, Collection<V>> would otherwise have appeared. The differences include: There is no need to populate an empty collection before adding an entry with put. get never returns null, only an empty collection. A key is contained in the multimap if and only if it maps to at least one value. Any operation that causes a key to have zero associated values has the effect of removing that key from the multimap. The total entry count is available as size(). Many complex operations become easier; for example, Collections.min(multimap.values()) finds the smallest value across all keys. ImplementationsAs always, prefer the immutable implementations, ImmutableListMultimap and ImmutableSetMultimap. General-purpose mutable implementations are listed above under ""All Known Implementing Classes"". You can also create a custom multimap, backed by any Map and Collection types, using the Multimaps.newMultimap family of methods. Finally, another popular way to obtain a multimap is using Multimaps.index. See the Multimaps class for these and other static utilities related to multimaps. Other NotesAs with Map, the behavior of a Multimap is not specified if key objects already present in the multimap change in a manner that affects equals comparisons. Use caution if mutable objects are used as keys in a Multimap. All methods that modify the multimap are optional. The view collections returned by the multimap may or may not be modifiable. Any modification method that is not supported will throw UnsupportedOperationException. See the Guava User Guide article on Multimap."
857,common/collect,com.google.common.collect,"Class MultimapBuilder<K0,V0>","A builder for a multimap implementation that allows customization of the backing map and value collection implementations used in a particular multimap. This can be used to easily configure multimap data structure implementations not provided explicitly in com.google.common.collect, for example: ListMultimap<String, Integer> treeListMultimap = MultimapBuilder.treeKeys().arrayListValues().build(); SetMultimap<Integer, MyEnum> hashEnumMultimap = MultimapBuilder.hashKeys().enumSetValues(MyEnum.class).build(); MultimapBuilder instances are immutable. Invoking a configuration method has no effect on the receiving instance; you must store and use the new builder instance it returns instead. The generated multimaps are serializable if the key and value types are serializable, unless stated otherwise in one of the configuration methods."
858,common/collect,com.google.common.collect,"Class MultimapBuilder.ListMultimapBuilder<K0,V0>",A specialization of MultimapBuilder that generates ListMultimap instances.
859,common/collect,com.google.common.collect,Class MultimapBuilder.MultimapBuilderWithKeys<K0>,"An intermediate stage in a MultimapBuilder in which the key-value collection map implementation has been specified, but the value collection implementation has not."
860,common/collect,com.google.common.collect,"Class MultimapBuilder.SetMultimapBuilder<K0,V0>",A specialization of MultimapBuilder that generates SetMultimap instances.
861,common/collect,com.google.common.collect,"Class MultimapBuilder.SortedSetMultimapBuilder<K0,V0>",A specialization of MultimapBuilder that generates SortedSetMultimap instances.
862,common/collect,com.google.common.collect,Class Multimaps,Provides static methods acting on or generating a Multimap. See the Guava User Guide article on Multimaps.
863,common/collect,com.google.common.collect,Interface Multiset<E>,"A collection that supports order-independent equality, like Set, but may have duplicate elements. A multiset is also sometimes called a bag. Elements of a multiset that are equal to one another are referred to as occurrences of the same single element. The total number of occurrences of an element in a multiset is called the count of that element (the terms ""frequency"" and ""multiplicity"" are equivalent, but not used in this API). Since the count of an element is represented as an int, a multiset may never contain more than Integer.MAX_VALUE occurrences of any one element. Multiset refines the specifications of several methods from Collection. It also defines an additional query operation, count(java.lang.Object), which returns the count of an element. There are five new bulk-modification operations, for example add(Object, int), to add or remove multiple occurrences of an element at once, or to set the count of an element to a specific value. These modification operations are optional, but implementations which support the standard collection operations add(Object) or remove(Object) are encouraged to implement the related methods as well. Finally, two collection views are provided: elementSet() contains the distinct elements of the multiset ""with duplicates collapsed"", and entrySet() is similar but contains Multiset.Entry instances, each providing both a distinct element and the count of that element. In addition to these required methods, implementations of Multiset are expected to provide two static creation methods: create(), returning an empty multiset, and create(Iterable<? extends E>), returning a multiset containing the given initial elements. This is simply a refinement of Collection's constructor recommendations, reflecting the new developments of Java 5. As with other collection types, the modification operations are optional, and should throw UnsupportedOperationException when they are not implemented. Most implementations should support either all add operations or none of them, all removal operations or none of them, and if and only if all of these are supported, the setCount methods as well. A multiset uses Object.equals(java.lang.Object) to determine whether two instances should be considered ""the same,"" unless specified otherwise by the implementation. Common implementations include ImmutableMultiset, HashMultiset, and ConcurrentHashMultiset. If your values may be zero, negative, or outside the range of an int, you may wish to use AtomicLongMap instead. Note, however, that unlike Multiset, AtomicLongMap does not automatically remove zeros. See the Guava User Guide article on Multiset."
864,common/collect,com.google.common.collect,Interface Multiset.Entry<E>,"An unmodifiable element-count pair for a multiset. The Multiset.entrySet() method returns a view of the multiset whose elements are of this class. A multiset implementation may return Entry instances that are either live ""read-through"" views to the Multiset, or immutable snapshots. Note that this type is unrelated to the similarly-named type Map.Entry."
865,common/collect,com.google.common.collect,Class Multisets,Provides static utility methods for creating and working with Multiset instances. See the Guava User Guide article on Multisets.
866,common/collect,com.google.common.collect,Class MutableClassToInstanceMap<B>,A mutable class-to-instance map backed by an arbitrary user-provided map. See also ImmutableClassToInstanceMap. See the Guava User Guide article on ClassToInstanceMap.
867,common/graph,com.google.common.graph,Interface MutableGraph<N>,"A subinterface of Graph which adds mutation methods. When mutation is not required, users should prefer the Graph interface."
868,common/graph,com.google.common.graph,"Interface MutableNetwork<N,E>","A subinterface of Network which adds mutation methods. When mutation is not required, users should prefer the Network interface."
869,common/reflect,com.google.common.reflect,Class MutableTypeToInstanceMap<B>,A mutable type-to-instance map. See also ImmutableTypeToInstanceMap.
870,common/graph,com.google.common.graph,"Interface MutableValueGraph<N,V>","A subinterface of ValueGraph which adds mutation methods. When mutation is not required, users should prefer the ValueGraph interface."
871,common/graph,com.google.common.graph,"Interface Network<N,E>","An interface for graph-structured data, whose edges are unique objects. A graph is composed of a set of nodes and a set of edges connecting pairs of nodes. There are three primary interfaces provided to represent graphs. In order of increasing complexity they are: Graph, ValueGraph, and Network. You should generally prefer the simplest interface that satisfies your use case. See the ""Choosing the right graph type"" section of the Guava User Guide for more details. CapabilitiesNetwork supports the following use cases (definitions of terms): directed graphs undirected graphs graphs that do/don't allow parallel edges graphs that do/don't allow self-loops graphs whose nodes/edges are insertion-ordered, sorted, or unordered graphs whose edges are unique objects Building a NetworkThe implementation classes that common.graph provides are not public, by design. To create an instance of one of the built-in implementations of Network, use the NetworkBuilder class: MutableNetwork<Integer, MyEdge> graph = NetworkBuilder.directed().build(); NetworkBuilder.build() returns an instance of MutableNetwork, which is a subtype of Network that provides methods for adding and removing nodes and edges. If you do not need to mutate a graph (e.g. if you write a method than runs a read-only algorithm on the graph), you should use the non-mutating Network interface, or an ImmutableNetwork. You can create an immutable copy of an existing Network using ImmutableNetwork.copyOf(Network): ImmutableNetwork<Integer, MyEdge> immutableGraph = ImmutableNetwork.copyOf(graph); Instances of ImmutableNetwork do not implement MutableNetwork (obviously!) and are contractually guaranteed to be unmodifiable and thread-safe. The Guava User Guide has more information on (and examples of) building graphs. Additional documentationSee the Guava User Guide for the common.graph package (""Graphs Explained"") for additional documentation, including: equals(), hashCode(), and graph equivalence Synchronization policyNotes for implementors"
872,common/graph,com.google.common.graph,"Class NetworkBuilder<N,E>","A builder for constructing instances of MutableNetwork or ImmutableNetwork with user-defined properties. A network built by this class will have the following properties by default: does not allow parallel edges does not allow self-loops orders Network.nodes() and Network.edges() in the order in which the elements were added Examples of use: // Building a mutable network MutableNetwork<String, Integer> network = NetworkBuilder.directed().allowsParallelEdges(true).build(); flightNetwork.addEdge(""LAX"", ""ATL"", 3025); flightNetwork.addEdge(""LAX"", ""ATL"", 1598); flightNetwork.addEdge(""ATL"", ""LAX"", 2450); // Building a immutable network ImmutableNetwork<String, Integer> immutableNetwork = NetworkBuilder.directed() .allowsParallelEdges(true) .<String, Integer>immutable() .addEdge(""LAX"", ""ATL"", 3025) .addEdge(""LAX"", ""ATL"", 1598) .addEdge(""ATL"", ""LAX"", 2450) .build();"
873,common/collect,com.google.common.collect,Class ObjectArrays,Static utility methods pertaining to object arrays.
874,common/base,com.google.common.base,Class Objects,Helper functions that can operate on any Object. See the Guava User Guide on writing Object methods with Objects.
875,common/base,com.google.common.base,Class Optional<T>,"An immutable object that may contain a non-null reference to another object. Each instance of this type either contains a non-null reference, or contains nothing (in which case we say that the reference is ""absent""); it is never said to ""contain null"". A non-null Optional<T> reference can be used as a replacement for a nullable T reference. It allows you to represent ""a T that must be present"" and a ""a T that might be absent"" as two distinct types in your program, which can aid clarity. Some uses of this class include As a method return type, as an alternative to returning null to indicate that no value was available To distinguish between ""unknown"" (for example, not present in a map) and ""known to have no value"" (present in the map, with value Optional.absent()) To wrap nullable references for storage in a collection that does not support null (though there are several other approaches to this that should be considered first) A common alternative to using this class is to find or create a suitable null object for the type in question. This class is not intended as a direct analogue of any existing ""option"" or ""maybe"" construct from other programming environments, though it may bear some similarities. Comparison to java.util.Optional (JDK 8 and higher): A new Optional class was added for Java 8. The two classes are extremely similar, but incompatible (they cannot share a common supertype). All known differences are listed either here or with the relevant methods below. This class is serializable; java.util.Optional is not. java.util.Optional has the additional methods ifPresent, filter, flatMap, and orElseThrow. java.util offers the primitive-specialized versions OptionalInt, OptionalLong and OptionalDouble, the use of which is recommended; Guava does not have these. There are no plans to deprecate this class in the foreseeable future. However, we do gently recommend that you prefer the new, standard Java class whenever possible. See the Guava User Guide article on using Optional."
876,common/collect,com.google.common.collect,Class Ordering<T>,"A comparator, with additional methods to support common operations. This is an ""enriched"" version of Comparator for pre-Java-8 users, in the same sense that FluentIterable is an enriched Iterable for pre-Java-8 users. Three types of methods Like other fluent types, there are three types of methods present: methods for acquiring, chaining, and using. AcquiringThe common ways to get an instance of Ordering are: Subclass it and implement compare(T, T) instead of implementing Comparator directly Pass a pre-existing Comparator instance to from(Comparator)Use the natural ordering, natural()ChainingThen you can use the chaining methods to get an altered version of that Ordering, including: reverse()compound(Comparator)onResultOf(Function)nullsFirst() / nullsLast()UsingFinally, use the resulting Ordering anywhere a Comparator is required, or use any of its special operations, such as: immutableSortedCopy(java.lang.Iterable<E>)isOrdered(java.lang.Iterable<? extends T>) / isStrictlyOrdered(java.lang.Iterable<? extends T>)min(java.util.Iterator<E>) / max(java.util.Iterator<E>)Understanding complex orderingsComplex chained orderings like the following example can be challenging to understand. Ordering<Foo> ordering = Ordering.natural() .nullsFirst() .onResultOf(getBarFunction) .nullsLast(); Note that each chaining method returns a new ordering instance which is backed by the previous instance, but has the chance to act on values before handing off to that backing instance. As a result, it usually helps to read chained ordering expressions backwards. For example, when compare is called on the above ordering: First, if only one Foo is null, that null value is treated as greaterNext, non-null Foo values are passed to getBarFunction (we will be comparing Bar values from now on) Next, if only one Bar is null, that null value is treated as lesserFinally, natural ordering is used (i.e. the result of Bar.compareTo(Bar) is returned) Alas, reverse() is a little different. As you read backwards through a chain and encounter a call to reverse, continue working backwards until a result is determined, and then reverse that result. Additional notesExcept as noted, the orderings returned by the factory methods of this class are serializable if and only if the provided instances that back them are. For example, if ordering and function can themselves be serialized, then ordering.onResultOf(function) can as well. For Java 8 usersIf you are using Java 8, this class is now obsolete. Most of its functionality is now provided by Stream and by Comparator itself, and the rest can now be found as static methods in our new Comparators class. See each method below for further instructions. Whenever possible, you should change any references of type Ordering to be of type Comparator instead. However, at this time we have no plan to deprecate this class. Many replacements involve adopting Stream, and these changes can sometimes make your code verbose. Whenever following this advice, you should check whether Stream could be adopted more comprehensively in your code; the end result may be quite a bit simpler. See alsoSee the Guava User Guide article on Ordering."
877,common/math,com.google.common.math,Class PairedStats,An immutable value object capturing some basic statistics about a collection of paired double values (e.g. points on a plane). Build instances with PairedStatsAccumulator.snapshot().
878,common/math,com.google.common.math,Class PairedStatsAccumulator,A mutable object which accumulates paired double values (e.g. points on a plane) and tracks some basic statistics over all the values added so far. This class is not thread safe.
879,common/reflect,com.google.common.reflect,Class Parameter,Represents a method or constructor parameter.
880,common/io,com.google.common.io,Class PatternFilenameFilter,File name filter that only accepts files matching a regular expression. This class is thread-safe and immutable.
881,common/collect,com.google.common.collect,Interface PeekingIterator<E>,An iterator that supports a one-element lookahead while iterating. See the Guava User Guide article on PeekingIterator.
882,common/net,com.google.common.net,Class PercentEscaper,"A UnicodeEscaper that escapes some set of Java characters using a UTF-8 based percent encoding scheme. The set of safe characters (those which remain unescaped) can be specified on construction. This class is primarily used for creating URI escapers in UrlEscapers but can be used directly if required. While URI escapers impose specific semantics on which characters are considered 'safe', this class has a minimal set of restrictions. When escaping a String, the following rules apply: All specified safe characters remain unchanged. If plusForSpace was specified, the space character "" "" is converted into a plus sign ""+"". All other characters are converted into one or more bytes using UTF-8 encoding and each byte is then represented by the 3-character string ""%XX"", where ""XX"" is the two-digit, uppercase, hexadecimal representation of the byte value. For performance reasons the only currently supported character encoding of this class is UTF-8. Note: This escaper produces uppercase hexadecimal sequences."
883,common/base,com.google.common.base,Class Preconditions,"Static convenience methods that help a method or constructor check whether it was invoked correctly (that is, whether its preconditions were met). If the precondition is not met, the Preconditions method throws an unchecked exception of a specified type, which helps the method in which the exception was thrown communicate that its caller has made a mistake. This allows constructs such as public static double sqrt(double value) { if (value < 0) { throw new IllegalArgumentException(""input is negative: "" + value); } // calculate square root } to be replaced with the more compact public static double sqrt(double value) { checkArgument(value >= 0, ""input is negative: %s"", value); // calculate square root } so that a hypothetical bad caller of this method, such as: void exampleBadCaller() { double d = sqrt(-1.0); } would be flagged as having called sqrt() with an illegal argument. PerformanceAvoid passing message arguments that are expensive to compute; your code will always compute them, even though they usually won't be needed. If you have such arguments, use the conventional if/throw idiom instead. Depending on your message arguments, memory may be allocated for boxing and varargs array creation. However, the methods of this class have a large number of overloads that prevent such allocations in many common cases. The message string is not formatted unless the exception will be thrown, so the cost of the string formatting itself should not be a concern. As with any performance concerns, you should consider profiling your code (in a production environment if possible) before spending a lot of effort on tweaking a particular element. Other types of preconditionsNot every type of precondition failure is supported by these methods. Continue to throw standard JDK exceptions such as NoSuchElementException or UnsupportedOperationException in the situations they are intended for. Non-preconditionsIt is of course possible to use the methods of this class to check for invalid conditions which are not the caller's fault. Doing so is not recommended because it is misleading to future readers of the code and of stack traces. See Conditional failures explained in the Guava User Guide for more advice. Notably, Verify offers assertions similar to those in this class for non-precondition checks. java.util.Objects.requireNonNull()Projects which use com.google.common should generally avoid the use of Objects.requireNonNull(Object). Instead, use whichever of checkNotNull(Object) or Verify.verifyNotNull(Object) is appropriate to the situation. (The same goes for the message-accepting overloads.) Only %s is supportedPreconditions uses Strings.lenientFormat(java.lang.String, java.lang.Object...) to format error message template strings. This only supports the ""%s"" specifier, not the full range of Formatter specifiers. However, note that if the number of arguments does not match the number of occurrences of ""%s"" in the format string, Preconditions will still behave as expected, and will still include all argument values in the error message; the message will simply not be formatted exactly as intended. More informationSee the Guava User Guide on using Preconditions."
884,common/graph,com.google.common.graph,Interface PredecessorsFunction<N>,"A functional interface for graph-structured data. This interface is meant to be used as the type of a parameter to graph algorithms (such as topological sort) that only need a way of accessing the predecessors of a node in a graph. Usage Given an algorithm, for example: public <N> someGraphAlgorithm(N startNode, PredecessorsFunction<N> predecessorsFunction); you will invoke it depending on the graph representation you're using. If you have an instance of one of the primary common.graph types (Graph, ValueGraph, and Network): someGraphAlgorithm(startNode, graph); This works because those types each implement PredecessorsFunction. It will also work with any other implementation of this interface. If you have your own graph implementation based around a custom node type MyNode, which has a method getParents() that retrieves its predecessors in a graph: someGraphAlgorithm(startNode, MyNode::getParents); If you have some other mechanism for returning the predecessors of a node, or one that doesn't return a Iterable<? extends N>, then you can use a lambda to perform a more general transformation: someGraphAlgorithm(startNode, node -> ImmutableList.of(node.mother(), node.father())); Graph algorithms that need additional capabilities (accessing both predecessors and successors, iterating over the edges, etc.) should declare their input to be of a type that provides those capabilities, such as Graph, ValueGraph, or Network. Additional documentationSee the Guava User Guide for the common.graph package (""Graphs Explained"") for additional documentation, including notes for implementors"
885,common/base,com.google.common.base,Interface Predicate<T>,"Legacy version of java.util.function.Predicate. Determines a true or false value for a given input. As this interface extends java.util.function.Predicate, an instance of this type may be used as a Predicate directly. To use a java.util.function.Predicate where a com.google.common.base.Predicate is expected, use the method reference predicate::test. This interface is now a legacy type. Use java.util.function.Predicate (or the appropriate primitive specialization such as IntPredicate) instead whenever possible. Otherwise, at least reduce explicit dependencies on this type by using lambda expressions or method references instead of classes, leaving your code easier to migrate in the future. The Predicates class provides common predicates and related utilities. See the Guava User Guide article on the use of Predicate."
886,common/base,com.google.common.base,Class Predicates,Static utility methods pertaining to Predicate instances. All methods return serializable predicates as long as they're given serializable parameters. See the Guava User Guide article on the use of Predicate.
887,common/primitives,com.google.common.primitives,Class Primitives,Contains static utility methods pertaining to primitive types and their corresponding wrapper types.
888,common/hash,com.google.common.hash,Interface PrimitiveSink,An object which can receive a stream of primitive values.
889,common/math,com.google.common.math,Class Quantiles,"Provides a fluent API for calculating quantiles. ExamplesTo compute the median: double myMedian = median().compute(myDataset); where median() has been statically imported. To compute the 99th percentile: double myPercentile99 = percentiles().index(99).compute(myDataset); where percentiles() has been statically imported. To compute median and the 90th and 99th percentiles: Map<Integer, Double> myPercentiles = percentiles().indexes(50, 90, 99).compute(myDataset); where percentiles() has been statically imported: myPercentiles maps the keys 50, 90, and 99, to their corresponding quantile values. To compute quartiles, use quartiles() instead of percentiles(). To compute arbitrary q-quantiles, use scale(q). These examples all take a copy of your dataset. If you have a double array, you are okay with it being arbitrarily reordered, and you want to avoid that copy, you can use computeInPlace instead of compute. Definition and notes on interpolationThe definition of the kth q-quantile of N values is as follows: define x = k * (N - 1) / q; if x is an integer, the result is the value which would appear at index x in the sorted dataset (unless there are NaN values, see below); otherwise, the result is the average of the values which would appear at the indexes floor(x) and ceil(x) weighted by (1-frac(x)) and frac(x) respectively. This is the same definition as used by Excel and by S, it is the Type 7 definition in R, and it is described by wikipedia as providing ""Linear interpolation of the modes for the order statistics for the uniform distribution on [0,1]."" Handling of non-finite valuesIf any values in the input are NaN then all values returned are NaN. (This is the one occasion when the behaviour is not the same as you'd get from sorting with Arrays.sort(double[]) or Collections.sort(List<Double>) and selecting the required value(s). Those methods would sort NaN as if it is greater than any other value and place them at the end of the dataset, even after POSITIVE_INFINITY.) Otherwise, NEGATIVE_INFINITY and POSITIVE_INFINITY sort to the beginning and the end of the dataset, as you would expect. If required to do a weighted average between an infinity and a finite value, or between an infinite value and itself, the infinite value is returned. If required to do a weighted average between NEGATIVE_INFINITY and POSITIVE_INFINITY, NaN is returned (note that this will only happen if the dataset contains no finite values). PerformanceThe average time complexity of the computation is O(N) in the size of the dataset. There is a worst case time complexity of O(N^2). You are extremely unlikely to hit this quadratic case on randomly ordered data (the probability decreases faster than exponentially in N), but if you are passing in unsanitized user data then a malicious user could force it. A light shuffle of the data using an unpredictable seed should normally be enough to thwart this attack. The time taken to compute multiple quantiles on the same dataset using indexes is generally less than the total time taken to compute each of them separately, and sometimes much less. For example, on a large enough dataset, computing the 90th and 99th percentiles together takes about 55% as long as computing them separately. When calling Quantiles.ScaleAndIndex.compute(java.util.Collection<? extends java.lang.Number>) (in either form), the memory requirement is 8*N bytes for the copy of the dataset plus an overhead which is independent of N (but depends on the quantiles being computed). When calling computeInPlace (in either form), only the overhead is required. The number of object allocations is independent of N in both cases."
890,common/math,com.google.common.math,Class Quantiles.Scale,Describes the point in a fluent API chain where only the scale (i.e. the q in q-quantiles) has been specified.
891,common/math,com.google.common.math,Class Quantiles.ScaleAndIndex,Describes the point in a fluent API chain where the scale and a single quantile index (i.e. the q and the k in the kth q-quantile) have been specified.
892,common/math,com.google.common.math,Class Quantiles.ScaleAndIndexes,Describes the point in a fluent API chain where the scale and a multiple quantile indexes (i.e. the q and a set of values for the k in the kth q-quantile) have been specified.
893,common/collect,com.google.common.collect,Class Queues,"Static utility methods pertaining to Queue and Deque instances. Also see this class's counterparts Lists, Sets, and Maps."
894,common/collect,com.google.common.collect,Class Range<C extends Comparable>,"A range (or ""interval"") defines the boundaries around a contiguous span of values of some Comparable type; for example, ""integers from 1 to 100 inclusive."" Note that it is not possible to iterate over these contained values. To do so, pass this range instance and an appropriate DiscreteDomain to ContiguousSet.create(com.google.common.collect.Range<C>, com.google.common.collect.DiscreteDomain<C>). Types of rangesEach end of the range may be bounded or unbounded. If bounded, there is an associated endpoint value, and the range is considered to be either open (does not include the endpoint) or closed (includes the endpoint) on that side. With three possibilities on each side, this yields nine basic types of ranges, enumerated below. (Notation: a square bracket ([ ]) indicates that the range is closed on that side; a parenthesis (( )) means it is either open or unbounded. The construct {x | statement} is read ""the set of all x such that statement."") Range TypesNotation Definition Factory method (a..b) {x | a < x < b} open[a..b] {x | a <= x <= b}closed(a..b] {x | a < x <= b} openClosed[a..b) {x | a <= x < b} closedOpen(a..+∞) {x | x > a} greaterThan[a..+∞) {x | x >= a} atLeast(-∞..b) {x | x < b} lessThan(-∞..b] {x | x <= b} atMost(-∞..+∞){x} allWhen both endpoints exist, the upper endpoint may not be less than the lower. The endpoints may be equal only if at least one of the bounds is closed: [a..a] : a singleton range [a..a); (a..a] : empty ranges; also valid (a..a) : invalid; an exception will be thrown WarningsUse immutable value types only, if at all possible. If you must use a mutable type, do not allow the endpoint instances to mutate after the range is created! Your value type's comparison method should be consistent with equals if at all possible. Otherwise, be aware that concepts used throughout this documentation such as ""equal"", ""same"", ""unique"" and so on actually refer to whether compareTo returns zero, not whether equals returns true. A class which implements Comparable<UnrelatedType> is very broken, and will cause undefined horrible things to happen in Range. For now, the Range API does not prevent its use, because this would also rule out all ungenerified (pre-JDK1.5) data types. This may change in the future.Other notesAll ranges are shallow-immutable. Instances of this type are obtained using the static factory methods in this class. Ranges are convex: whenever two values are contained, all values in between them must also be contained. More formally, for any c1 <= c2 <= c3 of type C, r.contains(c1) && r.contains(c3) implies r.contains(c2)). This means that a Range<Integer> can never be used to represent, say, ""all prime numbers from 1 to 100."" When evaluated as a Predicate, a range yields the same result as invoking contains(C). Terminology note: a range a is said to be the maximal range having property P if, for all ranges b also having property P, a.encloses(b). Likewise, a is minimal when b.encloses(a) for all b having property P. See, for example, the definition of intersection. Further readingSee the Guava User Guide article on Range."
895,common/collect,com.google.common.collect,"Interface RangeMap<K extends Comparable,V>","A mapping from disjoint nonempty ranges to non-null values. Queries look up the value associated with the range (if any) that contains a specified key. In contrast to RangeSet, no ""coalescing"" is done of connected ranges, even if they are mapped to the same value."
896,common/collect,com.google.common.collect,Interface RangeSet<C extends Comparable>,"A set comprising zero or more nonempty, disconnected ranges of type C. Implementations that choose to support the add(Range) operation are required to ignore empty ranges and coalesce connected ranges. For example: RangeSet<Integer> rangeSet = TreeRangeSet.create(); rangeSet.add(Range.closed(1, 10)); // {[1, 10]} rangeSet.add(Range.closedOpen(11, 15)); // disconnected range; {[1, 10], [11, 15)} rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)} rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)} rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)} Note that the behavior of Range.isEmpty() and Range.isConnected(Range) may not be as expected on discrete ranges. See the Javadoc of those methods for details. For a Set whose contents are specified by a Range, see ContiguousSet. See the Guava User Guide article on RangeSets."
897,util/concurrent,com.google.common.util.concurrent,Class RateLimiter,"A rate limiter. Conceptually, a rate limiter distributes permits at a configurable rate. Each acquire() blocks if necessary until a permit is available, and then takes it. Once acquired, permits need not be released. RateLimiter is safe for concurrent use: It will restrict the total rate of calls from all threads. Note, however, that it does not guarantee fairness. Rate limiters are often used to restrict the rate at which some physical or logical resource is accessed. This is in contrast to Semaphore which restricts the number of concurrent accesses instead of the rate (note though that concurrency and rate are closely related, e.g. see Little's Law). A RateLimiter is defined primarily by the rate at which permits are issued. Absent additional configuration, permits will be distributed at a fixed rate, defined in terms of permits per second. Permits will be distributed smoothly, with the delay between individual permits being adjusted to ensure that the configured rate is maintained. It is possible to configure a RateLimiter to have a warmup period during which time the permits issued each second steadily increases until it hits the stable rate. As an example, imagine that we have a list of tasks to execute, but we don't want to submit more than 2 per second: final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is ""2 permits per second"" void submitTasks(List<Runnable> tasks, Executor executor) { for (Runnable task : tasks) { rateLimiter.acquire(); // may wait executor.execute(task); } } As another example, imagine that we produce a stream of data, and we want to cap it at 5kb per second. This could be accomplished by requiring a permit per byte, and specifying a rate of 5000 permits per second: final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second void submitPacket(byte[] packet) { rateLimiter.acquire(packet.length); networkService.send(packet); } It is important to note that the number of permits requested never affects the throttling of the request itself (an invocation to acquire(1) and an invocation to acquire(1000) will result in exactly the same throttling, if any), but it affects the throttling of the next request. I.e., if an expensive task arrives at an idle RateLimiter, it will be granted immediately, but it is the next request that will experience extra throttling, thus paying for the cost of the expensive task."
898,common/io,com.google.common.io,Enum RecursiveDeleteOption,"Options for use with recursive delete methods (MoreFiles.deleteRecursively(java.nio.file.Path, com.google.common.io.RecursiveDeleteOption...) and MoreFiles.deleteDirectoryContents(java.nio.file.Path, com.google.common.io.RecursiveDeleteOption...))."
899,common/reflect,com.google.common.reflect,Class Reflection,Static utilities relating to Java reflection.
900,common/cache,com.google.common.cache,Enum RemovalCause,The reason why a cached entry was removed.
901,common/cache,com.google.common.cache,"Interface RemovalListener<K,V>","An object that can receive a notification when an entry is removed from a cache. The removal resulting in notification could have occurred to an entry being manually removed or replaced, or due to eviction resulting from timed expiration, exceeding a maximum size, or garbage collection. An instance may be called concurrently by multiple threads to process different entries. Implementations of this interface should avoid performing blocking calls or synchronizing on shared resources."
902,common/cache,com.google.common.cache,Class RemovalListeners,A collection of common removal listeners.
903,common/cache,com.google.common.cache,"Class RemovalNotification<K,V>","A notification of the removal of a single entry. The key and/or value may be null if they were already garbage collected. Like other Entry instances associated with CacheBuilder, this class holds strong references to the key and value, regardless of the type of references the cache may be using."
904,common/io,com.google.common.io,Class Resources,"Provides utility methods for working with resources in the classpath. Note that even though these methods use URL parameters, they are usually not appropriate for HTTP or other non-classpath resources. All method parameters must be non-null unless documented otherwise."
905,common/collect,com.google.common.collect,"Interface RowSortedTable<R,C,V>","Interface that extends Table and whose rows are sorted. The rowKeySet() method returns a SortedSet and the rowMap() method returns a SortedMap, instead of the Set and Map specified by the Table interface."
906,util/concurrent,com.google.common.util.concurrent,Class Runnables,Static utility methods pertaining to the Runnable interface.
907,util/concurrent,com.google.common.util.concurrent,Interface Service,"An object with an operational state, plus asynchronous startAsync() and stopAsync() lifecycle methods to transition between states. Example services include webservers, RPC servers and timers. The normal lifecycle of a service is: NEW -> STARTING -> RUNNING -> STOPPING -> TERMINATEDThere are deviations from this if there are failures or if stopAsync() is called before the Service reaches the RUNNING state. The set of legal transitions form a DAG, therefore every method of the listener will be called at most once. N.B. The Service.State.FAILED and Service.State.TERMINATED states are terminal states, once a service enters either of these states it cannot ever leave them. Implementors of this interface are strongly encouraged to extend one of the abstract classes in this package which implement this interface and make the threading and state management easier."
908,util/concurrent,com.google.common.util.concurrent,Class Service.Listener,"A listener for the various state changes that a Service goes through in its lifecycle. All methods are no-ops by default, implementors should override the ones they care about."
909,util/concurrent,com.google.common.util.concurrent,Enum Service.State,"The lifecycle states of a service. The ordering of the Service.State enum is defined such that if there is a state transition from A -> B then A.compareTo(B) < 0. N.B. The converse is not true, i.e. if A.compareTo(B) < 0 then there is not guaranteed to be a valid state transition A -> B."
910,util/concurrent,com.google.common.util.concurrent,Class ServiceManager,"A manager for monitoring and controlling a set of services. This class provides methods for starting, stopping and inspecting a collection of services. Additionally, users can monitor state transitions with the listener mechanism. While it is recommended that service lifecycles be managed via this class, state transitions initiated via other mechanisms do not impact the correctness of its methods. For example, if the services are started by some mechanism besides startAsync(), the listeners will be invoked when appropriate and awaitHealthy() will still work as expected. Here is a simple example of how to use a ServiceManager to start a server. class Server { public static void main(String[] args) { Set<Service> services = ...; ServiceManager manager = new ServiceManager(services); manager.addListener(new Listener() { public void stopped() {} public void healthy() { // Services have been initialized and are healthy, start accepting requests... } public void failure(Service service) { // Something failed, at this point we could log it, notify a load balancer, or take // some other action. For now we will just exit. System.exit(1); } }, MoreExecutors.directExecutor()); Runtime.getRuntime().addShutdownHook(new Thread() { public void run() { // Give the services 5 seconds to stop to ensure that we are responsive to shutdown // requests. try { manager.stopAsync().awaitStopped(5, TimeUnit.SECONDS); } catch (TimeoutException timeout) { // stopping timed out } } }); manager.startAsync(); // start all the services asynchronously } } This class uses the ServiceManager's methods to start all of its services, to respond to service failure and to ensure that when the JVM is shutting down all the services are stopped."
911,util/concurrent,com.google.common.util.concurrent,Class ServiceManager.Listener,"A listener for the aggregate state changes of the services that are under management. Users that need to listen to more fine-grained events (such as when each particular service starts, or terminates), should attach service listeners to each individual service."
912,common/collect,com.google.common.collect,"Interface SetMultimap<K,V>","A Multimap that cannot hold duplicate key-value pairs. Adding a key-value pair that's already in the multimap has no effect. See the Multimap documentation for information common to all multimaps. The get(K), removeAll(java.lang.Object), and replaceValues(K, java.lang.Iterable<? extends V>) methods each return a Set of values, while entries() returns a Set of map entries. Though the method signature doesn't say so explicitly, the map returned by asMap() has Set values. If the values corresponding to a single key should be ordered according to a Comparator (or the natural order), see the SortedSetMultimap subinterface. Since the value collections are sets, the behavior of a SetMultimap is not specified if key or value objects already present in the multimap change in a manner that affects equals comparisons. Use caution if mutable objects are used as keys or values in a SetMultimap. See the Guava User Guide article on Multimap."
913,common/collect,com.google.common.collect,Class Sets,"Static utility methods pertaining to Set instances. Also see this class's counterparts Lists, Maps and Queues. See the Guava User Guide article on Sets."
914,common/collect,com.google.common.collect,Class Sets.SetView<E>,"An unmodifiable view of a set which may be backed by other sets; this view will change as the backing sets do. Contains methods to copy the data into a new set which will then remain stable. There is usually no reason to retain a reference of type SetView; typically, you either use it as a plain Set, or immediately invoke immutableCopy() or copyInto(S) and forget the SetView itself."
915,util/concurrent,com.google.common.util.concurrent,Class SettableFuture<V>,"A ListenableFuture whose result can be set by a set(Object), setException(Throwable) or setFuture(ListenableFuture) call. It can also, like any other Future, be cancelled. SettableFuture is the recommended ListenableFuture implementation when your task cannot be implemented with ListeningExecutorService, the various Futures utility methods, or ListenableFutureTask. Those APIs have less opportunity for developer error. If your needs are more complex than SettableFuture supports, use AbstractFuture, which offers an extensible version of the API."
916,common/primitives,com.google.common.primitives,Class Shorts,"Static utility methods pertaining to short primitives, that are not already found in either Short or Arrays. See the Guava User Guide article on primitive utilities."
917,common/primitives,com.google.common.primitives,Class SignedBytes,"Static utility methods pertaining to byte primitives that interpret values as signed. The corresponding methods that treat the values as unsigned are found in UnsignedBytes, and the methods for which signedness is not an issue are in Bytes. See the Guava User Guide article on primitive utilities."
918,util/concurrent,com.google.common.util.concurrent,Class SimpleTimeLimiter,"A TimeLimiter that runs method calls in the background using an ExecutorService. If the time limit expires for a given method call, the thread running the call will be interrupted."
919,common/collect,com.google.common.collect,"Interface SortedMapDifference<K,V>",An object representing the differences between two sorted maps.
920,common/collect,com.google.common.collect,Interface SortedMultiset<E>,"A Multiset which maintains the ordering of its elements, according to either their natural order or an explicit Comparator. This order is reflected when iterating over the sorted multiset, either directly, or through its elementSet or entrySet views. In all cases, this implementation uses Comparable.compareTo(T) or Comparator.compare(T, T) instead of Object.equals(java.lang.Object) to determine equivalence of instances. Warning: The comparison must be consistent with equals as explained by the Comparable class specification. Otherwise, the resulting multiset will violate the Collection contract, which is specified in terms of Object.equals(java.lang.Object). See the Guava User Guide article on Multiset."
921,common/collect,com.google.common.collect,"Interface SortedSetMultimap<K,V>","A SetMultimap whose set of values for a given key are kept sorted; that is, they comprise a SortedSet. It cannot hold duplicate key-value pairs; adding a key-value pair that's already in the multimap has no effect. This interface does not specify the ordering of the multimap's keys. See the Multimap documentation for information common to all multimaps. The get(K), removeAll(java.lang.Object), and replaceValues(K, java.lang.Iterable<? extends V>) methods each return a SortedSet of values, while Multimap.entries() returns a Set of map entries. Though the method signature doesn't say so explicitly, the map returned by asMap() has SortedSet values. See the Guava User Guide article on Multimap."
922,common/base,com.google.common.base,Class Splitter,"Extracts non-overlapping substrings from an input string, typically by recognizing appearances of a separator sequence. This separator can be specified as a single character, fixed string, regular expression or CharMatcher instance. Or, instead of using a separator at all, a splitter can extract adjacent substrings of a given fixed length. For example, this expression: Splitter.on(',').split(""foo,bar,qux"") ... produces an Iterable containing ""foo"", ""bar"" and ""qux"", in that order. By default, Splitter's behavior is simplistic and unassuming. The following expression: Splitter.on(',').split("" foo,,, bar ,"") ... yields the substrings ["" foo"", """", """", "" bar "", """"]. If this is not the desired behavior, use configuration methods to obtain a new splitter instance with modified behavior: private static final Splitter MY_SPLITTER = Splitter.on(',') .trimResults() .omitEmptyStrings(); Now MY_SPLITTER.split(""foo,,, bar ,"") returns just [""foo"", ""bar""]. Note that the order in which these configuration methods are called is never significant. Warning: Splitter instances are immutable. Invoking a configuration method has no effect on the receiving instance; you must store and use the new splitter instance it returns instead. // Do NOT do this Splitter splitter = Splitter.on('/'); splitter.trimResults(); // does nothing! return splitter.split(""wrong / wrong / wrong""); For separator-based splitters that do not use omitEmptyStrings, an input string containing n occurrences of the separator naturally yields an iterable of size n + 1. So if the separator does not occur anywhere in the input, a single substring is returned containing the entire input. Consequently, all splitters split the empty string to [""""] (note: even fixed-length splitters). Splitter instances are thread-safe immutable, and are therefore safe to store as static final constants. The Joiner class provides the inverse operation to splitting, but note that a round-trip between the two should be assumed to be lossy. See the Guava User Guide article on Splitter."
923,common/base,com.google.common.base,Class Splitter.MapSplitter,"An object that splits strings into maps as Splitter splits iterables and lists. Like Splitter, it is thread-safe and immutable. The common way to build instances is by providing an additional key-value separator to Splitter."
924,common/base,com.google.common.base,Enum StandardSystemProperty,Represents a standard system property.
925,common/math,com.google.common.math,Class Stats,"A bundle of statistical summary values -- sum, count, mean/average, min and max, and several forms of variance -- that were computed from a single set of zero or more floating-point values. There are two ways to obtain a Stats instance: If all the values you want to summarize are already known, use the appropriate Stats.of factory method below. Primitive arrays, iterables and iterators of any kind of Number, and primitive varargs are supported. Or, to avoid storing up all the data first, create a StatsAccumulator instance, feed values to it as you get them, then call StatsAccumulator.snapshot(). Static convenience methods called meanOf are also provided for users who wish to calculate only the mean. Java 8 users: If you are not using any of the variance statistics, you may wish to use built-in JDK libraries instead of this class."
926,common/math,com.google.common.math,Class StatsAccumulator,A mutable object which accumulates double values and tracks some basic statistics over all the values added so far. The values may be added singly or in groups. This class is not thread safe.
927,common/base,com.google.common.base,Class Stopwatch,"An object that accurately measures elapsed time: the measured duration between two successive readings of ""now"" in the same process. In contrast, wall time is a reading of ""now"" as given by a method like System.currentTimeMillis(), best represented as an Instant. Such values can be subtracted to obtain a Duration (such as by Duration.between), but doing so does not give a reliable measurement of elapsed time, because wall time readings are inherently approximate, routinely affected by periodic clock corrections. Because this class (by default) uses System.nanoTime(), it is unaffected by these changes. Use this class instead of direct calls to System.nanoTime() for two reasons: The raw long values returned by nanoTime are meaningless and unsafe to use in any other way than how Stopwatch uses them. An alternative source of nanosecond ticks can be substituted, for example for testing or performance reasons, without affecting most of your code. Basic usage: Stopwatch stopwatch = Stopwatch.createStarted(); doSomething(); stopwatch.stop(); // optional Duration duration = stopwatch.elapsed(); log.info(""time: "" + stopwatch); // formatted string like ""12.3 ms"" The state-changing methods are not idempotent; it is an error to start or stop a stopwatch that is already in the desired state. When testing code that uses this class, use createUnstarted(Ticker) or createStarted(Ticker) to supply a fake or mock ticker. This allows you to simulate any valid behavior of the stopwatch. Note: This class is not thread-safe. Warning for Android users: a stopwatch with default behavior may not continue to keep time while the device is asleep. Instead, create one like this: Stopwatch.createStarted( new Ticker() { public long read() { return android.os.SystemClock.elapsedRealtimeNanos(); } });"
928,common/collect,com.google.common.collect,Class Streams,Static utility methods related to Stream instances.
929,common/collect,com.google.common.collect,Interface Streams.DoubleFunctionWithIndex<R>,"An analogue of DoubleFunction also accepting an index. This interface is only intended for use by callers of Streams.mapWithIndex(DoubleStream, DoubleFunctionWithIndex)."
930,common/collect,com.google.common.collect,"Interface Streams.FunctionWithIndex<T,R>","An analogue of Function also accepting an index. This interface is only intended for use by callers of Streams.mapWithIndex(Stream, FunctionWithIndex)."
931,common/collect,com.google.common.collect,Interface Streams.IntFunctionWithIndex<R>,"An analogue of IntFunction also accepting an index. This interface is only intended for use by callers of Streams.mapWithIndex(IntStream, IntFunctionWithIndex)."
932,common/collect,com.google.common.collect,Interface Streams.LongFunctionWithIndex<R>,"An analogue of LongFunction also accepting an index. This interface is only intended for use by callers of Streams.mapWithIndex(LongStream, LongFunctionWithIndex)."
933,common/base,com.google.common.base,Class Strings,Static utility methods pertaining to String or CharSequence instances.
934,util/concurrent,com.google.common.util.concurrent,Class Striped<L>,"A striped Lock/Semaphore/ReadWriteLock. This offers the underlying lock striping similar to that of ConcurrentHashMap in a reusable form, and extends it for semaphores and read-write locks. Conceptually, lock striping is the technique of dividing a lock into many stripes, increasing the granularity of a single lock and allowing independent operations to lock different stripes and proceed concurrently, instead of creating contention for a single lock. The guarantee provided by this class is that equal keys lead to the same lock (or semaphore), i.e. if (key1.equals(key2)) then striped.get(key1) == striped.get(key2) (assuming Object.hashCode() is correctly implemented for the keys). Note that if key1 is not equal to key2, it is not guaranteed that striped.get(key1) != striped.get(key2); the elements might nevertheless be mapped to the same lock. The lower the number of stripes, the higher the probability of this happening. There are three flavors of this class: Striped<Lock>, Striped<Semaphore>, and Striped<ReadWriteLock>. For each type, two implementations are offered: strong and weak Striped<Lock>, strong and weak Striped<Semaphore>, and strong and weak Striped<ReadWriteLock>. Strong means that all stripes (locks/semaphores) are initialized eagerly, and are not reclaimed unless Striped itself is reclaimable. Weak means that locks/semaphores are created lazily, and they are allowed to be reclaimed if nobody is holding on to them. This is useful, for example, if one wants to create a Striped<Lock> of many locks, but worries that in most cases only a small portion of these would be in use. Prior to this class, one might be tempted to use Map<K, Lock>, where K represents the task. This maximizes concurrency by having each unique key mapped to a unique lock, but also maximizes memory footprint. On the other extreme, one could use a single lock for all tasks, which minimizes memory footprint but also minimizes concurrency. Instead of choosing either of these extremes, Striped allows the user to trade between required concurrency and memory footprint. For example, if a set of tasks are CPU-bound, one could easily create a very compact Striped<Lock> of availableProcessors() * 4 stripes, instead of possibly thousands of locks which could be created in a Map<K, Lock> structure."
935,common/eventbus,com.google.common.eventbus,Annotation Type Subscribe,"Marks a method as an event subscriber. The type of event will be indicated by the method's first (and only) parameter, which cannot be primitive. If this annotation is applied to methods with zero parameters, or more than one parameter, the object containing the method will not be able to register for event delivery from the EventBus. Unless also annotated with @AllowConcurrentEvents, event subscriber methods will be invoked serially by each event bus that they are registered with."
936,common/eventbus,com.google.common.eventbus,Class SubscriberExceptionContext,Context for an exception thrown by a subscriber.
937,common/eventbus,com.google.common.eventbus,Interface SubscriberExceptionHandler,Handler for exceptions thrown by event subscribers.
938,common/graph,com.google.common.graph,Interface SuccessorsFunction<N>,"A functional interface for graph-structured data. This interface is meant to be used as the type of a parameter to graph algorithms (such as breadth first traversal) that only need a way of accessing the successors of a node in a graph. Usage Given an algorithm, for example: public <N> someGraphAlgorithm(N startNode, SuccessorsFunction<N> successorsFunction); you will invoke it depending on the graph representation you're using. If you have an instance of one of the primary common.graph types (Graph, ValueGraph, and Network): someGraphAlgorithm(startNode, graph); This works because those types each implement SuccessorsFunction. It will also work with any other implementation of this interface. If you have your own graph implementation based around a custom node type MyNode, which has a method getChildren() that retrieves its successors in a graph: someGraphAlgorithm(startNode, MyNode::getChildren); If you have some other mechanism for returning the successors of a node, or one that doesn't return an Iterable<? extends N>, then you can use a lambda to perform a more general transformation: someGraphAlgorithm(startNode, node -> ImmutableList.of(node.leftChild(), node.rightChild())); Graph algorithms that need additional capabilities (accessing both predecessors and successors, iterating over the edges, etc.) should declare their input to be of a type that provides those capabilities, such as Graph, ValueGraph, or Network. Additional documentationSee the Guava User Guide for the common.graph package (""Graphs Explained"") for additional documentation, including notes for implementors"
939,common/base,com.google.common.base,Interface Supplier<T>,"Legacy version of java.util.function.Supplier. Semantically, this could be a factory, generator, builder, closure, or something else entirely. No guarantees are implied by this interface. The Suppliers class provides common suppliers and related utilities. As this interface extends java.util.function.Supplier, an instance of this type can be used as a java.util.function.Supplier directly. To use a java.util.function.Supplier in a context where a com.google.common.base.Supplier is needed, use supplier::get. See the Guava User Guide article on the use of Function."
940,common/base,com.google.common.base,Class Suppliers,Useful suppliers. All methods return serializable suppliers as long as they're given serializable parameters.
941,common/collect,com.google.common.collect,"Interface Table<R,C,V>","A collection that associates an ordered pair of keys, called a row key and a column key, with a single value. A table may be sparse, with only a small fraction of row key / column key pairs possessing a corresponding value. The mappings corresponding to a given row key may be viewed as a Map whose keys are the columns. The reverse is also available, associating a column with a row key / value map. Note that, in some implementations, data access by column key may have fewer supported operations or worse performance than data access by row key. The methods returning collections or maps always return views of the underlying table. Updating the table can change the contents of those collections, and updating the collections will change the table. All methods that modify the table are optional, and the views returned by the table may or may not be modifiable. When modification isn't supported, those methods will throw an UnsupportedOperationException. See the Guava User Guide article on Table."
942,common/collect,com.google.common.collect,"Interface Table.Cell<R,C,V>",Row key / column key / value triplet corresponding to a mapping in a table.
943,common/collect,com.google.common.collect,Class Tables,Provides static methods that involve a Table. See the Guava User Guide article on Tables.
944,util/concurrent,com.google.common.util.concurrent,Class ThreadFactoryBuilder,"A ThreadFactory builder, providing any combination of these features: whether threads should be marked as daemon threads a naming formata thread priorityan uncaught exception handlera backing thread factoryIf no backing thread factory is provided, a default backing thread factory is used as if by calling setThreadFactory(Executors.defaultThreadFactory())."
945,common/base,com.google.common.base,Class Throwables,Static utility methods pertaining to instances of Throwable. See the Guava User Guide entry on Throwables.
946,common/base,com.google.common.base,Class Ticker,"A time source; returns a time value representing the number of nanoseconds elapsed since some fixed but arbitrary point in time. Note that most users should use Stopwatch instead of interacting with this class directly. Warning: this interface can only be used to measure elapsed time, not wall time."
947,util/concurrent,com.google.common.util.concurrent,Interface TimeLimiter,Imposes a time limit on method calls.
948,common/graph,com.google.common.graph,Class Traverser<N>,"An object that can traverse the nodes that are reachable from a specified (set of) start node(s) using a specified SuccessorsFunction. There are two entry points for creating a Traverser: forTree(SuccessorsFunction) and forGraph(SuccessorsFunction). You should choose one based on your answers to the following questions: Is there only one path to any node that's reachable from any start node? (If so, the graph to be traversed is a tree or forest even if it is a subgraph of a graph which is neither.) Are the node objects' implementations of equals()/hashCode() recursive? If your answers are: (1) ""no"" and (2) ""no"", use forGraph(SuccessorsFunction). (1) ""yes"" and (2) ""yes"", use forTree(SuccessorsFunction). (1) ""yes"" and (2) ""no"", you can use either, but forTree() will be more efficient. (1) ""no"" and (2) ""yes"", neither will work, but if you transform your node objects into a non-recursive form, you can use forGraph()."
949,common/collect,com.google.common.collect,"Class TreeBasedTable<R,C,V>","Implementation of Table whose row keys and column keys are ordered by their natural ordering or by supplied comparators. When constructing a TreeBasedTable, you may provide comparators for the row keys and the column keys, or you may use natural ordering for both. The rowKeySet() method returns a SortedSet and the rowMap() method returns a SortedMap, instead of the Set and Map specified by the Table interface. The views returned by column(C), columnKeySet(), and columnMap() have iterators that don't support remove(). Otherwise, all optional operations are supported. Null row keys, columns keys, and values are not supported. Lookups by row key are often faster than lookups by column key, because the data is stored in a Map<R, Map<C, V>>. A method call like column(columnKey).get(rowKey) still runs quickly, since the row key is provided. However, column(columnKey).size() takes longer, since an iteration across all row keys occurs. Because a TreeBasedTable has unique sorted values for a given row, both row(rowKey) and rowMap().get(rowKey) are SortedMap instances, instead of the Map specified in the Table interface. Note that this implementation is not synchronized. If multiple threads access this table concurrently and one of the threads modifies the table, it must be synchronized externally. See the Guava User Guide article on Table."
950,common/collect,com.google.common.collect,"Class TreeMultimap<K,V>","Implementation of Multimap whose keys and values are ordered by their natural ordering or by supplied comparators. In all cases, this implementation uses Comparable.compareTo(T) or Comparator.compare(T, T) instead of Object.equals(java.lang.Object) to determine equivalence of instances. Warning: The comparators or comparables used must be consistent with equals as explained by the Comparable class specification. Otherwise, the resulting multiset will violate the general contract of SetMultimap, which is specified in terms of Object.equals(java.lang.Object). The collections returned by keySet and asMap iterate through the keys according to the key comparator ordering or the natural ordering of the keys. Similarly, get, removeAll, and replaceValues return collections that iterate through the values according to the value comparator ordering or the natural ordering of the values. The collections generated by entries, keys, and values iterate across the keys according to the above key ordering, and for each key they iterate across the values according to the value ordering. The multimap does not store duplicate key-value pairs. Adding a new key-value pair equal to an existing key-value pair has no effect. Null keys and values are permitted (provided, of course, that the respective comparators support them). All optional multimap methods are supported, and all returned views are modifiable. This class is not threadsafe when any concurrent operations update the multimap. Concurrent read operations will work correctly. To allow concurrent update operations, wrap your multimap with a call to Multimaps.synchronizedSortedSetMultimap(com.google.common.collect.SortedSetMultimap<K, V>). See the Guava User Guide article on Multimap."
951,common/collect,com.google.common.collect,Class TreeMultiset<E>,"A multiset which maintains the ordering of its elements, according to either their natural order or an explicit Comparator. In all cases, this implementation uses Comparable.compareTo(T) or Comparator.compare(T, T) instead of Object.equals(java.lang.Object) to determine equivalence of instances. Warning: The comparison must be consistent with equals as explained by the Comparable class specification. Otherwise, the resulting multiset will violate the Collection contract, which is specified in terms of Object.equals(java.lang.Object). See the Guava User Guide article on Multiset."
952,common/collect,com.google.common.collect,"Class TreeRangeMap<K extends Comparable,V>","An implementation of RangeMap based on a TreeMap, supporting all optional operations. Like all RangeMap implementations, this supports neither null keys nor null values."
953,common/collect,com.google.common.collect,Class TreeRangeSet<C extends Comparable<?>>,An implementation of RangeSet backed by a TreeMap.
954,common/collect,com.google.common.collect,Class TreeTraverser<T>,"Deprecated. Use Traverser instead. All instance methods have their equivalent on the result of Traverser.forTree(tree) where tree implements SuccessorsFunction, which has a similar API as children(T) or can be the same lambda function as passed into using(Function). This class is scheduled to be removed in October 2019."
955,common/reflect,com.google.common.reflect,Class TypeParameter<T>,"Captures a free type variable that can be used in TypeToken.where(com.google.common.reflect.TypeParameter<X>, com.google.common.reflect.TypeToken<X>). For example: static <T> TypeToken<List<T>> listOf(Class<T> elementType) { return new TypeToken<List<T>>() {} .where(new TypeParameter<T>() {}, elementType); }"
956,common/reflect,com.google.common.reflect,Class TypeResolver,"An object of this class encapsulates type mappings from type variables. Mappings are established with where(java.lang.reflect.Type, java.lang.reflect.Type) and types are resolved using resolveType(java.lang.reflect.Type). Note that usually type mappings are already implied by the static type hierarchy (for example, the E type variable declared by class List naturally maps to String in the context of class MyStringList implements List<String>. In such case, prefer to use TypeToken.resolveType(java.lang.reflect.Type) since it's simpler and more type safe. This class should only be used when the type mapping isn't implied by the static type hierarchy, but provided through other means such as an annotation or external configuration file."
957,common/reflect,com.google.common.reflect,Interface TypeToInstanceMap<B>,"A map, each entry of which maps a TypeToken to an instance of that type. In addition to implementing Map, the additional type-safe operations putInstance(java.lang.Class<T>, T) and getInstance(java.lang.Class<T>) are available. Generally, implementations don't support Map.put(K, V) and Map.putAll(java.util.Map<? extends K, ? extends V>) because there is no way to check an object at runtime to be an instance of a TypeToken. Instead, caller should use the type safe putInstance(java.lang.Class<T>, T). Also, if caller suppresses unchecked warnings and passes in an Iterable<String> for type Iterable<Integer>, the map won't be able to detect and throw type error. Like any other Map<Class, Object>, this map may contain entries for primitive types, and a primitive type and its corresponding wrapper type may map to different values."
958,common/reflect,com.google.common.reflect,Class TypeToken<T>,"A Type with generics. Operations that are otherwise only available in Class are implemented to support Type, for example isSubtypeOf(com.google.common.reflect.TypeToken<?>), isArray() and getComponentType(). It also provides additional utilities such as getTypes(), resolveType(java.lang.reflect.Type), etc. There are three ways to get a TypeToken instance: Wrap a Type obtained via reflection. For example: TypeToken.of(method.getGenericReturnType()). Capture a generic type with a (usually anonymous) subclass. For example: new TypeToken<List<String>>() {} Note that it's critical that the actual type argument is carried by a subclass. The following code is wrong because it only captures the <T> type variable of the listType() method signature; while <String> is lost in erasure: class Util { static <T> TypeToken<List<T>> listType() { return new TypeToken<List<T>>() {}; } } TypeToken<List<String>> stringListType = Util.<String>listType(); Capture a generic type with a (usually anonymous) subclass and resolve it against a context class that knows what the type parameters are. For example: abstract class IKnowMyType<T> { TypeToken<T> type = new TypeToken<T>(getClass()) {}; } new IKnowMyType<String>() {}.type => String TypeToken is serializable when no type variable is contained in the type. Note to Guice users: TypeToken is similar to Guice's TypeLiteral class except that it is serializable and offers numerous additional utility methods."
959,util/concurrent,com.google.common.util.concurrent,Class UncaughtExceptionHandlers,Factories for Thread.UncaughtExceptionHandler instances.
960,util/concurrent,com.google.common.util.concurrent,Class UncheckedExecutionException,"Unchecked variant of ExecutionException. As with ExecutionException, the exception's cause comes from a failed task, possibly run in another thread. UncheckedExecutionException is intended as an alternative to ExecutionException when the exception thrown by a task is an unchecked exception. However, it may also wrap a checked exception in some cases. When wrapping an Error from another thread, prefer ExecutionError. When wrapping a checked exception, prefer ExecutionException."
961,util/concurrent,com.google.common.util.concurrent,Class UncheckedTimeoutException,Unchecked version of TimeoutException.
962,common/escape,com.google.common.escape,Class UnicodeEscaper,"An Escaper that converts literal text into a format safe for inclusion in a particular context (such as an XML document). Typically (but not always), the inverse process of ""unescaping"" the text is performed automatically by the relevant parser. For example, an XML escaper would convert the literal string ""Foo<Bar>"" into ""Foo&lt;Bar&gt;"" to prevent ""<Bar>"" from being confused with an XML tag. When the resulting XML document is parsed, the parser API will return this text as the original literal string ""Foo<Bar>"". Note: This class is similar to CharEscaper but with one very important difference. A CharEscaper can only process Java UTF16 characters in isolation and may not cope when it encounters surrogate pairs. This class facilitates the correct escaping of all Unicode characters. As there are important reasons, including potential security issues, to handle Unicode correctly if you are considering implementing a new escaper you should favor using UnicodeEscaper wherever possible. A UnicodeEscaper instance is required to be stateless, and safe when used concurrently by multiple threads. Popular escapers are defined as constants in classes like HtmlEscapers and XmlEscapers. To create your own escapers extend this class and implement the escape(int) method."
963,util/concurrent,com.google.common.util.concurrent,Class Uninterruptibles,"Utilities for treating interruptible operations as uninterruptible. In all cases, if a thread is interrupted during such a call, the call continues to block until the result is available or the timeout elapses, and only then re-interrupts the thread."
964,common/collect,com.google.common.collect,Class UnmodifiableIterator<E>,"An iterator that does not support remove(). UnmodifiableIterator is used primarily in conjunction with implementations of ImmutableCollection, such as ImmutableList. You can, however, convert an existing iterator to an UnmodifiableIterator using Iterators.unmodifiableIterator(java.util.Iterator<? extends T>)."
965,common/collect,com.google.common.collect,Class UnmodifiableListIterator<E>,"A list iterator that does not support UnmodifiableIterator.remove(), add(E), or set(E)."
966,common/primitives,com.google.common.primitives,Class UnsignedBytes,"Static utility methods pertaining to byte primitives that interpret values as unsigned (that is, any negative value b is treated as the positive value 256 + b). The corresponding methods that treat the values as signed are found in SignedBytes, and the methods for which signedness is not an issue are in Bytes. See the Guava User Guide article on primitive utilities."
967,common/primitives,com.google.common.primitives,Class UnsignedInteger,"A wrapper class for unsigned int values, supporting arithmetic operations. In some cases, when speed is more important than code readability, it may be faster simply to treat primitive int values as unsigned, using the methods from UnsignedInts. See the Guava User Guide article on unsigned primitive utilities."
968,common/primitives,com.google.common.primitives,Class UnsignedInts,"Static utility methods pertaining to int primitives that interpret values as unsigned (that is, any negative value x is treated as the positive value 2^32 + x). The methods for which signedness is not an issue are in Ints, as well as signed versions of methods for which signedness is an issue. In addition, this class provides several static methods for converting an int to a String and a String to an int that treat the int as an unsigned number. Users of these utilities must be extremely careful not to mix up signed and unsigned int values. When possible, it is recommended that the UnsignedInteger wrapper class be used, at a small efficiency penalty, to enforce the distinction in the type system. See the Guava User Guide article on unsigned primitive utilities."
969,common/primitives,com.google.common.primitives,Class UnsignedLong,"A wrapper class for unsigned long values, supporting arithmetic operations. In some cases, when speed is more important than code readability, it may be faster simply to treat primitive long values as unsigned, using the methods from UnsignedLongs. See the Guava User Guide article on unsigned primitive utilities."
970,common/primitives,com.google.common.primitives,Class UnsignedLongs,"Static utility methods pertaining to long primitives that interpret values as unsigned (that is, any negative value x is treated as the positive value 2^64 + x). The methods for which signedness is not an issue are in Longs, as well as signed versions of methods for which signedness is an issue. In addition, this class provides several static methods for converting a long to a String and a String to a long that treat the long as an unsigned number. Users of these utilities must be extremely careful not to mix up signed and unsigned long values. When possible, it is recommended that the UnsignedLong wrapper class be used, at a small efficiency penalty, to enforce the distinction in the type system. See the Guava User Guide article on unsigned primitive utilities."
971,common/net,com.google.common.net,Class UrlEscapers,"Escaper instances suitable for strings to be included in particular sections of URLs. If the resulting URLs are inserted into an HTML or XML document, they will require additional escaping with HtmlEscapers or XmlEscapers."
972,common/base,com.google.common.base,Class Utf8,"Low-level, high-performance utility methods related to the UTF-8 character encoding. UTF-8 is defined in section D92 of The Unicode Standard Core Specification, Chapter 3. The variant of UTF-8 implemented by this class is the restricted definition of UTF-8 introduced in Unicode 3.1. One implication of this is that it rejects ""non-shortest form"" byte sequences, even though the JDK decoder may accept them."
973,common/graph,com.google.common.graph,"Interface ValueGraph<N,V>","An interface for graph-structured data, whose edges have associated non-unique values. A graph is composed of a set of nodes and a set of edges connecting pairs of nodes. There are three primary interfaces provided to represent graphs. In order of increasing complexity they are: Graph, ValueGraph, and Network. You should generally prefer the simplest interface that satisfies your use case. See the ""Choosing the right graph type"" section of the Guava User Guide for more details. CapabilitiesValueGraph supports the following use cases (definitions of terms): directed graphs undirected graphs graphs that do/don't allow self-loops graphs whose nodes/edges are insertion-ordered, sorted, or unordered graphs whose edges have associated values ValueGraph, as a subtype of Graph, explicitly does not support parallel edges, and forbids implementations or extensions with parallel edges. If you need parallel edges, use Network. (You can use a positive Integer edge value as a loose representation of edge multiplicity, but the *degree() and mutation methods will not reflect your interpretation of the edge value as its multiplicity.) Building a ValueGraphThe implementation classes that common.graph provides are not public, by design. To create an instance of one of the built-in implementations of ValueGraph, use the ValueGraphBuilder class: MutableValueGraph<Integer, Double> graph = ValueGraphBuilder.directed().build(); ValueGraphBuilder.build() returns an instance of MutableValueGraph, which is a subtype of ValueGraph that provides methods for adding and removing nodes and edges. If you do not need to mutate a graph (e.g. if you write a method than runs a read-only algorithm on the graph), you should use the non-mutating ValueGraph interface, or an ImmutableValueGraph. You can create an immutable copy of an existing ValueGraph using ImmutableValueGraph.copyOf(ValueGraph): ImmutableValueGraph<Integer, Double> immutableGraph = ImmutableValueGraph.copyOf(graph); Instances of ImmutableValueGraph do not implement MutableValueGraph (obviously!) and are contractually guaranteed to be unmodifiable and thread-safe. The Guava User Guide has more information on (and examples of) building graphs. Additional documentationSee the Guava User Guide for the common.graph package (""Graphs Explained"") for additional documentation, including: equals(), hashCode(), and graph equivalence Synchronization policyNotes for implementors"
974,common/graph,com.google.common.graph,"Class ValueGraphBuilder<N,V>","A builder for constructing instances of MutableValueGraph or ImmutableValueGraph with user-defined properties. A graph built by this class will have the following properties by default: does not allow self-loops orders Graph.nodes() in the order in which the elements were added Examples of use: // Building a mutable value graph MutableValueGraph<String, Double> graph = ValueGraphBuilder.undirected().allowsSelfLoops(true).build(); graph.putEdgeValue(""San Francisco"", ""San Francisco"", 0.0); graph.putEdgeValue(""San Jose"", ""San Jose"", 0.0); graph.putEdgeValue(""San Francisco"", ""San Jose"", 48.4); // Building an immutable value graph ImmutableValueGraph<String, Double> immutableGraph = ValueGraphBuilder.undirected() .allowsSelfLoops(true) .<String, Double>immutable() .putEdgeValue(""San Francisco"", ""San Francisco"", 0.0) .putEdgeValue(""San Jose"", ""San Jose"", 0.0) .putEdgeValue(""San Francisco"", ""San Jose"", 48.4) .build();"
975,common/base,com.google.common.base,Class Verify,"Static convenience methods that serve the same purpose as Java language assertions, except that they are always enabled. These methods should be used instead of Java assertions whenever there is a chance the check may fail ""in real life"". Example: Bill bill = remoteService.getLastUnpaidBill(); // In case bug 12345 happens again we'd rather just die Verify.verify(bill.status() == Status.UNPAID, ""Unexpected bill status: %s"", bill.status()); Comparison to alternativesNote: In some cases the differences explained below can be subtle. When it's unclear which approach to use, don't worry too much about it; just pick something that seems reasonable and it will be fine. If checking whether the caller has violated your method or constructor's contract (such as by passing an invalid argument), use the utilities of the Preconditions class instead. If checking an impossible condition (which cannot happen unless your own class or its trusted dependencies is badly broken), this is what ordinary Java assertions are for. Note that assertions are not enabled by default; they are essentially considered ""compiled comments."" An explicit if/throw (as illustrated below) is always acceptable; we still recommend using our VerifyException exception type. Throwing a plain RuntimeException is frowned upon. Use of Objects.requireNonNull(Object) is generally discouraged, since verifyNotNull(Object) and Preconditions.checkNotNull(Object) perform the same function with more clarity. Warning about performanceRemember that parameter values for message construction must all be computed eagerly, and autoboxing and varargs array creation may happen as well, even when the verification succeeds and the message ends up unneeded. Performance-sensitive verification checks should continue to use usual form: Bill bill = remoteService.getLastUnpaidBill(); if (bill.status() != Status.UNPAID) { throw new VerifyException(""Unexpected bill status: "" + bill.status()); } Only %s is supportedAs with Preconditions, Verify uses Strings.lenientFormat(java.lang.String, java.lang.Object...) to format error message template strings. This only supports the ""%s"" specifier, not the full range of Formatter specifiers. However, note that if the number of arguments does not match the number of occurrences of ""%s"" in the format string, Verify will still behave as expected, and will still include all argument values in the error message; the message will simply not be formatted exactly as intended. More information See Conditional failures explained in the Guava User Guide for advice on when this class should be used."
976,common/base,com.google.common.base,Class VerifyException,"Exception thrown upon the failure of a verification check, including those performed by the convenience methods of the Verify class."
977,common/annotations,com.google.common.annotations,Annotation Type VisibleForTesting,"Annotates a program element that exists, or is more widely visible than otherwise necessary, only for use in test code. Do not use this interface for public or protected declarations: it is a fig leaf for bad design, and it does not prevent anyone from using the declaration---and experience has shown that they will. If the method breaks the encapsulation of its class, then its internal representation will be hard to change. Instead, use RestrictedApiChecker, which enforces fine-grained visibility policies."
978,common/cache,com.google.common.cache,"Interface Weigher<K,V>",Calculates the weights of cache entries.
979,common/xml,com.google.common.xml,Class XmlEscapers,"Escaper instances suitable for strings to be included in XML attribute values and elements' text contents. When possible, avoid manual escaping by using templating systems and high-level APIs that provide autoescaping. For example, consider XOM or JDOM. Note: Currently the escapers provided by this class do not escape any characters outside the ASCII character range. Unlike HTML escaping the XML escapers will not escape non-ASCII characters to their numeric entity replacements. These XML escapers provide the minimal level of escaping to ensure that the output can be safely included in a Unicode XML document. For details on the behavior of the escapers in this class, see sections 2.2 and 2.4 of the XML specification."
980,classic/pattern,ch.qos.logback.classic.pattern,Interface Abbreviator,An interface used for abbreviating strings according to different policies.
981,core/sift,ch.qos.logback.core.sift,Class AbstractAppenderFactoryUsingJoran<E>,"Builds new appenders dynamically by running SiftingJoranConfigurator instance, a custom configurator tailored for the contents of the sift element."
982,core/spi,ch.qos.logback.core.spi,Class AbstractComponentTracker<C>,"An abstract implementation of the ComponentTracker interface. Derived classes must implement buildComponent(String), processPriorToRemoval(Object), and isComponentStale(Object) methods as appropriate for their component type."
983,core/sift,ch.qos.logback.core.sift,Class AbstractDiscriminator<E>,Base implementation of Discriminator that provides basic lifecycle management
984,joran/action,ch.qos.logback.core.joran.action,Class AbstractEventEvaluatorAction,
985,core/filter,ch.qos.logback.core.filter,Class AbstractMatcherFilter<E>,
986,net/server,ch.qos.logback.core.net.server,Class AbstractServerSocketAppender<E>,This is the super class for module specific ServerSocketAppender implementations can derive from.
987,core/net,ch.qos.logback.core.net,Class AbstractSocketAppender<E>,An abstract base for module specific SocketAppender implementations in other logback modules.
988,core/net,ch.qos.logback.core.net,Class AbstractSSLSocketAppender<E>,An abstract base for module specific SSLSocketAppender implementations located in other logback modules.
989,logback/access,ch.qos.logback.access,Class AccessConstants,
990,access/spi,ch.qos.logback.access.spi,Class AccessContext,"A minimal context implementation used by certain logback-access components, mainly SocketServer."
991,access/pattern,ch.qos.logback.access.pattern,Class AccessConverter,
992,access/spi,ch.qos.logback.access.spi,Class AccessEvent,The Access module's internal representation of logging events. When the logging component instance is called in the container to log then a AccessEvent instance is created. This instance is passed around to the different logback components.
993,access/sift,ch.qos.logback.access.sift,Class AccessEventDiscriminator,AccessEventDiscriminator's job is to return the value of a designated field in an IAccessEvent instance. The field is specified via the AccessEventDiscriminator.FieldName property.
994,access/sift,ch.qos.logback.access.sift,Enum AccessEventDiscriminator.FieldName,"At present time the followed fields can be designated: COOKIE, REQUEST_ATTRIBUTE, SESSION_ATTRIBUTE, REMOTE_ADDRESS, LOCAL_PORT,REQUEST_URI The first three fields require an additional key. For the SESSION_ATTRIBUTE field, the additional key named ""id"" has special meaning as it is mapped to the session id of the current http request."
995,access/net,ch.qos.logback.access.net,Class AccessEventPreSerializationTransformer,
996,joran/action,ch.qos.logback.core.joran.action,Class Action,Most of the work for configuring logback is done by Actions. Action methods are invoked as the XML file is parsed. This class is largely inspired from the relevant class in the commons-digester project of the Apache Software Foundation.
997,joran/action,ch.qos.logback.core.joran.action,Class ActionConst,This class contains costants used by other Actions.
998,joran/spi,ch.qos.logback.core.joran.spi,Class ActionException,By throwing an exception an action can signal the Interpreter to skip processing of all the nested (child) elements of the element associated with the action causing the exception.
999,joran/action,ch.qos.logback.core.joran.action,Class ActionUtil,
1000,joran/action,ch.qos.logback.core.joran.action,Enum ActionUtil.Scope,
1001,onJoran/calculator,chapters.onJoran.calculator,Class AddAction,This action adds the two integers at the top of the stack (they are removed) and pushes the result to the top the stack.
1002,chapters/configuration,chapters.configuration,Class AddStatusListenerApp,
1003,core/util,ch.qos.logback.core.util,Enum AggregationType,AggregationType classifies how one object is contained within another object. See also http://en.wikipedia.org/wiki/Class_diagram and http://en.wikipedia.org/wiki/Object_composition
1004,pattern/util,ch.qos.logback.core.pattern.util,Class AlmostAsIsEscapeUtil,This implementation is intended for use in FileNamePattern.
1005,pattern/color,ch.qos.logback.core.pattern.color,Class ANSIConstants,
1006,logback/core,ch.qos.logback.core,Interface Appender<E>,
1007,joran/action,ch.qos.logback.core.joran.action,Class AppenderAction<E>,
1008,core/spi,ch.qos.logback.core.spi,Interface AppenderAttachable<E>,Interface for attaching appenders to objects.
1009,core/spi,ch.qos.logback.core.spi,Class AppenderAttachableImpl<E>,A ReentrantReadWriteLock based implementation of the AppenderAttachable interface.
1010,logback/core,ch.qos.logback.core,Class AppenderBase<E>,"Sets a skeleton implementation for appenders. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#AppenderBase"
1011,receivers/socket,chapters.receivers.socket,Class AppenderExample,This application loads a configuration containing some form of socket appender and then allows the user to enter messages which will be relayed to remote clients via the appender.
1012,core/sift,ch.qos.logback.core.sift,Interface AppenderFactory<E>,Created with IntelliJ IDEA. User: ceki Date: 25.04.13 Time: 19:00 To change this template use File | Settings | File Templates.
1013,access/sift,ch.qos.logback.access.sift,Class AppenderFactoryUsingJoran,
1014,classic/sift,ch.qos.logback.classic.sift,Class AppenderFactoryUsingJoran,
1015,joran/action,ch.qos.logback.core.joran.action,Class AppenderRefAction<E>,
1016,core/sift,ch.qos.logback.core.sift,Class AppenderTracker<E>,Track appenders by key. When an appender is not used for longer than ComponentTracker.DEFAULT_TIMEOUT it is stopped and removed.
1017,rolling/helper,ch.qos.logback.core.rolling.helper,Interface ArchiveRemover,Given a date remove older archived log files.
1018,pattern/util,ch.qos.logback.core.pattern.util,Class AsIsEscapeUtil,
1019,logback/classic,ch.qos.logback.classic,Class AsyncAppender,"In order to optimize performance this appender deems events of level TRACE, DEBUG and INFO as discardable. See the chapter on appenders in the manual for further information."
1020,logback/core,ch.qos.logback.core,Class AsyncAppenderBase<E>,"This appender and derived classes, log events asynchronously. In order to avoid loss of logging events, this appender should be closed. It is the user's responsibility to close appenders, typically at the end of the application lifecycle. This appender buffers events in a BlockingQueue. Worker thread created by this appender takes events from the head of the queue, and dispatches them to the single appender attached to this appender. Please refer to the logback manual for further information about this appender."
1021,core/net,ch.qos.logback.core.net,Class AutoFlushingObjectWriter,Automatically flushes the underlying ObjectOutputStream immediately after calling it's ObjectOutputStream.writeObject(Object) method.
1022,sub/sample,chapters.appenders.sub.sample,Class Bar,
1023,logback/classic,ch.qos.logback.classic,Class BasicConfigurator,BasicConfigurator configures logback-classic by attaching a ConsoleAppender to the root logger. The console appender's layout is set to a TTLLLayout.
1024,classic/spi,ch.qos.logback.classic.spi,Class BasicSequenceNumberGenerator,A very simple SequenceNumberGenerator based on an AtomicLong variable.
1025,logback/core,ch.qos.logback.core,Class BasicStatusManager,
1026,util/beans,ch.qos.logback.core.joran.util.beans,Class BeanDescription,"Lightweight pendant to the java.beans.BeanInfo class. An instance of this class encapsulates the properties of a certain class. The properties are the public setters and getters. In addition the 'add-er'-methods are included, which are the public methods which start with the prefix 'add'."
1027,util/beans,ch.qos.logback.core.joran.util.beans,Class BeanDescriptionCache,Cache for BeanDescription instances. All the cache users which use the same instance of BeanDescriptionCache can profit from each others cached bean descriptions. The cache is not thread-safe and should not be shared across configurator instances.
1028,util/beans,ch.qos.logback.core.joran.util.beans,Class BeanDescriptionFactory,"Encapsulates creation of BeanDescription instances. This factory is kind of a lightweight Introspector as described in the Java Beans API specification. The given class is only analyzed for its public getters, setters and adders methods. Implementations of the BeanInfo interface are not taken into account for analysis. Therefore this class is only partially compatible with the Java Beans API specification."
1029,util/beans,ch.qos.logback.core.joran.util.beans,Class BeanUtil,Encapsulates utility methods associated with standard java beans.
1030,core/db,ch.qos.logback.core.db,Class BindDataSourceToJNDIAction,
1031,pattern/color,ch.qos.logback.core.pattern.color,Class BlackCompositeConverter<E>,Encloses a given set of converter output in black using the appropriate ANSI escape codes.
1032,pattern/color,ch.qos.logback.core.pattern.color,Class BlueCompositeConverter<E>,Encloses a given set of converter output in blue using the appropriate ANSI escape codes.
1033,joran/event,ch.qos.logback.core.joran.event,Class BodyEvent,
1034,event/stax,ch.qos.logback.core.joran.event.stax,Class BodyEvent,
1035,pattern/color,ch.qos.logback.core.pattern.color,Class BoldBlueCompositeConverter<E>,Encloses a given set of converter output in bold blue using the appropriate ANSI escape codes.
1036,pattern/color,ch.qos.logback.core.pattern.color,Class BoldCyanCompositeConverter<E>,Encloses a given set of converter output in bold cyan using the appropriate ANSI escape codes.
1037,pattern/color,ch.qos.logback.core.pattern.color,Class BoldGreenCompositeConverter<E>,Encloses a given set of converter output in bold green using the appropriate ANSI escape codes.
1038,pattern/color,ch.qos.logback.core.pattern.color,Class BoldMagentaCompositeConverter<E>,Encloses a given set of converter output in bold magenta using the appropriate ANSI escape codes.
1039,pattern/color,ch.qos.logback.core.pattern.color,Class BoldRedCompositeConverter<E>,Encloses a given set of converter output in bold red using the appropriate ANSI escape codes.
1040,pattern/color,ch.qos.logback.core.pattern.color,Class BoldWhiteCompositeConverter<E>,Encloses a given set of converter output in bold white using the appropriate ANSI escape codes.
1041,pattern/color,ch.qos.logback.core.pattern.color,Class BoldYellowCompositeConverter<E>,Encloses a given set of converter output in bold yellow using the appropriate ANSI escape codes.
1042,core/encoder,ch.qos.logback.core.encoder,Class ByteArrayUtil,
1043,core/util,ch.qos.logback.core.util,Class CachingDateFormatter,A synchronized implementation of SimpleDateFormat which uses caching internally.
1044,onJoran/calculator,chapters.onJoran.calculator,Class Calculator1,This examples illustrates collaboration between multiple actions through the common execution context stack.
1045,onJoran/calculator,chapters.onJoran.calculator,Class Calculator2,This examples illustrates collaboration between multiple actions through the common execution context stack. It differs from Calculator1 in that it supports arbitrary nesting of computation elements. You can test this application with the sample XML file calculator3.xml.
1046,classic/spi,ch.qos.logback.classic.spi,Class CallerData,This class computes caller data returning the result in the form of a StackTraceElement array.
1047,classic/pattern,ch.qos.logback.classic.pattern,Class CallerDataConverter,This converter outputs caller data depending on depth or depth range and marker data.
1048,chapters/layouts,chapters.layouts,Class CallerEvaluatorExample,
1049,core/property,ch.qos.logback.core.property,Class CanonicalHostNamePropertyDefiner,
1050,logback/classic,ch.qos.logback.classic,Class ClassicConstants,
1051,classic/pattern,ch.qos.logback.classic.pattern,Class ClassicConverter,This class serves the super-class of all converters in logback. It extends DynamicConverter.
1052,classic/pattern,ch.qos.logback.classic.pattern,Class ClassNameOnlyAbbreviator,"This abbreviator returns the class name from a fully qualified class name, removing the leading package name."
1053,classic/pattern,ch.qos.logback.classic.pattern,Class ClassOfCallerConverter,
1054,classic/spi,ch.qos.logback.classic.spi,Class ClassPackagingData,
1055,net/server,ch.qos.logback.core.net.server,Interface Client,"A client of a ServerRunner. This interface exists primarily to abstract away the details of the client's underlying Socket and the concurrency associated with handling multiple clients. Such realities make it difficult to create effective unit tests for the ServerRunner that are easy to understand and maintain. This interface captures the only those details about a client that the ServerRunner cares about; namely, that it is something that is Runnable — i.e. it can be executed concurrentlyholds resources that need to be closed before the client is discarded"
1056,net/server,ch.qos.logback.core.net.server,Interface ClientVisitor<T extends Client>,A visitor for a Client.
1057,core/util,ch.qos.logback.core.util,Class CloseUtil,Static utility method for Closeable objects.
1058,db/names,ch.qos.logback.classic.db.names,Enum ColumnName,
1059,joran/node,ch.qos.logback.core.joran.node,Class ComponentNode,
1060,core/spi,ch.qos.logback.core.spi,Interface ComponentTracker<C>,Interface for tracking various components by key. Components which have not been accessed for more than a user-specified duration are deemed stale and removed. Components can also be explicitly marked as having reached their endOfLife(String) in which case they will linger for a few seconds and then be removed.
1061,core/pattern,ch.qos.logback.core.pattern,Class CompositeConverter<E>,
1062,pattern/parser,ch.qos.logback.core.pattern.parser,Class CompositeNode,
1063,rolling/helper,ch.qos.logback.core.rolling.helper,Enum CompressionMode,
1064,rolling/helper,ch.qos.logback.core.rolling.helper,Class Compressor,The Compression class implements ZIP and GZ file compression/decompression methods.
1065,onJoran/calculator,chapters.onJoran.calculator,Class ComputationAction1,"ComputationAction1 will print the result of the compuration made by children elements but only if the compuration itself is named, that is if the name attribute of the associated computation element is not null. In other words, anonymous computations will not print their result."
1066,onJoran/calculator,chapters.onJoran.calculator,Class ComputationAction2,"ComputationAction2 will print the result of the compuration made by children elements but only if the computation itself is named, that is if the name attribute of the associated computation element is not null. In other words, anonymous computations will not print their result. ComputationAction2 differs from ComputationAction1 in its handling of instance variables. ComputationAction1 has a simple nameStr instance variable. This variable is set when the begin() method is called and then later used within the end() method. This simple approach works properly if the begin() and end() method of a given action are expected to be called in sequence. However, there are situations where the begin() method of the same action instance is invoked multiple times before the matching end() method is invoked. When this happens, the second call to begin() overwrites values set by the first invocation to begin(). The solution is to save parameter values into a separate stack. The well-formedness of XML will guarantee that a value saved by one begin() will be consumed only by the matching end() method. Note that in the vast majority of cases there is no need to resort to a separate stack for each variable. The situation of successive begin() invocations can only occur if: 1) the associated pattern contains a wildcard, i.e. the * character and 2) the associated element tag can contain itself as a child For example, ""*/computation"" pattern means that computations can contain other computation elements as children."
1067,net/server,ch.qos.logback.core.net.server,Class ConcurrentServerRunner<T extends Client>,"A concurrent ServerRunner. An instance of this object is created with a ServerListener and an Executor. On invocation of the start() method, it passes itself to the given Executor and returns immediately. On invocation of its run() method by the Executor it begins accepting client connections via its ServerListener. As each new Client is accepted, the client is configured with the runner's LoggingContext and is then passed to the Executor for concurrent execution of the client's service loop. On invocation of the stop() method, the runner closes the listener and each of the connected clients (by invoking Client.close() effectively interrupting any blocked I/O calls and causing these concurrent subtasks to exit gracefully). This ensures that before the stop() method returns (1) all I/O resources have been released and (2) all of the threads of the Executor are idle."
1068,joran/conditional,ch.qos.logback.core.joran.conditional,Interface Condition,
1069,net/ssl,ch.qos.logback.core.net.ssl,Class ConfigurableSSLServerSocketFactory,"An SSLServerSocketFactory that configures SSL parameters (those specified in SSLParametersConfiguration on each newly created socket. When any of this factory's createServerSocket methods are invoked, it calls on a delegate SSLServerSocketFactory to create the socket, and then sets the SSL parameters of the socket (using the provided configuration) before returning the socket to the caller."
1070,net/ssl,ch.qos.logback.core.net.ssl,Class ConfigurableSSLSocketFactory,"An SSLSocketFactory that configures SSL parameters (those covered by SSLParameters) on each newly created socket. When any of this factory's createSocket methods are invoked, it calls on a SSLSocketFactory delegate to create the socket, and then sets the SSL parameters of the socket (using the provided configuration) before returning the socket to the caller."
1071,joran/action,ch.qos.logback.access.joran.action,Class ConfigurationAction,
1072,joran/action,ch.qos.logback.classic.joran.action,Class ConfigurationAction,
1073,chapters/appenders,chapters.appenders,Class ConfigurationTester,"This java ""application"" configures logback using a configuration file supplied on the class path and logs a few times."
1074,joran/spi,ch.qos.logback.core.joran.spi,Class ConfigurationWatchList,
1075,joran/util,ch.qos.logback.core.joran.util,Class ConfigurationWatchListUtil,
1076,classic/spi,ch.qos.logback.classic.spi,Interface Configurator,Allows programmatic initialization and configuration of Logback. The ServiceLoader is typically used to instantiate implementations and thus implementations will need to follow the guidelines of the ServiceLoader specifically a no-arg constructor is required.
1077,core/db,ch.qos.logback.core.db,Interface ConnectionSource,"The ConnectionSource interface provides a pluggable means of transparently obtaining JDBC Connections for logback classes that require the use of a Connection. For more information about this component, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#DBAppender"
1078,core/db,ch.qos.logback.core.db,Class ConnectionSourceBase,
1079,logback/core,ch.qos.logback.core,Class ConsoleAppender<E>,"ConsoleAppender appends log events to System.out or System.err using a layout specified by the user. The default target is System.out.   For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#ConsoleAppender"
1080,joran/action,ch.qos.logback.classic.joran.action,Class ConsolePluginAction,
1081,appenders/socket,chapters.appenders.socket,Class ConsolePluginClient,Created with IntelliJ IDEA. User: ceki Date: 27.06.12 Time: 19:35 To change this template use File | Settings | File Templates.
1082,joran/spi,ch.qos.logback.core.joran.spi,Enum ConsoleTarget,The set of console output targets.
1083,access/pattern,ch.qos.logback.access.pattern,Class ContentLengthConverter,
1084,core/util,ch.qos.logback.core.util,Class ContentTypeUtil,Various utility methods for processing strings representing context types.
1085,logback/core,ch.qos.logback.core,Interface Context,A context is the main anchorage point of all logback components.
1086,core/spi,ch.qos.logback.core.spi,Interface ContextAware,An object which has a context and add methods for updating internal status messages.
1087,core/spi,ch.qos.logback.core.spi,Class ContextAwareBase,A helper class that implements ContextAware methods. A class can implement the ContextAware interface by deriving from this class.
1088,core/spi,ch.qos.logback.core.spi,Class ContextAwareImpl,A helper class that implements ContextAware methods. Use this class to implement the ContextAware interface by composition.
1089,logback/core,ch.qos.logback.core,Class ContextBase,
1090,classic/sift,ch.qos.logback.classic.sift,Class ContextBasedDiscriminator,"This discriminator returns the value context to which this event is attached to. If the said value is null, then a default value is returned. Both Key and the DefaultValue are user specified properties."
1091,selector/servlet,ch.qos.logback.classic.selector.servlet,Class ContextDetachingSCL,
1092,classic/util,ch.qos.logback.classic.util,Class ContextInitializer,This class contains logback's logic for automatic configuration
1093,classic/selector,ch.qos.logback.classic.selector,Class ContextJNDISelector,"A class that allows the LoggerFactory to access an environment-based LoggerContext. To add in catalina.sh JAVA_OPTS=""$JAVA_OPTS ""-Dlogback.ContextSelector=JNDI"""""
1094,joran/action,ch.qos.logback.classic.joran.action,Class ContextNameAction,
1095,classic/pattern,ch.qos.logback.classic.pattern,Class ContextNameConverter,Converts an event to the logger context's name.
1096,joran/action,ch.qos.logback.core.joran.action,Class ContextPropertyAction,
1097,classic/selector,ch.qos.logback.classic.selector,Interface ContextSelector,An interface that provides access to different contexts. It is used by the LoggerFactory to access the context it will use to retrieve loggers.
1098,classic/util,ch.qos.logback.classic.util,Class ContextSelectorStaticBinder,Holds the context selector for use in the current environment.
1099,core/util,ch.qos.logback.core.util,Class ContextUtil,
1100,joran/action,ch.qos.logback.core.joran.action,Class ConversionRuleAction,
1101,core/pattern,ch.qos.logback.core.pattern,Class Converter<E>,A minimal converter which sets up the general interface for derived classes. It also implements the functionality to chain converters in a linked list.
1102,core/pattern,ch.qos.logback.core.pattern,Class ConverterUtil,
1103,classic/util,ch.qos.logback.classic.util,Class CopyOnInheritThreadLocal,This class extends InheritableThreadLocal so that children threads get a copy of the parent's hashmap.
1104,logback/core,ch.qos.logback.core,Class CoreConstants,
1105,appenders/mail,chapters.appenders.mail,Class CounterBasedEvaluator,A simple EventEvaluator implementation that triggers email transmission after 1024 events regardless of event level.
1106,chapters/appenders,chapters.appenders,Class CountingConsoleAppender,
1107,access/filter,ch.qos.logback.access.filter,Class CountingFilter,
1108,core/util,ch.qos.logback.core.util,Class COWArrayList<E>,"A GC-free lock-free thread-safe implementation of the List interface for use cases where iterations over the list vastly out-number modifications on the list. Underneath, it wraps an instance of CopyOnWriteArrayList and exposes a copy of the array used by that instance. Typical use: COWArrayList<Integer> list = new COWArrayList(new Integer[0]); // modify the list list.add(1); list.add(2); Integer[] intArray = list.asTypedArray(); int sum = 0; // iteration over the array is thread-safe for(int i = 0; i < intArray.length; i++) { sum != intArray[i]; } If the list is not modified, then repetitive calls to asTypedArray(), toArray() and toArray(Object[]) are guaranteed to be GC-free. Note that iterating over the list using iterator() and listIterator() are not GC-free."
1109,core/html,ch.qos.logback.core.html,Interface CssBuilder,
1110,pattern/color,ch.qos.logback.core.pattern.color,Class CyanCompositeConverter<E>,Encloses a given set of converter output in cyan using the appropriate ANSI escape codes.
1111,core/helpers,ch.qos.logback.core.helpers,Class CyclicBuffer<E>,CyclicBuffer holds values in a cyclic array. It allows read access to any element in the buffer not just the first or last element.
1112,core/read,ch.qos.logback.core.read,Class CyclicBufferAppender<E>,"CyclicBufferAppender stores events in a cyclic buffer of user-specified size. As the name suggests, if the size of the buffer is N, only the latest N events are available."
1113,core/spi,ch.qos.logback.core.spi,Class CyclicBufferTracker<E>,CyclicBufferTracker tracks CyclicBuffer instances.
1114,core/db,ch.qos.logback.core.db,Class DataSourceConnectionSource,"The DataSourceConnectionSource is an implementation of ConnectionSource that obtains the Connection in the recommended JDBC manner based on a DataSource. For more information about this component, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#DBAppender"
1115,access/pattern,ch.qos.logback.access.pattern,Class DateConverter,
1116,classic/pattern,ch.qos.logback.classic.pattern,Class DateConverter,
1117,core/util,ch.qos.logback.core.util,Class DatePatternToRegexUtil,This class is concerned with computing a regex corresponding to a date pattern (in SimpleDateFormat format).
1118,rolling/helper,ch.qos.logback.core.rolling.helper,Class DateTokenConverter<E>,Returns a date formatted by SimpleDateFormatter.
1119,access/db,ch.qos.logback.access.db,Class DBAppender,"The DBAppender inserts access events into three database tables in a format independent of the Java programming language. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#AccessDBAppender"
1120,classic/db,ch.qos.logback.classic.db,Class DBAppender,"The DBAppender inserts logging events into three database tables in a format independent of the Java programming language. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#DBAppender"
1121,core/db,ch.qos.logback.core.db,Class DBAppenderBase<E>,
1122,classic/db,ch.qos.logback.classic.db,Class DBHelper,
1123,core/db,ch.qos.logback.core.db,Class DBHelper,
1124,db/names,ch.qos.logback.classic.db.names,Interface DBNameResolver,Source of table and column names used in SQL queries generated by DBAppender Implement this interface to override default table and/or column names used by DBAppender.
1125,db/dialect,ch.qos.logback.core.db.dialect,Class DBUtil,
1126,joran/spi,ch.qos.logback.core.joran.spi,Annotation Type DefaultClass,
1127,classic/selector,ch.qos.logback.classic.selector,Class DefaultContextSelector,
1128,access/html,ch.qos.logback.access.html,Class DefaultCssBuilder,"This class helps the HTMLLayout build the CSS link. It either provides the HTMLLayout with a default css file, or builds the link to an external, user-specified, file."
1129,classic/html,ch.qos.logback.classic.html,Class DefaultCssBuilder,"This class helps the HTMLLayout build the CSS link. It either provides the HTMLLayout with a default css file, or builds the link to an external, user-specified, file."
1130,db/names,ch.qos.logback.classic.db.names,Class DefaultDBNameResolver,The default name resolver simply returns the enum passes as parameter as a lower case string.
1131,core/sift,ch.qos.logback.core.sift,Class DefaultDiscriminator<E>,
1132,core/util,ch.qos.logback.core.util,Class DefaultInvocationGate,"This class serves as a gateway for invocations of a ""costly"" operation on a critical execution path."
1133,joran/spi,ch.qos.logback.core.joran.spi,Class DefaultNestedComponentRegistry,A registry which maps a property in a host class to a default class.
1134,classic/util,ch.qos.logback.classic.util,Class DefaultNestedComponentRules,Contains mappings for the default type of nested components in logback-classic.
1135,core/hook,ch.qos.logback.core.hook,Class DefaultShutdownHook,ShutdownHook implementation that stops the Logback context after a specified delay. The default delay is 0 ms (zero). Stopping the logback context
1136,core/net,ch.qos.logback.core.net,Class DefaultSocketConnector,Default implementation of SocketConnector.
1137,classic/html,ch.qos.logback.classic.html,Class DefaultThrowableRenderer,
1138,core/rolling,ch.qos.logback.core.rolling,Class DefaultTimeBasedFileNamingAndTriggeringPolicy<E>,
1139,core/spi,ch.qos.logback.core.spi,Interface DeferredProcessingAware,
1140,joran/action,ch.qos.logback.core.joran.action,Class DefinePropertyAction,Instantiate class for define property value. Get future property name and property definer class from attributes. Some property definer properties could be used. After defining put new property to context.
1141,core/util,ch.qos.logback.core.util,Interface DelayStrategy,A strategy for computing a delay.
1142,core/sift,ch.qos.logback.core.sift,Interface Discriminator<E>,"Implement this interface in order to compute a discriminating value for a given event of type <E>. The returned value can depend on any data available at the time of the call, including data contained within the currently running thread."
1143,core/db,ch.qos.logback.core.db,Class DriverManagerConnectionSource,"The DriverManagerConnectionSource is an implementation of ConnectionSource that obtains the Connection in the traditional JDBC manner based on the connection URL. For more information about this component, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#DBAppender"
1144,classic/turbo,ch.qos.logback.classic.turbo,Class DuplicateMessageFilter,See http://logback.qos.ch/manual/filters.html#DuplicateMessageFilter for details.
1145,core/util,ch.qos.logback.core.util,Class Duration,"Duration instances represent a lapse of time. Internally, the duration is stored in milliseconds. However, whenever a parameter of type Duration is expected, Joran (logback's configuration system) will automatically convert strings such as ""20 seconds"" ""3.5 minutes"" or ""5 hours"" into Duration instances. The recognized units of time are the ""millisecond"", ""second"", ""minute"" ""hour"" and ""day"". The unit name may be followed by an ""s"". Thus, ""2 day"" and ""2 days"" are equivalent. In the absence of a time unit specification, milliseconds are assumed. Note: the conversion magic is entirely due to the fact that this class follows the valueOf(java.lang.String) convention."
1146,core/util,ch.qos.logback.core.util,Class DynamicClassLoadingException,
1147,core/pattern,ch.qos.logback.core.pattern,Class DynamicConverter<E>,
1148,classic/turbo,ch.qos.logback.classic.turbo,Class DynamicThresholdFilter,"This filter allows for efficient course grained filtering based on criteria such as product name or company name that would be associated with requests as they are processed. This filter will allow you to associate threshold levels to a key put in the MDC. This key can be any value specified by the user. Furthermore, you can pass MDC value and level threshold associations, which are then looked up to find the level threshold to apply to the current logging request. If no level threshold could be found, then a 'default' value specified by the user is applied. We call this value 'levelAssociatedWithMDCValue'. If 'levelAssociatedWithMDCValue' is higher or equal to the level of the current logger request, the decide() method returns the value of onHigherOrEqual, if it is lower then the value of onLower is returned. Both 'onHigherOrEqual' and 'onLower' can be set by the user. By default, 'onHigherOrEqual' is set to NEUTRAL and 'onLower' is set to DENY. Thus, if the current logger request's level is lower than 'levelAssociatedWithMDCValue', then the request is denied, and if it is higher or equal, then this filter decides NEUTRAL letting subsequent filters to make the decision on the fate of the logging request. The example below illustrates how logging could be enabled for only individual users. In this example all events for logger names matching ""com.mycompany"" will be logged if they are for 'user1' and at a level higher than equals to DEBUG, and for 'user2' if they are at a level higher than or equal to TRACE, and for other users only if they are at level ERROR or higher. Events issued by loggers other than ""com.mycompany"" will only be logged if they are at level ERROR or higher since that is all the root logger allows. <configuration> <appender name=""STDOUT"" class=""ch.qos.logback.core.ConsoleAppender""> <layout class=""ch.qos.logback.classic.PatternLayout""> <Pattern>TEST %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</Pattern> </layout> </appender> <turboFilter class=""ch.qos.logback.classic.turbo.DynamicThresholdFilter""> <Key>userId</Key> <DefaultThreshold>ERROR</DefaultThreshold> <MDCValueLevelPair> <value>user1</value> <level>DEBUG</level> </MDCValueLevelPair> <MDCValueLevelPair> <value>user2</value> <level>TRACE</level> </MDCValueLevelPair> </turboFilter> <logger name=""com.mycompany"" level=""TRACE""/> <root level=""ERROR"" > <appender-ref ref=""STDOUT"" /> </root> </configuration> In the next configuration events from user1 and user2 will be logged regardless of the logger levels. Events for other users and records without a userid in the MDC will be logged if they are ERROR level messages. With this configuration, the root level is never checked since DynamicThresholdFilter will either accept or deny all records. <configuration> <appender name=""STDOUT"" class=""ch.qos.logback.core.ConsoleAppender""> <layout class=""ch.qos.logback.classic.PatternLayout""> <Pattern>TEST %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</Pattern> </layout> </appender> <turboFilter class=""ch.qos.logback.classic.turbo.DynamicThresholdFilter""> <Key>userId</Key> <DefaultThreshold>ERROR</DefaultThreshold> <OnHigherOrEqual>ACCEPT</OnHigherOrEqual> <OnLower>DENY</OnLower> <MDCValueLevelPair> <value>user1</value> <level>TRACE</level> </MDCValueLevelPair> <MDCValueLevelPair> <value>user2</value> <level>TRACE</level> </MDCValueLevelPair> </turboFilter> <root level=""DEBUG"" > <appender-ref ref=""STDOUT"" /> </root> </configuration>"
1149,core/encoder,ch.qos.logback.core.encoder,Class EchoEncoder<E>,
1150,core/layout,ch.qos.logback.core.layout,Class EchoLayout<E>,Echos the incoming object adding a line separator character(s) at the end.
1151,access/pattern,ch.qos.logback.access.pattern,Class ElapsedSecondsConverter,
1152,access/pattern,ch.qos.logback.access.pattern,Class ElapsedTimeConverter,
1153,joran/spi,ch.qos.logback.core.joran.spi,Class ElementPath,A element path characterizes a traversal path in an XML document.
1154,joran/spi,ch.qos.logback.core.joran.spi,Class ElementSelector,"ElementSelector extends ElementPath with matching operations such as fullPathMatch(ElementPath), getPrefixMatchLength(ElementPath) and getTailMatchLength(ElementPath). Parts of the path may contain '*' for wildcard matching."
1155,joran/conditional,ch.qos.logback.core.joran.conditional,Class ElseAction,
1156,appenders/mail,chapters.appenders.mail,Class EMail,This application generates log messages in numbers specified by the user.
1157,core/encoder,ch.qos.logback.core.encoder,Interface Encoder<E>,Encoders are responsible for transform an incoming event into a byte array
1158,core/encoder,ch.qos.logback.core.encoder,Class EncoderBase<E>,
1159,joran/event,ch.qos.logback.core.joran.event,Class EndEvent,
1160,event/stax,ch.qos.logback.core.joran.event.stax,Class EndEvent,Created with IntelliJ IDEA. User: ceki Date: 7/2/13 Time: 4:07 PM To change this template use File | Settings | File Templates.
1161,classic/pattern,ch.qos.logback.classic.pattern,Class EnsureExceptionHandling,
1162,access/pattern,ch.qos.logback.access.pattern,Class EnsureLineSeparation,
1163,classic/util,ch.qos.logback.classic.util,Class EnvUtil,
1164,core/util,ch.qos.logback.core.util,Class EnvUtil,
1165,core/status,ch.qos.logback.core.status,Class ErrorStatus,
1166,core/boolex,ch.qos.logback.core.boolex,Class EvaluationException,This exception wraps exceptions thrown while evaluating events.
1167,joran/action,ch.qos.logback.access.joran.action,Class EvaluatorAction,
1168,joran/action,ch.qos.logback.classic.joran.action,Class EvaluatorAction,
1169,core/filter,ch.qos.logback.core.filter,Class EvaluatorFilter<E>,"The value of the AbstractMatcherFilter.onMatch and AbstractMatcherFilter.onMismatch attributes is set to FilterReply.NEUTRAL, so that a badly configured evaluator filter does not disturb the functioning of the filter chain. It is expected that one of the two attributes will have its value changed to FilterReply.ACCEPT or FilterReply.DENY. That way, it is possible to decide if a given result must be returned after the evaluation either failed or succeeded. For more information about filters, please refer to the online manual at http://logback.qos.ch/manual/filters.html"
1170,classic/spi,ch.qos.logback.classic.spi,Class EventArgUtil,
1171,core/boolex,ch.qos.logback.core.boolex,Interface EventEvaluator<E>,"Evaluates whether a given an event matches user-specified criteria. Implementations are free to evaluate the event as they see fit. In particular, the evaluation results may depend on previous events."
1172,core/boolex,ch.qos.logback.core.boolex,Class EventEvaluatorBase<E>,
1173,joran/spi,ch.qos.logback.core.joran.spi,Class EventPlayer,
1174,chapters/layouts,chapters.layouts,Class ExceptionEvaluatorExample,
1175,core/util,ch.qos.logback.core.util,Class ExecutorServiceUtil,Static utility methods for manipulating an ExecutorService.
1176,classic/pattern,ch.qos.logback.classic.pattern,Class ExtendedThrowableProxyConverter,
1177,logback/core,ch.qos.logback.core,Class FileAppender<E>,"FileAppender appends log events to a file. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#FileAppender"
1178,core/property,ch.qos.logback.core.property,Class FileExistsPropertyDefiner,"In conjunction with PropertyAction sets the named variable to ""true"" if the file specified by path property exists, to ""false"" otherwise."
1179,rolling/helper,ch.qos.logback.core.rolling.helper,Class FileFilterUtil,
1180,rolling/helper,ch.qos.logback.core.rolling.helper,Class FileNamePattern,"After parsing file name patterns, given a number or a date, instances of this class can be used to compute a file name according to the file name pattern and the current date or integer."
1181,classic/pattern,ch.qos.logback.classic.pattern,Class FileOfCallerConverter,
1182,core/util,ch.qos.logback.core.util,Class FileSize,"Instances of this class represent the size of a file. Internally, the size is stored as long. The valueOf(java.lang.String) method can convert strings such as ""3 kb"", ""5 mb"", into FileSize instances. The recognized unit specifications for file size are the ""kb"", ""mb"", and ""gb"". The unit name may be followed by an ""s"". Thus, ""2 kbs"" and ""2 kb"" are equivalent. In the absence of a time unit specification, byte is assumed."
1183,rolling/helper,ch.qos.logback.core.rolling.helper,Class FileStoreUtil,A utility class using functionality available since JDK 1.7.
1184,core/util,ch.qos.logback.core.util,Class FileUtil,
1185,core/filter,ch.qos.logback.core.filter,Class Filter<E>,"Users should extend this class to implement customized event filtering. We suggest that you first try to use the built-in rules before rushing to write your own custom filters. For more information about filters, please refer to the online manual at http://logback.qos.ch/manual/filters.html"
1186,core/spi,ch.qos.logback.core.spi,Interface FilterAttachable<E>,Interface for attaching filters to objects.
1187,core/spi,ch.qos.logback.core.spi,Class FilterAttachableImpl<E>,Implementation of FilterAttachable.
1188,chapters/filters,chapters.filters,Class FilterEvents,
1189,core/spi,ch.qos.logback.core.spi,Enum FilterReply,"This enum represents the possible replies that a filtering component in logback can return. It is used by implementations of both Filter and ch.qos.logback.classic.turbo.TurboFilter abstract classes. Based on the order that the FilterReply values are declared, FilterReply.ACCEPT.compareTo(FilterReply.DENY) will return a positive value."
1190,core/util,ch.qos.logback.core.util,Class FixedDelay,A default DelayStrategy that implements a simple fixed delay.
1191,core/rolling,ch.qos.logback.core.rolling,Class FixedWindowRollingPolicy,"When rolling over, FixedWindowRollingPolicy renames files according to a fixed window algorithm. For more information about this policy, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#FixedWindowRollingPolicy"
1192,chapters/configuration,chapters.configuration,Class Foo,
1193,pattern/color,ch.qos.logback.core.pattern.color,Class ForegroundCompositeConverterBase<E>,Base class for all foreground color setting composite converters.
1194,core/pattern,ch.qos.logback.core.pattern,Class FormatInfo,FormattingInfo instances contain the information obtained when parsing formatting modifiers in conversion modifiers.
1195,core/pattern,ch.qos.logback.core.pattern,Class FormattingConverter<E>,
1196,pattern/parser,ch.qos.logback.core.pattern.parser,Class FormattingNode,
1197,access/pattern,ch.qos.logback.access.pattern,Class FullRequestConverter,This class is tied to the fullRequest conversion word. It has been removed from the PatternLayout since it needs further testing before wide use.
1198,access/pattern,ch.qos.logback.access.pattern,Class FullResponseConverter,
1199,core/joran,ch.qos.logback.core.joran,Class GenericConfigurator,
1200,chapters/filters,chapters.filters,Class GoMDC,
1201,pattern/color,ch.qos.logback.core.pattern.color,Class GrayCompositeConverter<E>,Encloses a given set of converter output in gray using the appropriate ANSI escape codes.
1202,pattern/color,ch.qos.logback.core.pattern.color,Class GreenCompositeConverter<E>,Encloses a given set of converter output in green using the appropriate ANSI escape codes.
1203,db/dialect,ch.qos.logback.core.db.dialect,Class H2Dialect,The H2 dialect.
1204,access/net,ch.qos.logback.access.net,Class HardenedAccessEventInputStream,
1205,net/server,ch.qos.logback.classic.net.server,Class HardenedLoggingEventInputStream,
1206,core/net,ch.qos.logback.core.net,Class HardenedObjectInputStream,"HardenedObjectInputStream restricts the set of classes that can be deserialized to a set of explicitly whitelisted classes. This prevents certain type of attacks from being successful. It is assumed that classes in the ""java.lang"" and ""java.util"" packages are always authorized."
1207,onJoran/helloWorld,chapters.onJoran.helloWorld,Class HelloWorld,A hello world example using Joran.
1208,chapters/introduction,chapters.introduction,Class HelloWorld1,
1209,chapters/introduction,chapters.introduction,Class HelloWorld2,
1210,onJoran/helloWorld,chapters.onJoran.helloWorld,Class HelloWorldAction,"A trivial action that writes ""Hello world"" on the console. See the HelloWorld class for integration with Joran."
1211,pattern/color,ch.qos.logback.classic.pattern.color,Class HighlightingCompositeConverter,"Highlights inner-text depending on the level, in bold red for events of level ERROR, in red for WARN, in BLUE for INFO, and in the default color for other levels."
1212,joran/spi,ch.qos.logback.core.joran.spi,Class HostClassAndPropertyDouble,A 2-tuple (a double) consisting of a Class and a String. The Class references the hosting class of a component and the String represents the property name under which a nested component is referenced the host. This class is used by DefaultNestedComponentRegistry.
1213,db/dialect,ch.qos.logback.core.db.dialect,Class HSQLDBDialect,The HSQLDB dialect.
1214,access/html,ch.qos.logback.access.html,Class HTMLLayout,"HTMLLayout outputs events in an HTML table. The content of the table columns are specified using a conversion pattern. See PatternLayout for documentation on the available patterns. For more information about this layout, please refer to the online manual at http://logback.qos.ch/manual/layouts.html#AccessHTMLLayout"
1215,classic/html,ch.qos.logback.classic.html,Class HTMLLayout,"HTMLLayout outputs events in an HTML table. The content of the table columns are specified using a conversion pattern. See PatternLayout for documentation on the available patterns. For more information about this layout, please refer to the online manual at http://logback.qos.ch/manual/layouts.html#ClassicHTMLLayout"
1216,core/html,ch.qos.logback.core.html,Class HTMLLayoutBase<E>,This class is a base class for HTMLLayout classes part of other logback modules such as logback-classic and logback-access.
1217,access/spi,ch.qos.logback.access.spi,Interface IAccessEvent,The Access module's internal representation of logging events. When the logging component instance is called in the container to log then a AccessEvent instance is created. This instance is passed around to the different logback components.
1218,joran/action,ch.qos.logback.core.joran.action,Class IADataForComplexProperty,Lump together several fields for use by NestedComplexPropertyIA.
1219,core/pattern,ch.qos.logback.core.pattern,Class IdentityCompositeConverter<E>,
1220,pattern/util,ch.qos.logback.core.pattern.util,Interface IEscapeUtil,
1221,classic/boolex,ch.qos.logback.classic.boolex,Interface IEvaluator,An internal interface used by the GEventEvaluator.
1222,joran/conditional,ch.qos.logback.core.joran.conditional,Class IfAction,
1223,classic/spi,ch.qos.logback.classic.spi,Interface ILoggingEvent,"The central interface in logback-classic. In a nutshell, logback-classic is nothing more than a processing chain built around this interface."
1224,joran/action,ch.qos.logback.core.joran.action,Class ImplicitAction,"ImplcitActions are like normal (explicit) actions except that are applied by the parser when no other pattern applies. Since there can be many implicit actions, each action is asked whether it applies in the given context. The first implicit action to respond positively is then applied. See also the isApplicable(ch.qos.logback.core.joran.spi.ElementPath, org.xml.sax.Attributes, ch.qos.logback.core.joran.spi.InterpretationContext) method."
1225,joran/action,ch.qos.logback.core.joran.action,Class IncludeAction,
1226,core/util,ch.qos.logback.core.util,Class IncompatibleClassException,
1227,core/status,ch.qos.logback.core.status,Class InfoStatus,
1228,joran/event,ch.qos.logback.core.joran.event,Interface InPlayListener,
1229,joran/action,ch.qos.logback.classic.joran.action,Class InsertFromJNDIAction,Insert an env-entry found in JNDI as a new context variable
1230,rolling/helper,ch.qos.logback.core.rolling.helper,Class IntegerTokenConverter,"When asked to convert an integer, IntegerTokenConverter the string value of that integer."
1231,joran/spi,ch.qos.logback.core.joran.spi,Class InterpretationContext,An InterpretationContext contains the contextual state of a Joran parsing session. Action objects depend on this context to exchange and store information.
1232,joran/spi,ch.qos.logback.core.joran.spi,Class Interpreter,"Interpreter is Joran's main driving class. It extends SAX DefaultHandler which invokes various actions according to predefined patterns. Patterns are kept in a RuleStore which is programmed to store and then later produce the applicable actions for a given pattern. The pattern corresponding to a top level <a> element is the string ""a"". The pattern corresponding to an element <b> embedded within a top level <a> element is the string ""a/b"". The pattern corresponding to an <b> and any level of nesting is ""*/b. Thus, the * character placed at the beginning of a pattern serves as a wildcard for the level of nesting. Conceptually, this is very similar to the API of commons-digester. Joran offers several small advantages. First and foremost, it offers support for implicit actions which result in a significant leap in flexibility. Second, in our opinion better error reporting capability. Third, it is self-reliant. It does not depend on other APIs, in particular commons-logging which is too unreliable. Last but not least, Joran is quite tiny and is expected to remain so."
1233,core/util,ch.qos.logback.core.util,Class InterruptUtil,"Allows masking of interrupt flag if previously the flag is already set. Does nothing otherwise. Typical use: InterruptUtil interruptUtil = new InterruptUtil(context); try { interruptUtil.maskInterruptFlag(); someOtherThread.join(delay); } catch(InterruptedException e) { // reachable only if join does not succeed within delay. // Without the maskInterruptFlag() call, the join() would have returned immediately // had the current thread been interrupted previously, i.e. before entering the above block } finally { interruptUtil.unmaskInterruptFlag(); }"
1234,core/util,ch.qos.logback.core.util,Interface InvocationGate,
1235,chapters/appenders,chapters.appenders,Class IO,
1236,chapters/appenders,chapters.appenders,Class IOPerformance,
1237,classic/spi,ch.qos.logback.classic.spi,Interface IThrowableProxy,
1238,core/html,ch.qos.logback.core.html,Interface IThrowableRenderer<E>,
1239,access/boolex,ch.qos.logback.access.boolex,Class JaninoEventEvaluator,
1240,classic/boolex,ch.qos.logback.classic.boolex,Class JaninoEventEvaluator,
1241,core/boolex,ch.qos.logback.core.boolex,Class JaninoEventEvaluatorBase<E>,Abstract class which sets the groundwork for janino based evaluations.
1242,access/jetty,ch.qos.logback.access.jetty,Class JettyServerAdapter,A jetty specific implementation of the ServerAdapter interface.
1243,classic/jmx,ch.qos.logback.classic.jmx,Class JMXConfigurator,A class that provides access to logback components via JMX. Since this class implements JMXConfiguratorMBean it has to be named as JMXConfigurator}.
1244,joran/action,ch.qos.logback.classic.joran.action,Class JMXConfiguratorAction,
1245,classic/jmx,ch.qos.logback.classic.jmx,Interface JMXConfiguratorMBean,
1246,classic/sift,ch.qos.logback.classic.sift,Class JNDIBasedContextDiscriminator,"This discriminator returns the value context as determined by JNDI. If the said value is null, then a default value is returned. Both Key and the DefaultValue are user specified properties."
1247,core/db,ch.qos.logback.core.db,Class JNDIConnectionSource,"The JNDIConnectionSource is an implementation of ConnectionSource that obtains a DataSource from a JNDI provider and uses it to obtain a Connection. It is primarily designed to be used inside of J2EE application servers or application server clients, assuming the application server supports remote access of DataSources. In this way one can take advantage of connection pooling and whatever other goodies the application server provides. For more information about this component, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#DBAppender"
1248,classic/util,ch.qos.logback.classic.util,Class JNDIUtil,A simple utility class to create and use a JNDI Context.
1249,access/joran,ch.qos.logback.access.joran,Class JoranConfigurator,This JoranConfiguratorclass adds rules specific to logback-access.
1250,classic/joran,ch.qos.logback.classic.joran,Class JoranConfigurator,JoranConfigurator class adds rules specific to logback-classic.
1251,core/joran,ch.qos.logback.core.joran,Class JoranConfiguratorBase<E>,A JoranConfiguratorBase lays most of the groundwork for concrete configurators derived from it. Concrete configurators only need to implement the addInstanceRules(ch.qos.logback.core.joran.spi.RuleStore) method. A JoranConfiguratorBase instance should not be used more than once to configure a Context.
1252,joran/spi,ch.qos.logback.core.joran.spi,Class JoranException,
1253,classic/jul,ch.qos.logback.classic.jul,Class JULHelper,
1254,net/ssl,ch.qos.logback.core.net.ssl,Class KeyManagerFactoryFactoryBean,A factory bean for a JSSE KeyManagerFactory. This object holds the configurable properties of a key manager factory and uses them to create and load a KeyManagerFactory instance.
1255,net/ssl,ch.qos.logback.core.net.ssl,Class KeyStoreFactoryBean,A factory bean for a JCA KeyStore. This object holds the configurable properties of a key store and uses them to create and load a KeyStore instance.
1256,logback/core,ch.qos.logback.core,Interface Layout<E>,
1257,logback/core,ch.qos.logback.core,Class LayoutBase<E>,
1258,core/encoder,ch.qos.logback.core.encoder,Class LayoutWrappingEncoder<E>,
1259,logback/classic,ch.qos.logback.classic,Class Level,"Defines the set of levels recognized by logback-classic, that is OFF, ERROR, WARN, INFO, DEBUG, TRACE and ALL. The Level class is final and cannot be sub-classed."
1260,joran/action,ch.qos.logback.classic.joran.action,Class LevelAction,Action to handle the element nested within element. This action is deprecated. Use the level attribute within the logger element.
1261,classic/jul,ch.qos.logback.classic.jul,Class LevelChangePropagator,Propagate level changes made to a logback logger into the equivalent logger in j.u.l.
1262,classic/pattern,ch.qos.logback.classic.pattern,Class LevelConverter,Return the event's level.
1263,classic/filter,ch.qos.logback.classic.filter,Class LevelFilter,"A class that filters events by the level equality. For more information about this filter, please refer to the online manual at http://logback.qos.ch/manual/filters.html#levelFilter"
1264,classic/util,ch.qos.logback.classic.util,Class LevelToSyslogSeverity,
1265,core/spi,ch.qos.logback.core.spi,Interface LifeCycle,
1266,logback/core,ch.qos.logback.core,Class LifeCycleManager,An object that manages a collection of components that implement the LifeCycle interface. Each component that is added to the manager will be stopped and removed from the manager when the manager is reset.
1267,classic/pattern,ch.qos.logback.classic.pattern,Class LineOfCallerConverter,
1268,access/pattern,ch.qos.logback.access.pattern,Class LineSeparatorConverter,
1269,classic/pattern,ch.qos.logback.classic.pattern,Class LineSeparatorConverter,
1270,core/read,ch.qos.logback.core.read,Class ListAppender<E>,
1271,onJoran/calculator,chapters.onJoran.calculator,Class LiteralAction,This action converts the value attribute of the associated element to an integer and pushes the resulting Integer object on top of the execution context stack. It also illustrates usage of Joran's error reporting/handling paradigm.
1272,core/pattern,ch.qos.logback.core.pattern,Class LiteralConverter<E>,
1273,core/util,ch.qos.logback.core.util,Class Loader,Load resources (or images) from various sources.
1274,access/pattern,ch.qos.logback.access.pattern,Class LocalIPAddressConverter,
1275,access/pattern,ch.qos.logback.access.pattern,Class LocalPortConverter,
1276,classic/pattern,ch.qos.logback.classic.pattern,Class LocalSequenceNumberConverter,A converters based on a a locally incremented sequence number. The sequence number is initialized to the number of milliseconds elapsed since 1970-01-01 until this instance is initialized. EXPERIMENTAL This class is experimental and may be removed in the future.
1277,core/util,ch.qos.logback.core.util,Class LocationUtil,A static utility method that converts a string that describes the location of a resource into a URL object.
1278,chapters/migrationFromLog4j,chapters.migrationFromLog4j,Class Log4jMain,A minimal application making use of log4j and TrivialLog4jAppender.
1279,logback/core,ch.qos.logback.core,Class LogbackException,
1280,core/spi,ch.qos.logback.core.spi,Class LogbackLock,This class just makes it easier to identify locks associated with logback when analysing thread dumps.
1281,chapters/migrationFromLog4j,chapters.migrationFromLog4j,Class LogbackMain,A minimal application making use of logback-classic. It uses the configuration file logback-trivial.xml which makes use of TrivialLogbackAppender.
1282,classic/util,ch.qos.logback.classic.util,Class LogbackMDCAdapter,"A Mapped Diagnostic Context, or MDC in short, is an instrument for distinguishing interleaved log output from different sources. Log output is typically interleaved when a server handles multiple clients near-simultaneously. The MDC is managed on a per thread basis. A child thread automatically inherits a copy of the mapped diagnostic context of its parent. For more information about MDC, please refer to the online manual at http://logback.qos.ch/manual/mdc.html"
1283,classic/spi,ch.qos.logback.classic.spi,Class LogbackServiceProvider,
1284,classic/servlet,ch.qos.logback.classic.servlet,Class LogbackServletContainerInitializer,Attaches a new instance of LogbackServletContextListener to the current web-applications ServletContext.
1285,classic/servlet,ch.qos.logback.classic.servlet,Class LogbackServletContextListener,Allows for graceful shutdown of the LoggerContext associated with this web-app.
1286,access/tomcat,ch.qos.logback.access.tomcat,Class LogbackValve,"This class is an implementation of tomcat's Valve interface, by extending ValveBase. For more information on using LogbackValve please refer to the online documentation on logback-acces and tomcat."
1287,logback/classic,ch.qos.logback.classic,Class Logger,
1288,joran/action,ch.qos.logback.classic.joran.action,Class LoggerAction,Action which handles elements in configuration files.
1289,classic/spi,ch.qos.logback.classic.spi,Class LoggerComparator,
1290,logback/classic,ch.qos.logback.classic,Class LoggerContext,"LoggerContext glues many of the logback-classic components together. In principle, every logback-classic component instance is attached either directly or indirectly to a LoggerContext instance. Just as importantly LoggerContext implements the ILoggerFactory acting as the manufacturing source of Logger instances."
1291,classic/spi,ch.qos.logback.classic.spi,Interface LoggerContextAware,
1292,classic/spi,ch.qos.logback.classic.spi,Class LoggerContextAwareBase,
1293,selector/servlet,ch.qos.logback.classic.selector.servlet,Class LoggerContextFilter,"A servlet filter that puts the environment dependent LoggerContext in a ThreadLocal variable, removing it after the request is processed. To use it, add the following lines to a web.xml file LoggerContextFilter ch.qos.logback.classic.selector.servlet.LoggerContextFilter LoggerContextFilter/*"
1294,classic/spi,ch.qos.logback.classic.spi,Interface LoggerContextListener,
1295,joran/action,ch.qos.logback.classic.joran.action,Class LoggerContextListenerAction,
1296,classic/spi,ch.qos.logback.classic.spi,Class LoggerContextVO,"LoggerContextVO offers a restricted view of LoggerContext intended to be exposed by LoggingEvent to remote systems. This restricted view is optimized for serialization. Some of the LoggerContext or Logger attributes MUST not survive serialization, e.g appenders, level values etc, as these attributes may have other values on the remote platform. LoggerContextVO class exposes the minimal and relevant attributes to the remote host, instead of having to deal with an incomplete LoggerContext with many null references."
1297,classic/pattern,ch.qos.logback.classic.pattern,Class LoggerConverter,
1298,classic/util,ch.qos.logback.classic.util,Class LoggerNameUtil,Utility class for analysing logger names.
1299,classic/spi,ch.qos.logback.classic.spi,Class LoggerRemoteView,An interface that allows Logger objects and LoggerSer objects to be used the same way be client of the LoggingEvent object. See LoggerContextVO for the rationale of this class.
1300,classic/spi,ch.qos.logback.classic.spi,Class LoggingEvent,"The internal representation of logging events. When an affirmative decision is made to log then a LoggingEvent instance is created. This instance is passed around to the different logback-classic components. Writers of logback-classic components such as appenders should be aware of that some of the LoggingEvent fields are initialized lazily. Therefore, an appender wishing to output data to be later correctly read by a receiver, must initialize ""lazy"" fields prior to writing them out. See the prepareForDeferredProcessing() method for the exact list."
1301,classic/net,ch.qos.logback.classic.net,Class LoggingEventPreSerializationTransformer,
1302,classic/spi,ch.qos.logback.classic.spi,Class LoggingEventVO,A read-only and serializable implementation of ILoggingEvent.
1303,core/net,ch.qos.logback.core.net,Class LoginAuthenticator,Used by SMTPAppender for authentication purposes.
1304,pattern/color,ch.qos.logback.core.pattern.color,Class MagentaCompositeConverter<E>,Encloses a given set of converter output in magenta using the appropriate ANSI escape codes.
1305,appenders/mail,chapters.appenders.mail,Class Marked_EMail,"This application generates a number of message many of which are of LEVEL. However, only one message bears the ""NOTIFY_ADMIN"" marker."
1306,classic/pattern,ch.qos.logback.classic.pattern,Class MarkerConverter,Return the event's marker value(s).
1307,classic/turbo,ch.qos.logback.classic.turbo,Class MarkerFilter,Checks whether the marker in the event matches the marker specified by the user.
1308,core/boolex,ch.qos.logback.core.boolex,Class Matcher,
1309,classic/turbo,ch.qos.logback.classic.turbo,Class MatchingFilter,"An abstract class containing support for onMatch on onMismatch attributes, shared by many but not all turbo filters."
1310,classic/jmx,ch.qos.logback.classic.jmx,Class MBeanUtil,
1311,classic/sift,ch.qos.logback.classic.sift,Class MDCBasedDiscriminator,"MDCBasedDiscriminator essentially returns the value mapped to an MDC key. If the said value is null, then a default value is returned. Both Key and the DefaultValue are user specified properties."
1312,classic/pattern,ch.qos.logback.classic.pattern,Class MDCConverter,
1313,classic/turbo,ch.qos.logback.classic.turbo,Class MDCFilter,"This class allows output for a given MDC value. When the given value is identified by this TurboFilter, the reply is based on the OnMatch option. The information is taken from the MDC. For this TurboFilter to work, one must set the key that will be used to access the information in the MDC. To allow output for the value, set the OnMatch option to ACCEPT. To disable output for the given value, set the OnMatch option to DENY. By default, values of the OnMatch and OnMisMatch options are set to NEUTRAL."
1314,classic/helpers,ch.qos.logback.classic.helpers,Class MDCInsertingServletFilter,A servlet filter that inserts various values retrieved from the incoming http request into the MDC. The values are removed after the request is processed.
1315,classic/turbo,ch.qos.logback.classic.turbo,Class MDCValueLevelPair,Bean pairing an MDC value with a log level.
1316,classic/pattern,ch.qos.logback.classic.pattern,Class MessageConverter,Return the event's formatted message.
1317,classic/pattern,ch.qos.logback.classic.pattern,Class MethodOfCallerConverter,
1318,rolling/helper,ch.qos.logback.core.rolling.helper,Interface MonoTypedConverter,Converters which can deal only with one type should implement this interface.
1319,db/dialect,ch.qos.logback.core.db.dialect,Class MsSQLDialect,The MS SQL Server dialect is untested. Note that the dialect is not needed if your JDBC driver supports the getGeneratedKeys method introduced in JDBC 3.0 specification.
1320,onJoran/calculator,chapters.onJoran.calculator,Class MultiplyAction,This action multiplies the two integers at the top of the stack (they are removed) and pushes the result on top the stack.
1321,chapters/configuration,chapters.configuration,Class MyApp1,
1322,chapters/configuration,chapters.configuration,Class MyApp2,
1323,chapters/configuration,chapters.configuration,Class MyApp3,
1324,chapters/architecture,chapters.architecture,Class MyAppWithConfigFile,
1325,chapters/layouts,chapters.layouts,Class MySampleConverter,
1326,chapters/layouts,chapters.layouts,Class MySampleLayout,
1327,chapters/layouts,chapters.layouts,Class MySampleLayout2,
1328,db/dialect,ch.qos.logback.core.db.dialect,Class MySQLDialect,
1329,access/pattern,ch.qos.logback.access.pattern,Class NAConverter,"Always returns the NA (not available) string which is ""-"" in the case of access conversions."
1330,classic/pattern,ch.qos.logback.classic.pattern,Class NamedConverter,
1331,joran/action,ch.qos.logback.core.joran.action,Class NestedBasicPropertyIA,This action is responsible for tying together a parent object with one of its simple properties specified as an element but for which there is no explicit rule.
1332,joran/action,ch.qos.logback.core.joran.action,Class NestedComplexPropertyIA,This action is responsible for tying together a parent object with a child element for which there is no explicit rule.
1333,core/util,ch.qos.logback.core.util,Class NetworkAddressUtil,
1334,joran/action,ch.qos.logback.core.joran.action,Class NewRuleAction,
1335,onJoran/newRule,chapters.onJoran.newRule,Class NewRuleCalculator,This example illustrates the usage of NewRuleAction which allows the Joran interpreter to learn new rules on the fly. This example relies heavily on the code from the joran.calculator package.
1336,joran/spi,ch.qos.logback.core.joran.spi,Annotation Type NoAutoStart,"If a type (a class) has this annotation, then it will not be automatically started by Joran at configuration time."
1337,joran/spi,ch.qos.logback.core.joran.spi,Class NoAutoStartUtil,
1338,pattern/parser,ch.qos.logback.core.pattern.parser,Class Node,
1339,core/subst,ch.qos.logback.core.subst,Class Node,
1340,core/subst,ch.qos.logback.core.subst,Class NodeToStringTransformer,Compiles a previously parsed Node chain into a String.
1341,core/encoder,ch.qos.logback.core.encoder,Class NonClosableInputStream,
1342,joran/action,ch.qos.logback.core.joran.action,Class NOPAction,No operation (NOP) action that does strictly nothing. Setting a rule to this pattern is sometimes useful in order to prevent implicit actions to kick in.
1343,onJoran/implicit,chapters.onJoran.implicit,Class NOPAction,No operation (NOP) action that does strictly nothing.
1344,core/helpers,ch.qos.logback.core.helpers,Class NOPAppender<E>,
1345,core/status,ch.qos.logback.core.status,Class NopStatusListener,A no-operation (nop) StatusListener
1346,classic/pattern,ch.qos.logback.classic.pattern,Class NopThrowableInformationConverter,"Always returns an empty string. This converter is useful to pretend that the converter chain for PatternLayout actually handles exceptions, when in fact it does not. By adding %nopex to the conversion pattern, the user can bypass the automatic addition of %ex conversion pattern for patterns which do not contain a converter handling exceptions. Users can ignore the existence of this converter, unless they want to suppress the automatic printing of exceptions by PatternLayout."
1347,core/html,ch.qos.logback.core.html,Class NOPThrowableRenderer,
1348,chapters/mdc,chapters.mdc,Interface NumberCruncher,NumberCruncher factors positive integers.
1349,chapters/mdc,chapters.mdc,Class NumberCruncherClient,NumberCruncherClient is a simple client for factoring integers. A remote NumberCruncher is contacted and asked to factor an integer. The factors returned by the NumberCruncherServer are displayed on the screen.
1350,chapters/mdc,chapters.mdc,Class NumberCruncherServer,A simple NumberCruncher implementation that logs its progress when factoring numbers. The purpose of the whole exercise is to show the use of mapped diagnostic contexts in order to distinguish the log output from different client requests.
1351,core/net,ch.qos.logback.core.net,Interface ObjectWriter,Writes objects to an output.
1352,core/net,ch.qos.logback.core.net,Class ObjectWriterFactory,Factory for ObjectWriter instances.
1353,core/status,ch.qos.logback.core.status,Class OnConsoleStatusListener,Print all new incoming status messages on the console (System.out).
1354,core/status,ch.qos.logback.core.status,Class OnErrorConsoleStatusListener,Print all new incoming status messages on the error console (System.err).
1355,classic/boolex,ch.qos.logback.classic.boolex,Class OnErrorEvaluator,Evaluates to true when the logging event passed as parameter has level ERROR or higher.
1356,classic/boolex,ch.qos.logback.classic.boolex,Class OnMarkerEvaluator,Evaluates to true when the logging event passed as parameter contains one of the user-specified markers.
1357,core/status,ch.qos.logback.core.status,Class OnPrintStreamStatusListenerBase,Print all new incoming status messages on the on the designated PrintStream.
1358,core/util,ch.qos.logback.core.util,Class OptionHelper,
1359,pattern/parser,ch.qos.logback.core.pattern.parser,Class OptionTokenizer,
1360,db/dialect,ch.qos.logback.core.db.dialect,Class OracleDialect,The Oracle dialect. Tested successfully on Oracle9i Release 9.2.0.3.0 by James Stauffer.
1361,logback/core,ch.qos.logback.core,Class OutputStreamAppender<E>,"OutputStreamAppender appends events to a OutputStream. This class provides basic services that other appenders build upon. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#OutputStreamAppender"
1362,classic/spi,ch.qos.logback.classic.spi,Class PackagingDataCalculator,"Given a classname locate associated PackageInfo (jar name, version name)."
1363,joran/action,ch.qos.logback.core.joran.action,Class ParamAction,
1364,pattern/parser,ch.qos.logback.core.pattern.parser,Class Parser<E>,
1365,core/subst,ch.qos.logback.core.subst,Class Parser,Parse a token list returning a node chain.
1366,logback/access,ch.qos.logback.access,Class PatternLayout,"This class is a module-specific implementation of PatternLayout to allow http-specific patterns to be used. The ch.qos.logback.access.PatternLayout provides a way to format the logging output that is just as easy and flexible as the usual PatternLayout. For more information about this layout, please refer to the online manual at http://logback.qos.ch/manual/layouts.html#AccessPatternLayout"
1367,logback/classic,ch.qos.logback.classic,Class PatternLayout,"A flexible layout configurable with pattern string. The goal of this class is to format a ILoggingEvent and return the results in a {#link String}. The format of the result depends on the conversion pattern. For more information about this layout, please refer to the online manual at http://logback.qos.ch/manual/layouts.html#PatternLayout"
1368,core/pattern,ch.qos.logback.core.pattern,Class PatternLayoutBase<E>,
1369,logback/access,ch.qos.logback.access,Class PatternLayoutEncoder,
1370,classic/encoder,ch.qos.logback.classic.encoder,Class PatternLayoutEncoder,
1371,core/pattern,ch.qos.logback.core.pattern,Class PatternLayoutEncoderBase<E>,
1372,chapters/layouts,chapters.layouts,Class PatternSample,
1373,rolling/helper,ch.qos.logback.core.rolling.helper,Enum PeriodicityType,
1374,access/filter,ch.qos.logback.access.filter,Class PeriodicStats,
1375,classic/spi,ch.qos.logback.classic.spi,Class PlatformInfo,This class provides information about the runtime platform.
1376,core/pattern,ch.qos.logback.core.pattern,Interface PostCompileProcessor<E>,"Implements this to perform post compile processing for a PatternLayout. For example, PatternLayout in the classic module should add a converter for exception handling (otherwise exceptions would not be printed)."
1377,db/dialect,ch.qos.logback.core.db.dialect,Class PostgreSQLDialect,
1378,core/spi,ch.qos.logback.core.spi,Interface PreSerializationTransformer<E>,PreSerializationTransformer instances have the responsibility to transform object into a presumably equivalent serializable representation.
1379,onJoran/implicit,chapters.onJoran.implicit,Class PrintMe,"This example illustrates the usage of implicit actions. Keep in mind that implicit actions are not associated with any specific pattern. Moreover, they are added directly to a Joran Interpreter instead of a rule store."
1380,onJoran/implicit,chapters.onJoran.implicit,Class PrintMeImplicitAction,A rather trivial implicit action which is applicable if an element has a printme attribute set to true.
1381,joran/action,ch.qos.logback.core.joran.action,Class PropertyAction,"This class serves as a base for other actions, which similar to the ANT <property> task which add/set properties of a given object. This action sets new substitution properties in the logging context by name, value pair, or adds all the properties passed in ""file"" or ""resource"" attribute."
1382,core/spi,ch.qos.logback.core.spi,Interface PropertyContainer,
1383,classic/pattern,ch.qos.logback.classic.pattern,Class PropertyConverter,
1384,core/spi,ch.qos.logback.core.spi,Interface PropertyDefiner,
1385,logback/core,ch.qos.logback.core,Class PropertyDefinerBase,A skeleton implementation for property definers so that they derive from ContextAwareBase.
1386,joran/conditional,ch.qos.logback.core.joran.conditional,Class PropertyEvalScriptBuilder,
1387,joran/util,ch.qos.logback.core.joran.util,Class PropertySetter,"General purpose Object property setter. Clients repeatedly invokes setProperty(name,value) in order to invoke setters on the Object specified in the constructor. This class relies on reflection to analyze the given Object Class. Usage: PropertySetter ps = new PropertySetter(anObject); ps.set(""name"", ""Joe""); ps.set(""age"", ""32""); ps.set(""isMale"", ""true""); will cause the invocations anObject.setName(""Joe""), anObject.setAge(32), and setMale(true) if such methods exist with those signatures. Otherwise an PropertySetterException is thrown."
1388,core/util,ch.qos.logback.core.util,Class PropertySetterException,Thrown when an error is encountered whilst attempting to set a property using the PropertySetter utility class.
1389,joran/conditional,ch.qos.logback.core.joran.conditional,Class PropertyWrapperForScripts,
1390,access/pattern,ch.qos.logback.access.pattern,Class QueryStringConverter,
1391,core/net,ch.qos.logback.core.net,Class QueueFactory,Factory for Queue instances.
1392,joran/action,ch.qos.logback.classic.joran.action,Class ReceiverAction,A Joran Action for a SocketReceiver configuration.
1393,classic/net,ch.qos.logback.classic.net,Class ReceiverBase,An abstract base for components that receive logging events from a remote peer and log according to local policy
1394,receivers/socket,chapters.receivers.socket,Class ReceiverExample,This application loads a configuration containing a receiver component and logs events received from the remote appender according to the local configuration.
1395,classic/turbo,ch.qos.logback.classic.turbo,Class ReconfigureOnChangeFilter,Reconfigure a LoggerContext when the configuration file changes.
1396,classic/joran,ch.qos.logback.classic.joran,Class ReconfigureOnChangeTask,
1397,classic/joran,ch.qos.logback.classic.joran,Class ReconfigureOnChangeTaskListener,
1398,core/recovery,ch.qos.logback.core.recovery,Class RecoveryCoordinator,
1399,pattern/color,ch.qos.logback.core.pattern.color,Class RedCompositeConverter<E>,Encloses a given set of converter output in red using the appropriate ANSI escape codes.
1400,pattern/util,ch.qos.logback.core.pattern.util,Class RegularEscapeUtil,This implementation is intended for use in PatternLayout.
1401,classic/pattern,ch.qos.logback.classic.pattern,Class RelativeTimeConverter,
1402,access/pattern,ch.qos.logback.access.pattern,Class RemoteHostConverter,
1403,access/pattern,ch.qos.logback.access.pattern,Class RemoteIPAddressConverter,
1404,access/pattern,ch.qos.logback.access.pattern,Class RemoteUserConverter,
1405,rolling/helper,ch.qos.logback.core.rolling.helper,Class RenameUtil,Utility class to help solving problems encountered while renaming files.
1406,core/pattern,ch.qos.logback.core.pattern,Class ReplacingCompositeConverter<E>,
1407,access/pattern,ch.qos.logback.access.pattern,Class RequestAttributeConverter,
1408,access/pattern,ch.qos.logback.access.pattern,Class RequestContentConverter,This class is tied to the requestContent conversion word. It has been removed from the PatternLayout since it needs further testing before wide use.
1409,access/pattern,ch.qos.logback.access.pattern,Class RequestCookieConverter,
1410,access/pattern,ch.qos.logback.access.pattern,Class RequestHeaderConverter,
1411,access/jetty,ch.qos.logback.access.jetty,Class RequestLogImpl,"This class is logback's implementation of jetty's RequestLog interface. It can be seen as logback classic's LoggerContext. Appenders can be attached directly to RequestLogImpl and RequestLogImpl uses the same StatusManager as LoggerContext does. It also provides containers for properties. To configure jetty in order to use RequestLogImpl, the following lines must be added to the jetty configuration file, namely etc/jetty.xml: <Ref id=""requestLog""> <Set name=""requestLog""> <New id=""requestLogImpl"" class=""ch.qos.logback.access.jetty.RequestLogImpl""></New> </Set> </Ref> By default, RequestLogImpl looks for a logback configuration file called logback-access.xml, in the same folder where jetty.xml is located, that is etc/logback-access.xml. The logback-access.xml file is slightly different than the usual logback classic configuration file. Most of it is the same: Appenders and Layouts are declared the exact same way. However, loggers elements are not allowed. It is possible to put the logback configuration file anywhere, as long as it's path is specified. Here is another example, with a path to the logback-access.xml file. <Ref id=""requestLog""> <Set name=""requestLog""> <New id=""requestLogImpl"" class=""ch.qos.logback.access.jetty.RequestLogImpl""></New> <Set name=""fileName"">path/to/logback.xml</Set> </Set> </Ref> Here is a sample logback-access.xml file that can be used right away: <configuration> <appender name=""STDOUT"" class=""ch.qos.logback.core.ConsoleAppender""> <layout class=""ch.qos.logback.access.PatternLayout""> <param name=""Pattern"" value=""%date %server %remoteIP %clientHost %user %requestURL"" /> </layout> </appender> <appender-ref ref=""STDOUT"" /> </configuration> Another configuration file, using SMTPAppender, could be: <configuration> <appender name=""SMTP"" class=""ch.qos.logback.access.net.SMTPAppender""> <layout class=""ch.qos.logback.access.PatternLayout""> <param name=""pattern"" value=""%remoteIP [%date] %requestURL %statusCode %bytesSent"" /> </layout> <param name=""From"" value=""sender@domaine.org"" /> <param name=""SMTPHost"" value=""mail.domain.org"" /> <param name=""Subject"" value=""Last Event: %statusCode %requestURL"" /> <param name=""To"" value=""server_admin@domain.org"" /> </appender> <appender-ref ref=""SMTP"" /> </configuration>"
1412,access/jetty,ch.qos.logback.access.jetty,Class RequestLogRegistry,
1413,access/pattern,ch.qos.logback.access.pattern,Class RequestMethodConverter,
1414,access/pattern,ch.qos.logback.access.pattern,Class RequestParameterConverter,
1415,access/pattern,ch.qos.logback.access.pattern,Class RequestProtocolConverter,
1416,access/pattern,ch.qos.logback.access.pattern,Class RequestURIConverter,The request URI.
1417,access/pattern,ch.qos.logback.access.pattern,Class RequestURLConverter,The first line of the request.
1418,core/recovery,ch.qos.logback.core.recovery,Class ResilientFileOutputStream,
1419,core/recovery,ch.qos.logback.core.recovery,Class ResilientOutputStreamBase,
1420,core/recovery,ch.qos.logback.core.recovery,Class ResilientSyslogOutputStream,
1421,core/property,ch.qos.logback.core.property,Class ResourceExistsPropertyDefiner,"In conjunction with PropertyAction sets the named variable to ""true"" if the resource specified by the user is available on the class path, ""false"" otherwise."
1422,access/pattern,ch.qos.logback.access.pattern,Class ResponseContentConverter,This class is tied to the requestContent conversion word. It has been removed from the PatternLayout since it needs further testing before wide use.
1423,access/pattern,ch.qos.logback.access.pattern,Class ResponseHeaderConverter,
1424,pattern/util,ch.qos.logback.core.pattern.util,Class RestrictedEscapeUtil,This implementation is intended for use in PatternLayout.
1425,rolling/helper,ch.qos.logback.core.rolling.helper,Class RollingCalendar,"RollingCalendar is a helper class to TimeBasedRollingPolicy or similar timed-based rolling policies. Given a periodicity type and the current time, it computes the start of the next interval (i.e. the triggering date)."
1426,core/rolling,ch.qos.logback.core.rolling,Class RollingFileAppender<E>,"RollingFileAppender extends FileAppender to backup the log files depending on RollingPolicy and TriggeringPolicy. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#RollingFileAppender"
1427,core/rolling,ch.qos.logback.core.rolling,Interface RollingPolicy,"A RollingPolicy is responsible for performing the rolling over of the active log file. The RollingPolicy is also responsible for providing the active log file, that is the live file where logging output will be directed."
1428,core/rolling,ch.qos.logback.core.rolling,Class RollingPolicyBase,"Implements methods common to most, it not all, rolling policies. Currently such methods are limited to a compression mode getter/setter."
1429,core/rolling,ch.qos.logback.core.rolling,Class RolloverFailure,"A RolloverFailure occurs if, for whatever reason a rollover fails."
1430,classic/pattern,ch.qos.logback.classic.pattern,Class RootCauseFirstThrowableProxyConverter,
1431,joran/action,ch.qos.logback.classic.joran.action,Class RootLoggerAction,
1432,joran/spi,ch.qos.logback.core.joran.spi,Interface RuleStore,"As its name indicates, a RuleStore contains 2-tuples consists of a ElementSelector and an Action. As a joran configurator goes through the elements in a document, it asks the rule store whether there are rules matching the current pattern by invoking the matchActions(ElementPath) method."
1433,chapters/filters,chapters.filters,Class SampleFilter,
1434,chapters/layouts,chapters.layouts,Class SampleLogging,
1435,chapters/filters,chapters.filters,Class SampleTurboFilter,
1436,joran/event,ch.qos.logback.core.joran.event,Class SaxEvent,
1437,joran/event,ch.qos.logback.core.joran.event,Class SaxEventRecorder,
1438,core/spi,ch.qos.logback.core.spi,Class ScanException,
1439,net/ssl,ch.qos.logback.core.net.ssl,Class SecureRandomFactoryBean,A factory bean for a JCA SecureRandom generator. This object holds the configurable properties of a secure random generator and uses them to create and load a SecureRandom instance.
1440,chapters/architecture,chapters.architecture,Class SelectionRule,
1441,classic/spi,ch.qos.logback.classic.spi,Interface SequenceNumberGenerator,Generate sequence numbers
1442,access/spi,ch.qos.logback.access.spi,Interface ServerAdapter,An interface to access server-specific methods from the server-independent AccessEvent.
1443,net/server,ch.qos.logback.core.net.server,Interface ServerListener<T extends Client>,"A listener that accepts Client connections on behalf of a ServerRunner. This interface exists primarily to abstract away the details of the listener's underlying ServerSocket and the concurrency associated with handling multiple clients. Such realities make it difficult to create effective unit tests for the ServerRunner that are easy to understand and maintain. This interface captures the only those details about the listener that the ServerRunner cares about; namely, that it is something that has an underlying resource (or resources) that need to be closed before the listener is discarded."
1444,access/pattern,ch.qos.logback.access.pattern,Class ServerNameConverter,
1445,net/server,ch.qos.logback.core.net.server,Interface ServerRunner<T extends Client>,An object that is responsible for the asynchronous execution of a socket server. This interface exists primarily to allow the runner to be mocked for the purpose of unit testing the socket server implementation.
1446,net/server,ch.qos.logback.access.net.server,Class ServerSocketAppender,An appender that listens on a TCP port for connections from remote loggers. Each event delivered to this appender is delivered to all connected remote loggers.
1447,net/server,ch.qos.logback.classic.net.server,Class ServerSocketAppender,An appender that listens on a TCP port for connections from remote loggers. Each event delivered to this appender is delivered to all connected remote loggers.
1448,net/server,ch.qos.logback.core.net.server,Class ServerSocketListener<T extends Client>,A ServerListener that accepts connections on a ServerSocket.
1449,net/server,ch.qos.logback.classic.net.server,Class ServerSocketReceiver,A logging socket server that is configurable using Joran.
1450,access/pattern,ch.qos.logback.access.pattern,Class SessionIDConverter,
1451,core/hook,ch.qos.logback.core.hook,Interface ShutdownHook,Interface describing a logback shutdown hook implementation
1452,joran/action,ch.qos.logback.core.joran.action,Class ShutdownHookAction,Action which handles <shutdownHook> elements in configuration files.
1453,core/hook,ch.qos.logback.core.hook,Class ShutdownHookBase,Base class for classes implementing a Logback ShutdownHook via extension
1454,access/sift,ch.qos.logback.access.sift,Class SiftAction,
1455,classic/sift,ch.qos.logback.classic.sift,Class SiftAction,
1456,appenders/sift,chapters.appenders.sift,Class SiftExample,
1457,access/sift,ch.qos.logback.access.sift,Class SiftingAppender,This appender can contains other appenders which it can build dynamically depending on MDC values. The built appender is specified as part of a configuration file. See the logback manual for further details.
1458,classic/sift,ch.qos.logback.classic.sift,Class SiftingAppender,This appender can contains other appenders which it can build dynamically depending on MDC values. The built appender is specified as part of a configuration file. See the logback manual for further details.
1459,core/sift,ch.qos.logback.core.sift,Class SiftingAppenderBase<E>,"This appender serves as the base class for actual SiftingAppenders implemented by the logback-classic and logback-access modules. In a nutshell, a SiftingAppender contains other appenders which it can build dynamically depending on discriminating values supplied by the event currently being processed. The appender to build (dynamically) is specified as part of a configuration file."
1460,access/sift,ch.qos.logback.access.sift,Class SiftingJoranConfigurator,
1461,classic/sift,ch.qos.logback.classic.sift,Class SiftingJoranConfigurator,
1462,core/sift,ch.qos.logback.core.sift,Class SiftingJoranConfiguratorBase<E>,
1463,chapters/onJoran,chapters.onJoran,Class SimpleConfigurator,A minimal configurator extending GenericConfigurator.
1464,db/names,ch.qos.logback.classic.db.names,Class SimpleDBNameResolver,Adds custom prefix/suffix to table and column names.
1465,pattern/parser,ch.qos.logback.core.pattern.parser,Class SimpleKeywordNode,
1466,chapters/mdc,chapters.mdc,Class SimpleMDC,
1467,joran/spi,ch.qos.logback.core.joran.spi,Class SimpleRuleStore,This class implements the RuleStore interface. It is the rule store implementation used by default in Joran.
1468,access/net,ch.qos.logback.access.net,Class SimpleSocketServer,A simple SocketNode based server. <b>Usage:</b> java ch.qos.logback.access.net.SimpleSocketServer port configFile where port is a part number where the server listens and configFile is an xml configuration file fed to JoranConfigurator.
1469,classic/net,ch.qos.logback.classic.net,Class SimpleSocketServer,A simple SocketNode based server. <b>Usage:</b> java ch.qos.logback.classic.net.SimpleSocketServer port configFile where port is a port number where the server listens and configFile is an xml configuration file fed to JoranConfigurator.
1470,classic/net,ch.qos.logback.classic.net,Class SimpleSSLSocketServer,"A SimpleSocketServer that supports SSL. <b>Usage:</b> java ch.qos.logback.classic.net.ssl.SimpleSSLSocketServer port configFile where port is a port number where the server listens and configFile is an xml configuration file fed to JoranConfigurator. When running the SimpleSSLServerFactory as shown above, it is necessary to configure JSSE system properties using -Dname=value on the command-line when starting the server. In particular, you will probably want/need to configure the following system properties: javax.net.ssl.keyStorejavax.net.ssl.keyStorePasswordjavax.net.ssl.keyStoreTypejavax.net.ssl.trustStorejavax.net.ssl.trustStorePasswordjavax.net.ssl.trustStoreType See the Customizing the JSSE in the JSSE Reference Guide for details on how to set these system properties."
1471,rolling/helper,ch.qos.logback.core.rolling.helper,Class SizeAndTimeBasedArchiveRemover,
1472,core/rolling,ch.qos.logback.core.rolling,Class SizeAndTimeBasedFNATP<E>,
1473,core/rolling,ch.qos.logback.core.rolling,Class SizeAndTimeBasedRollingPolicy<E>,
1474,core/rolling,ch.qos.logback.core.rolling,Class SizeBasedTriggeringPolicy<E>,"SizeBasedTriggeringPolicy looks at size of the file being currently written to. If it grows bigger than the specified size, the FileAppender using the SizeBasedTriggeringPolicy rolls the file and creates a new one. For more information about this policy, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#SizeBasedTriggeringPolicy"
1475,access/net,ch.qos.logback.access.net,Class SMTPAppender,"Send an e-mail when a specific access event occurs, typically when certain pages are accessed. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#AccessSMTPAppender"
1476,classic/net,ch.qos.logback.classic.net,Class SMTPAppender,"Send an e-mail when a specific logging event occurs, typically on errors or fatal errors. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#SMTPAppender"
1477,core/net,ch.qos.logback.core.net,Class SMTPAppenderBase<E>,An abstract class that provides support for sending events to an email address. See http://logback.qos.ch/manual/appenders.html#SMTPAppender for further documentation.
1478,access/net,ch.qos.logback.access.net,Class SocketAppender,"Sends IAccessEvent objects to a remote a log server, usually a SocketNode. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#AccessSocketAppender"
1479,classic/net,ch.qos.logback.classic.net,Class SocketAppender,"Sends ILoggingEvent objects to a remote a log server, usually a SocketNode. For more information on this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#SocketAppender"
1480,appenders/socket,chapters.appenders.socket,Class SocketClient1,This application uses a SocketAppender that log messages to a server on a host and port specified by the user. It waits for the user to type a message which will be sent to the server.
1481,appenders/socket,chapters.appenders.socket,Class SocketClient2,This application uses a SocketAppender that log messages to a server on a host and port specified by the user. It waits for the user to type a message which will be sent to the server.
1482,core/net,ch.qos.logback.core.net,Interface SocketConnector,A Runnable that (re)connects a socket. An implementation of this interface is responsible for repeatedly attempting to create a socket connection to a remote host.
1483,core/net,ch.qos.logback.core.net,Interface SocketConnector.ExceptionHandler,An exception handler that is notified of all exceptions that occur during the (re)connection process.
1484,access/net,ch.qos.logback.access.net,Class SocketNode,"Read IAccessEvent objects sent from a remote client using Sockets (TCP). These logging events are logged according to local policy, as if they were generated locally. For example, the socket node might decide to log events to a local file and also resent them to a second socket node."
1485,classic/net,ch.qos.logback.classic.net,Class SocketNode,"Read ILoggingEvent objects sent from a remote client using Sockets (TCP). These logging events are logged according to local policy, as if they were generated locally. For example, the socket node might decide to log events to a local file and also resent them to a second socket node."
1486,classic/net,ch.qos.logback.classic.net,Class SocketReceiver,A component that receives serialized ILoggingEvent objects from a remote appender over a Socket.
1487,core/pattern,ch.qos.logback.core.pattern,Class SpacePadder,
1488,classic/db,ch.qos.logback.classic.db,Class SQLBuilder,
1489,db/dialect,ch.qos.logback.core.db.dialect,Interface SQLDialect,
1490,db/dialect,ch.qos.logback.core.db.dialect,Enum SQLDialectCode,
1491,db/dialect,ch.qos.logback.core.db.dialect,Class SQLiteDialect,SQLite dialect Note that the dialect is not needed if your JDBC driver supports the getGeneratedKeys method introduced in JDBC 3.0 specification.
1492,net/ssl,ch.qos.logback.core.net.ssl,Interface SSL,Various constants used by the SSL implementation.
1493,net/ssl,ch.qos.logback.core.net.ssl,Interface SSLComponent,A interface used to identify components that have an SSL configuration.
1494,net/ssl,ch.qos.logback.core.net.ssl,Interface SSLConfigurable,An object that has configurable SSL parameters. This interface allows us o decouple the SSLParametersConfiguration from SSLSocket and SSLServerSocket to facilitate unit testing.
1495,net/ssl,ch.qos.logback.core.net.ssl,Class SSLConfigurableServerSocket,An SSLConfigurable wrapper for an SSLServerSocket.
1496,net/ssl,ch.qos.logback.core.net.ssl,Class SSLConfigurableSocket,An SSLConfigurable wrapper for an SSLSocket.
1497,net/ssl,ch.qos.logback.core.net.ssl,Class SSLConfiguration,A configuration for an SSLContext.
1498,net/ssl,ch.qos.logback.core.net.ssl,Class SSLContextFactoryBean,A factory bean for a JSSE SSLContext. This object holds the configurable properties for an SSL context and uses them to create an SSLContext instance.
1499,net/ssl,ch.qos.logback.core.net.ssl,Class SSLNestedComponentRegistryRules,Nested component registry rules for SSLConfiguration and its components.
1500,net/ssl,ch.qos.logback.core.net.ssl,Class SSLParametersConfiguration,A configuration of SSL parameters for an SSLEngine.
1501,net/server,ch.qos.logback.access.net.server,Class SSLServerSocketAppender,An appender that listens on a TCP port for connections from remote loggers. Each event delivered to this appender is delivered to all connected remote loggers.
1502,net/server,ch.qos.logback.classic.net.server,Class SSLServerSocketAppender,A ServerSocketAppender that supports SSL.
1503,net/server,ch.qos.logback.core.net.server,Class SSLServerSocketAppenderBase<E>,This is the base class for module specific ServerSocketAppender implementations.
1504,net/server,ch.qos.logback.classic.net.server,Class SSLServerSocketReceiver,A ServerSocketReceiver that supports SSL.
1505,access/net,ch.qos.logback.access.net,Class SSLSocketAppender,"A SocketAppender that supports SSL. For more information on this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#SSLSocketAppender"
1506,classic/net,ch.qos.logback.classic.net,Class SSLSocketAppender,"A SocketAppender that supports SSL. For more information on this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#SSLSocketAppender"
1507,classic/net,ch.qos.logback.classic.net,Class SSLSocketReceiver,A SocketReceiver that supports SSL.
1508,classic/spi,ch.qos.logback.classic.spi,Class StackTraceElementProxy,
1509,joran/event,ch.qos.logback.core.joran.event,Class StartEvent,
1510,event/stax,ch.qos.logback.core.joran.event.stax,Class StartEvent,
1511,access/filter,ch.qos.logback.access.filter,Interface StatisticalView,
1512,access/filter,ch.qos.logback.access.filter,Class StatisticalViewImpl,
1513,access/filter,ch.qos.logback.access.filter,Class StatsByDay,
1514,access/filter,ch.qos.logback.access.filter,Class StatsByHour,
1515,access/filter,ch.qos.logback.access.filter,Class StatsByMinute,
1516,access/filter,ch.qos.logback.access.filter,Class StatsByMonth,
1517,access/filter,ch.qos.logback.access.filter,Class StatsByWeek,
1518,core/status,ch.qos.logback.core.status,Interface Status,
1519,core/status,ch.qos.logback.core.status,Class StatusBase,
1520,access/pattern,ch.qos.logback.access.pattern,Class StatusCodeConverter,
1521,core/status,ch.qos.logback.core.status,Interface StatusListener,A StatusListener registered with logback context's StatusManager will receive notification of every incoming status message.
1522,joran/action,ch.qos.logback.core.joran.action,Class StatusListenerAction,
1523,core/status,ch.qos.logback.core.status,Class StatusListenerAsList,Collect all incoming events in a list.
1524,core/util,ch.qos.logback.core.util,Class StatusListenerConfigHelper,
1525,core/status,ch.qos.logback.core.status,Interface StatusManager,Internal error messages (statii) are managed by instances of this interface.
1526,core/util,ch.qos.logback.core.util,Class StatusPrinter,
1527,core/status,ch.qos.logback.core.status,Class StatusUtil,
1528,classic/util,ch.qos.logback.classic.util,Class StatusViaSLF4JLoggerFactory,Add a status message to the LoggerContext returned by LoggerFactory.getILoggerFactory().
1529,event/stax,ch.qos.logback.core.joran.event.stax,Class StaxEvent,
1530,event/stax,ch.qos.logback.core.joran.event.stax,Class StaxEventRecorder,
1531,classic/spi,ch.qos.logback.classic.spi,Class STEUtil,
1532,core/util,ch.qos.logback.core.util,Class StringCollectionUtil,Static utility methods for working with collections of strings.
1533,joran/util,ch.qos.logback.core.joran.util,Class StringToObjectConverter,Utility class which can convert string into objects.
1534,db/dialect,ch.qos.logback.core.db.dialect,Class SybaseSqlAnywhereDialect,
1535,classic/net,ch.qos.logback.classic.net,Class SyslogAppender,"This appender can be used to send messages to a remote syslog daemon. For more information about this appender, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#SyslogAppender"
1536,core/net,ch.qos.logback.core.net,Class SyslogAppenderBase<E>,Base class for SyslogAppender.
1537,core/net,ch.qos.logback.core.net,Class SyslogConstants,Constants used by syslog daemon and transitively by SyslogAppenderBase.
1538,core/net,ch.qos.logback.core.net,Class SyslogOutputStream,SyslogOutputStream is a wrapper around the DatagramSocket class so that it behaves like an OutputStream.
1539,classic/pattern,ch.qos.logback.classic.pattern,Class SyslogStartConverter,
1540,core/util,ch.qos.logback.core.util,Class SystemInfo,
1541,db/names,ch.qos.logback.classic.db.names,Enum TableName,
1542,classic/pattern,ch.qos.logback.classic.pattern,Class TargetLengthBasedClassNameAbbreviator,
1543,access/servlet,ch.qos.logback.access.servlet,Class TeeFilter,
1544,access/servlet,ch.qos.logback.access.servlet,Class TeeHttpServletResponse,
1545,access/servlet,ch.qos.logback.access.servlet,Class TeeServletOutputStream,
1546,chapters/layouts,chapters.layouts,Class TestException,
1547,joran/conditional,ch.qos.logback.core.joran.conditional,Class ThenAction,
1548,joran/conditional,ch.qos.logback.core.joran.conditional,Class ThenOrElseActionBase,
1549,classic/pattern,ch.qos.logback.classic.pattern,Class ThreadConverter,Return the events thread (usually the current thread).
1550,access/pattern,ch.qos.logback.access.pattern,Class ThreadNameConverter,
1551,classic/filter,ch.qos.logback.classic.filter,Class ThresholdFilter,"Filters events below the threshold level. Events with a level below the specified level will be denied, while events with a level equal or above the specified level will trigger a FilterReply.NEUTRAL result, to allow the rest of the filter chain process the event. For more information about filters, please refer to the online manual at http://logback.qos.ch/manual/filters.html#thresholdFilter"
1552,classic/pattern,ch.qos.logback.classic.pattern,Class ThrowableHandlingConverter,Converter which handle throwables should be derived from this class.
1553,classic/spi,ch.qos.logback.classic.spi,Class ThrowableProxy,
1554,classic/pattern,ch.qos.logback.classic.pattern,Class ThrowableProxyConverter,Add a stack trace in case the event contains a Throwable.
1555,classic/spi,ch.qos.logback.classic.spi,Class ThrowableProxyUtil,Convert a throwable into an array of ThrowableDataPoint objects.
1556,classic/spi,ch.qos.logback.classic.spi,Class ThrowableProxyVO,
1557,core/helpers,ch.qos.logback.core.helpers,Class ThrowableToStringArray,
1558,rolling/helper,ch.qos.logback.core.rolling.helper,Class TimeBasedArchiveRemover,
1559,core/rolling,ch.qos.logback.core.rolling,Interface TimeBasedFileNamingAndTriggeringPolicy<E>,This interface lists the set of methods that need to be implemented by triggering policies which are nested within a TimeBasedRollingPolicy.
1560,core/rolling,ch.qos.logback.core.rolling,Class TimeBasedFileNamingAndTriggeringPolicyBase<E>,
1561,core/rolling,ch.qos.logback.core.rolling,Class TimeBasedRollingPolicy<E>,"TimeBasedRollingPolicy is both easy to configure and quite powerful. It allows the roll over to be made based on time. It is possible to specify that the roll over occur once per day, per week or per month. For more information, please refer to the online manual at http://logback.qos.ch/manual/appenders.html#TimeBasedRollingPolicy"
1562,joran/action,ch.qos.logback.core.joran.action,Class TimestampAction,"Given a key and a date-and-time pattern, puts a property to the context, with the specified key and value equal to the current time in the format corresponding to the specified date-and-time pattern."
1563,core/util,ch.qos.logback.core.util,Class TimeUtil,
1564,core/subst,ch.qos.logback.core.subst,Class Token,
1565,core/subst,ch.qos.logback.core.subst,Enum Token.Type,
1566,rolling/helper,ch.qos.logback.core.rolling.helper,Class TokenConverter,TokenConverter offers some basic functionality used by more specific token converters. It basically sets up the chained architecture for tokens. It also forces derived classes to fix their type.
1567,core/subst,ch.qos.logback.core.subst,Class Tokenizer,
1568,access/tomcat,ch.qos.logback.access.tomcat,Class TomcatServerAdapter,A tomcat specific implementation of the ServerAdapter interface.
1569,core/helpers,ch.qos.logback.core.helpers,Class Transform,Utility class for transforming strings.
1570,core/rolling,ch.qos.logback.core.rolling,Interface TriggeringPolicy<E>,"A TriggeringPolicy controls the conditions under which roll-over occurs. Such conditions include time of day, file size, an external event, the log request or a combination thereof."
1571,core/rolling,ch.qos.logback.core.rolling,Class TriggeringPolicyBase<E>,SizeBasedTriggeringPolicy looks at size of the file being currently written to.
1572,chapters/migrationFromLog4j,chapters.migrationFromLog4j,Class TrivialLog4jAppender,
1573,chapters/migrationFromLog4j,chapters.migrationFromLog4j,Class TrivialLog4jLayout,A very simple log4j layout which formats a logging event by returning the message contained therein.
1574,chapters/migrationFromLog4j,chapters.migrationFromLog4j,Class TrivialLogbackAppender,
1575,chapters/migrationFromLog4j,chapters.migrationFromLog4j,Class TrivialLogbackLayout,A very simple logback-classic layout which formats a logging event by returning the message contained therein.
1576,chapters/layouts,chapters.layouts,Class TrivialMain,
1577,net/ssl,ch.qos.logback.core.net.ssl,Class TrustManagerFactoryFactoryBean,A factory bean for a JSSE TrustManagerFactory. This object holds the configurable properties of a trust manager factory and uses them to create and load a TrustManagerFactory instance.
1578,classic/layout,ch.qos.logback.classic.layout,Class TTLLLayout,A layout with a fixed format. The output is equivalent to that produced by PatternLayout with the pattern:
1579,classic/turbo,ch.qos.logback.classic.turbo,Class TurboFilter,"TurboFilter is a specialized filter with a decide method that takes a bunch of parameters instead of a single event object. The latter is cleaner but the first is much more performant. For more information about turbo filters, please refer to the online manual at http://logback.qos.ch/manual/filters.html#TurboFilter"
1580,classic/spi,ch.qos.logback.classic.spi,Class TurboFilterList,Implementation of TurboFilterAttachable.
1581,logback/core,ch.qos.logback.core,Class UnsynchronizedAppenderBase<E>,Similar to AppenderBase except that derived appenders need to handle thread synchronization on their own.
1582,access/html,ch.qos.logback.access.html,Class UrlCssBuilder,"This class helps the HTMLLayout build the CSS link. It either provides the HTMLLayout with a default css file, or builds the link to an external, user-specified, file."
1583,classic/html,ch.qos.logback.classic.html,Class UrlCssBuilder,"This class helps the HTMLLayout build the CSS link. It either provides the HTMLLayout with a default css file, or builds the link to an external, user-specified, file."
1584,access/net,ch.qos.logback.access.net,Class URLEvaluator,
1585,chapters/mdc,chapters.mdc,Class UserServletFilter,A simple servlet filter that puts the username found either in the Principal. The value is removed from the MDC once the request has been fully processed.
1586,access/servlet,ch.qos.logback.access.servlet,Class Util,
1587,access/spi,ch.qos.logback.access.spi,Class Util,
1588,classic/pattern,ch.qos.logback.classic.pattern,Class Util,
1589,logback/access,ch.qos.logback.access,Class ViewStatusMessagesServlet,
1590,logback/classic,ch.qos.logback.classic,Class ViewStatusMessagesServlet,
1591,core/status,ch.qos.logback.core.status,Class ViewStatusMessagesServletBase,
1592,core/status,ch.qos.logback.core.status,Class WarnStatus,
1593,pattern/color,ch.qos.logback.core.pattern.color,Class WhiteCompositeConverter<E>,Encloses a given set of converter output in white using the appropriate ANSI escape codes.
1594,classic/log4j,ch.qos.logback.classic.log4j,Class XMLLayout,Generates log4j.dtd compliant XML documents.
1595,joran/spi,ch.qos.logback.core.joran.spi,Class XMLUtil,
1596,pattern/color,ch.qos.logback.core.pattern.color,Class YellowCompositeConverter<E>,Encloses a given set of converter output in yellow using the appropriate ANSI escape codes.
1597,batch/android,com.batch.android,Interface AdsIdentifierProvider,
1598,batch/android,com.batch.android,Interface AdsIdentifierProvider.AdsIdentifierListener,Interface used to callback from
1599,batch/android,com.batch.android,Class AdsIdentifierProviderAvailabilityException,
1600,batch/android,com.batch.android,Class Batch,Entry point of the Batch library
1601,batch/android,com.batch.android,Class Batch.Actions,Batch Action manager
1602,batch/android,com.batch.android,Class Batch.Debug,Batch Debug module
1603,batch/android,com.batch.android,Class Batch.EventDispatcher,Batch EventDispatcher module
1604,batch/android,com.batch.android,Interface Batch.EventDispatcher.Payload,"Accessor to the payload of the dispatched event in BatchEventDispatcher#dispatchEvent(Type, Payload). Declared under Batch.EventDispatcher to avoid ambiguity with BatchEventData and BatchPushPayload."
1605,batch/android,com.batch.android,Enum Batch.EventDispatcher.Type,"Represents the type of the dispatched event in BatchEventDispatcher#dispatchEvent(Type, Payload). Declared under Batch.EventDispatcher to avoid ambiguity with BatchEventData."
1606,batch/android,com.batch.android,Class Batch.Inbox,Batch Inbox module
1607,batch/android,com.batch.android,Class Batch.Messaging,Batch Messaging module
1608,batch/android,com.batch.android,Class Batch.Messaging.DisplayHint,
1609,batch/android,com.batch.android,Interface Batch.Messaging.DisplayHintProvider,
1610,batch/android,com.batch.android,Interface Batch.Messaging.LifecycleListener,"Listener interface for messaging views lifecycle events. Implement this if you want to be notified of what happens to the messaging view (for example, perform some analytics on show/hide). You're also required to implement this if you want to add actions with a ""callback"" type."
1611,batch/android,com.batch.android,Interface Batch.Messaging.LifecycleListener2,"Listener interface for messaging events. If you'd like to opt-in to additional lifecycle events, you should implement this methods, as it gives you more control about how and when to display In-App Messages"
1612,batch/android,com.batch.android,Class Batch.Push,Batch Push module
1613,batch/android,com.batch.android,Class Batch.User,Batch User module
1614,batch/android,com.batch.android,Class BatchActionActivity,Dummy activity that starts BatchActionService or opens a deeplink
1615,batch/android,com.batch.android,Class BatchActionService,Service that Batch uses to respond to actions when not in an activity
1616,batch/android,com.batch.android,Class BatchActivityLifecycleHelper,"Implementation of android.app.Application.ActivityLifecycleCallbacks for managing Batch's lifecycle Important note: While this removes the need for most lifecycle activities, you still MUST add Batch.onNewIntent(this, intent) in all your activities"
1617,batch/android,com.batch.android,Class BatchAlertContent,Model for the content of an Alert In-App/Landing message
1618,batch/android,com.batch.android,Class BatchAlertContent.CTA,
1619,batch/android,com.batch.android,Interface BatchAttributesFetchListener,"Listener used when fetching attributes using Batch.User#fetchAttributes(Context, BatchAttributesFetchListener)."
1620,batch/android,com.batch.android,Class BatchBannerContent,Model for the content of a Banner In-App/Landing message
1621,batch/android,com.batch.android,Class BatchBannerContent.Action,
1622,batch/android,com.batch.android,Class BatchBannerContent.CTA,
1623,batch/android,com.batch.android,Class BatchBannerView,"BatchBannerView handles operations related to a Batch In-App Messaging banner, when used in manual mode. It is not actually a view that you can directly add to your hierarchy. You will have to use show(View) and dismiss(boolean) to control how it shows up."
1624,batch/android,com.batch.android,Interface BatchDeeplinkInterceptor,Abstract class describing a deeplink interceptor. An interceptor's job is to override some aspects of a deeplink that Batch wants to open. See the various methods to see what you can override.
1625,batch/android,com.batch.android,Class BatchDisplayReceiptJobService,JobService implementation of Batch Display Receipt
1626,batch/android,com.batch.android,Class BatchEventData,"Object holding data to be associated to an event Keys should be made of letters, numbers or underscores ([a-z0-9_]) and can't be longer than 30 characters."
1627,batch/android,com.batch.android,Interface BatchEventDispatcher,Interface used when listening for event to dispatch. See Batch.EventDispatcher#addDispatcher(BatchEventDispatcher) and Batch.EventDispatcher#removeDispatcher(BatchEventDispatcher).
1628,batch/android,com.batch.android,Class BatchImageContent,Model for the content of an image-only message
1629,batch/android,com.batch.android,Class BatchImageContent.Action,
1630,batch/android,com.batch.android,Class BatchInAppMessage,A subclass of BatchMessage that represents an In-App message
1631,batch/android,com.batch.android,Interface BatchInAppMessage.Content,Interface defining a BatchInAppMessage content model object. See classes implementing this interface to learn more.
1632,batch/android,com.batch.android,Class BatchInboxFetcher,"BatchInboxFetcher allows you to fetch notifications that have been sent to a user (or installation, more on that later) in their raw form, allowing you to display them in a list, for example. This is also useful to display messages to users that disabled notifications. Once you get your BatchInboxFetcher instance, you should call fetchNewNotifications(com.batch.android.BatchInboxFetcher.OnNewNotificationsFetchedListener) to fetch the initial page of messages: nothing is done automatically. This method is also useful to refresh the list. In an effort to minimize network and memory usage, messages are fetched by page (batches of messages): this allows you to easily create an infinite list, loading more messages on demand. While you can configure the maximum number of messages you want in a page, the actual number of returned messages can differ, as the SDK may filter some of the messages returned by the server (such as duplicate notifications, etc...). As BatchInboxFetcher caches answers from the server, instances of this class should be tied to the lifecycle of the UI consuming it (if applicable). For example, you should keep a reference to this object during your Activity's entire life. Another reason to keep the object around, is that you cannot mark a message as read with another BatchInbox instance that the one that gave you the message in the first place. A BatchInboxFetcher instance will hold to all fetched messages: be careful of how long you're keeping the instances around. You can also set a upper messages limit, after which BatchInbox will stop fetching new messages, even if you call fetchNextPage. Note: You will always be called back on the thread that you instantiated BatchInboxFetcher on. use setHandlerOverride(Handler) if you want to change that behaviour."
1633,batch/android,com.batch.android,Interface BatchInboxFetcher.OnNewNotificationsFetchedListener,
1634,batch/android,com.batch.android,Interface BatchInboxFetcher.OnNextPageFetchedListener,
1635,batch/android,com.batch.android,Class BatchInboxNotificationContent,BatchInboxNotificationContent is a model representing the content of an inbox notification
1636,batch/android,com.batch.android,Class BatchInterstitialContent,Model for the content of an Interstitial In-App/Landing message
1637,batch/android,com.batch.android,Class BatchInterstitialContent.CTA,
1638,batch/android,com.batch.android,Class BatchLandingMessage,A subclass of BatchMessage that represents a push landing message
1639,batch/android,com.batch.android,Class BatchMessage,Model representing a Batch Messaging message.
1640,batch/android,com.batch.android,Enum BatchMessage.Format,Formats that can be contained into a BatchMessage. This list might evolve in the future
1641,batch/android,com.batch.android,Class BatchMessageAction,Represents a BatchAction triggerable by a messaging component
1642,batch/android,com.batch.android,Class BatchMessageCTA,Represents a BatchAction triggerable by a basic CTA messaging component
1643,batch/android,com.batch.android,Class BatchMessagingException,Batch Messaging Exception. Usually wraps another exception.
1644,batch/android,com.batch.android,Class BatchModalContent,Model for the content of a modal message
1645,batch/android,com.batch.android,Class BatchModalContent.Action,
1646,batch/android,com.batch.android,Class BatchModalContent.CTA,
1647,batch/android,com.batch.android,Class BatchNotificationAction,Represents a Notification Action button
1648,batch/android,com.batch.android,Class BatchNotificationChannelsManager,"BatchNotificationChannelsManager manages how Batch interacts with Android 8.0 (API 26). It allows you to control which default notification channel Batch will use, how it is named, or to provide your own channel per notification"
1649,batch/android,com.batch.android,Interface BatchNotificationChannelsManager.ChannelNameProvider,"Interface describing a channel name provider. Implementing that interface allows Batch to call you back on locale change, to update your channel name translation."
1650,batch/android,com.batch.android,Interface BatchNotificationChannelsManager.NotificationChannelIdInterceptor,Interface describing a channel ID interceptor for notifications displayed by Batch
1651,batch/android,com.batch.android,Class BatchNotificationChannelsManager.StringResChannelNameProvider,Implementation of ChannelNameProvider using a String resource to automatically fetch the right translation.
1652,batch/android,com.batch.android,Class BatchNotificationInterceptor,Abstract class describing a notification interceptor. An interceptor's job is to override some aspects of a notification that Batch wants to display. See the various methods to see what you can override.
1653,batch/android,com.batch.android,Enum BatchNotificationSource,"BatchNotificationSource represents how the push was sent from Batch: via the Transactional API, or using a Push Campaign The value might be unknown for forward compatibility, or if the information was missing."
1654,batch/android,com.batch.android,Interface BatchOptOutResultListener,Interface describing a listener for server-side Opt-Out/Opt-Out and wipe acknowledgment
1655,batch/android,com.batch.android,Enum BatchOptOutResultListener.ErrorPolicy,
1656,batch/android,com.batch.android,Class BatchPushData,Deprecated. Use BatchPushPayload
1657,batch/android,com.batch.android,Class BatchPushInstanceIDService,Batch's service for handling Google's Instance ID token refresh
1658,batch/android,com.batch.android,Class BatchPushJobService,JobService implementation of Batch Push
1659,batch/android,com.batch.android,Class BatchPushMessageDismissReceiver,Batch's implementation of dismiss intent of push notification
1660,batch/android,com.batch.android,Class BatchPushMessageReceiver,Batch's implementation of GCM's Push BroadcastReceiver
1661,batch/android,com.batch.android,Class BatchPushPayload,Convenience object to retrieve standardized Batch data out of a Batch Push intent. This class does not have a public constructor. You must use payloadFromBundle(Bundle) or payloadFromReceiverIntent(Intent)
1662,batch/android,com.batch.android,Class BatchPushPayload.ParsingException,Represents a payload parsing exception. This usually means that the given bundle or receiver intent doesn't contain data that BatchPushPayload understands.
1663,batch/android,com.batch.android,Class BatchPushReceiver,Batch's legacy implementation of GCM's Push BroadcastReceiver
1664,batch/android,com.batch.android,Class BatchPushService,"Batch's service for handling the push messages and show a notification This is a legacy implementation, and should not be used on versions higher than Android O"
1665,batch/android,com.batch.android,Interface BatchTagCollectionsFetchListener,"Listener used when fetching tag collections using Batch.User#fetchTagCollections(Context, BatchTagCollectionsFetchListener)."
1666,batch/android,com.batch.android,Class BatchUserAttribute,
1667,batch/android,com.batch.android,Enum BatchUserAttribute.Type,
1668,batch/android,com.batch.android,Class BatchUserDataEditor,Batch User data editor
1669,batch/android,com.batch.android,Class BatchUserProfile,Deprecated. Please use Batch.User methods instead
1670,batch/android,com.batch.android,Class Config,Class to build a configuration for Batch SDK
1671,batch/android,com.batch.android,Enum FailReason,Reason for Batch failure
1672,batch/android,com.batch.android,Interface InAppMessageUserActionSource,Represents an In-App Message user action source.
1673,android/json,com.batch.android.json,Class JSONArray,"A dense indexed sequence of values. Values may be any mix of JSONObject, other JSONArray, Strings, Booleans, Integers, Longs, Doubles, null or JSONObject#NULL. Values may not be NaNs, infinities, or of any type not listed here. JSONArray has the same type coercion behavior and optional/mandatory accessors as JSONObject. See that class' documentation for details. Warning: this class represents null in two incompatible ways: the standard Java null reference, and the sentinel value JSONObject#NULL. In particular, get fails if the requested index holds the null reference, but succeeds if it holds JSONObject.NULL. Instances of this class are not thread safe. Although this class is nonfinal, it was not designed for inheritance and should not be subclassed. In particular, self-use by overridable methods is not specified. See Effective Java Item 17, ""Design and Document or inheritance or else prohibit it"" for further information."
1674,android/json,com.batch.android.json,Class JSONException,"Thrown to indicate a problem with the JSON API. Such problems include: Attempts to parse or construct malformed documents Use of null as a name Use of numeric types not available to JSON, such as NaNs or infinities. Lookups using an out of range index or nonexistent name Type mismatches on lookups Although this is a checked exception, it is rarely recoverable. Most callers should simply wrap this exception in an unchecked exception and rethrow: public JSONArray toJSONObject() { try { JSONObject result = new JSONObject(); ... } catch (JSONException e) { throw new RuntimeException(e); } }"
1675,android/json,com.batch.android.json,Class JSONHelper,Helper json methods that don't belong in JSON
1676,android/json,com.batch.android.json,Class JSONObject,"A modifiable set of name/value mappings. Names are unique, non-null strings. Values may be any mix of JSONObject, JSONArray, Strings, Booleans, Integers, Longs, Doubles or NULL. Values may not be null, NaNs, infinities, or of any type not listed here. This class can coerce values to another type when requested. When the requested type is a boolean, strings will be coerced using a case-insensitive comparison to ""true"" and ""false"". When the requested type is a double, other Number types will be coerced using doubleValue. Strings that can be coerced using Double.valueOf(String) will be. When the requested type is an int, other Number types will be coerced using intValue. Strings that can be coerced using Double.valueOf(String) will be, and then cast to int. When the requested type is a long, other Number types will be coerced using longValue. Strings that can be coerced using Double.valueOf(String) will be, and then cast to long. This two-step conversion is lossy for very large values. For example, the string ""9223372036854775806"" yields the long 9223372036854775807.When the requested type is a String, other non-null values will be coerced using String.valueOf(Object). Although null cannot be coerced, the sentinel value JSONObject#NULL is coerced to the string ""null"". This class can look up both mandatory and optional values: Use getType() to retrieve a mandatory value. This fails with a JSONException if the requested name has no value or if the value cannot be coerced to the requested type. Use optType() to retrieve an optional value. This returns a system- or user-supplied default if the requested name has no value or if the value cannot be coerced to the requested type. Warning: this class represents null in two incompatible ways: the standard Java null reference, and the sentinel value JSONObject#NULL. In particular, calling put(name, null) removes the named entry from the object but put(name, JSONObject.NULL) stores an entry whose value is JSONObject.NULL. Instances of this class are not thread safe. Although this class is nonfinal, it was not designed for inheritance and should not be subclassed. In particular, self-use by overrideable methods is not specified. See Effective Java Item 17, ""Design and Document or inheritance or else prohibit it"" for further information."
1677,android/json,com.batch.android.json,Class JSONStringer,"Implements JSONObject#toString and JSONArray#toString. Most application developers should use those methods directly and disregard this API. For example: JSONObject object = ... String json = object.toString();Stringers only encode well-formed JSON strings. In particular: The stringer must have exactly one top-level array or object. Lexical scopes must be balanced: every call to array() must have a matching call to endArray() and every call to object() must have a matching call to endObject(). Arrays may not contain keys (property names). Objects must alternate keys (property names) and values. Values are inserted with either literal value calls, or by nesting arrays or objects. Calls that would result in a malformed JSON string will fail with a JSONException. This class provides no facility for pretty-printing (ie. indenting) output. To encode indented output, use JSONObject#toString(int) or JSONArray#toString(int). Some implementations of the API support at most 20 levels of nesting. Attempts to create more than 20 levels of nesting may fail with a JSONException. Each stringer may be used to encode a single top level value. Instances of this class are not thread safe. Although this class is nonfinal, it was not designed for inheritance and should not be subclassed. In particular, self-use by overrideable methods is not specified. See Effective Java Item 17, ""Design and Document or inheritance or else prohibit it"" for further information."
1678,android/json,com.batch.android.json,Class JSONTokener,"Parses a JSON (RFC 4627) encoded string into the corresponding object. Most clients of this class will use only need the constructor and nextValue() method. Example usage: String json = ""{"" + "" \""query\"": \""Pizza\"", "" + "" \""locations\"": [ 94043, 90210 ] "" + ""}""; JSONObject object = (JSONObject) new JSONTokener(json).nextValue(); String query = object.getString(""query""); JSONArray locations = object.getJSONArray(""locations"");For best interoperability and performance use JSON that complies with RFC 4627, such as that generated by JSONStringer. For legacy reasons this parser is lenient, so a successful parse does not indicate that the input string was valid JSON. All of the following syntax errors will be ignored: End of line comments starting with // or # and ending with a newline character. C-style comments starting with /* and ending with */. Such comments may not be nested. Strings that are unquoted or 'single quoted'. Hexadecimal integers prefixed with 0x or 0X. Octal integers prefixed with 0. Array elements separated by ;. Unnecessary array separators. These are interpreted as if null was the omitted value. Key-value pairs separated by = or =>. Key-value pairs separated by ;. Each tokener may be used to parse a single JSON string. Instances of this class are not thread safe. Although this class is nonfinal, it was not designed for inheritance and should not be subclassed. In particular, self-use by overrideable methods is not specified. See Effective Java Item 17, ""Design and Document or inheritance or else prohibit it"" for further information."
1679,batch/android,com.batch.android,Interface LoggerDelegate,Interface declaring methods that needs to be implemented for a Logger delegate. Works in a way very similar to android.util.Log.
1680,batch/android,com.batch.android,Enum LoggerLevel,
1681,batch/android,com.batch.android,Class MessagingActivity,Activity that only lives to display a messaging fragment
1682,batch/android,com.batch.android,Enum PushNotificationType,Enum that define how notifications should be display
1683,batch/android,com.batch.android,Interface PushRegistrationProvider,Defines a push notification registration provider
1684,batch/android,com.batch.android,Class PushRegistrationProviderAvailabilityException,
1685,batch/android,com.batch.android,Interface PushUserActionSource,Represents a push user action source
1686,batch/android,com.batch.android,Class UserAction,"Model that represents an user action, which can be triggered by Batch SDK in various contexts."
1687,batch/android,com.batch.android,Interface UserActionRunnable,"Represents an UserAction's runnable. Similar to Runnable, but with specific contextual arguments."
1688,batch/android,com.batch.android,Interface UserActionSource,Represents an action source.
